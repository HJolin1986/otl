<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Oracle Call Interface Template Library 1.0.5 (OTL), Pro*OTL /
Pre-Pro*C preprocessor 1.0.0 (PPC)</title>
</head>
<body>
<h1>Oracle Call Interface Template Library 1.0.5 (OTL), Pro*OTL /
Pre-Pro*C preprocessor 1.0.0 (PPC)</h1>
<p><i>Sergei Kuchin, email:
<a href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.com</a></i>
</p>
<xmp>
Copyright (C) Sergei Kuchin, 1996, 1997,1998
Permission to use, copy, modify and redistribute this
document for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all
copies.
</xmp>
<h2><a href="mailto:skuchin@gmail.com">Table of Contents</a></h2>
<ul>
  <li><a href="#sec1">1. Introduction</a>
  </li>
  <li><a href="#sec2">2. Getting started with OTL</a>
    <ul>
      <li><a href="#sec21">2.1. Examples</a>
        <ul>
          <li><a href="#sec211">2.1.1. Example 1 (with ordinary,
non-template host variables)</a>
          </li>
          <li><a href="#sec212">2.1.2. Example 2 (with template
instantiated host variables)</a>
          </li>
          <li><a href="#sec213">2.1.3. Example 3 (with the extended
"parse" function)</a>
          </li>
          <li><a href="#sec214">2.1.4. Example 4 (with Oracle LONG
columns)</a>
          </li>
          <li><a href="#sec215">2.1.5. Example 5 (with the
otl_select_stream class)</a>
          </li>
          <li><a href="#sec216">2.1.6. Example 6 (with the
otl_out_stream class)</a>
          </li>
          <li><a href="#sec217">2.1.7. Example 7 (with the
otl_inout_stream class)</a>
          </li>
          <li><a href="#sec217">2.1.8. Example 8 (with the otl_stream
class)</a>
          </li>
          <li><a href="#sec219">2.1.9. Example 9 (with PL/SQL block)</a>
          </li>
          <li><a href="#sec2110">2.1.10. Example 10 (with printf/scanf
functions)</a>
          </li>
          <li><a href="#sec2111">2.1.11. Example 11 (with Prosto*C)</a>
          </li>
        </ul>
      </li>
      <li><a href="#sec22">2.2. Comparison with the other C++/database
libraries</a>
        <ul>
          <li>
            <a href="#sec221">2.2.1. OTL vs. SQLObjects (by Intelligent
Objects)</a>
          </li>
          <li>
            <a href="#sec222">2.2.2. OTL vs. DBTools.h++ (by Rogue Wave)</a>
          </li>
        </ul>
      </li>
      <li><a href="#sec3">3. Library structure</a>
        <ul>
          <li><a href="#sec31">3.1. Host variable and array template
classes</a>
            <ul>
              <li><a href="#sec311">3.1.1. Specialized host variable
classes</a>
              </li>
              <li><a href="#sec312">3.1.2. Specialized host array
classes</a>
              </li>
            </ul>
          </li>
          <li><a href="#sec32">3.2. Oracle Call Interface "wrapper"</a>
            <ul>
              <li><a href="#sec103">Class otl_exception</a>
              </li>
              <li><a href="#sec104">Class otl_object</a>
              </li>
              <li><a href="#sec105">Class otl_connect</a>
              </li>
              <li><a href="#sec106">Class otl_column_desc</a>
              </li>
              <li><a href="#sec107">Class otl_cursor</a>
              </li>
              <li><a href="#sec108">Class otl_select_cursor</a>
              </li>
              <li><a href="#sec200">Class otl_dynamic_variable</a>
              </li>
              <li><a href="#sec109">Class otl_err_info</a>
              </li>
            </ul>
          </li>
          <li><a href="#sec33">3.3. OTL stream interface</a>
            <ul>
              <li><a href="#sec201">Class otl_select_stream</a>
              </li>
              <li><a href="#sec202">Class otl_out_stream</a>
              </li>
              <li><a href="#sec203">Class otl_inout_stream</a>
              </li>
              <li><a href="#sec204">Class otl_stream</a>
              </li>
              <li><a href="#sec205">Stream bind variable declarations</a>
              </li>
            </ul>
          </li>
          <li><a href="#sec34">3.4. Prosto*C</a>
          </li>
        </ul>
      </li>
      <li><a href="#sec4">4. Pro*OTL / Pre-Pro*C preprocessor (PPC)</a>
        <ul>
          <li><a href="#sec41">4.1. Getting started with PPC</a>
            <ul>
              <li><a href="#sec411">Example in Pro*C</a>
              </li>
              <li><a href="#sec412">Example in C++</a>
              </li>
            </ul>
          </li>
          <li><a href="#sec42">4.2. Directives</a>
            <ul>
              <li><a href="#sec421">4.2.1. #sql-select</a>
              </li>
              <li><a href="#sec422">4.2.2. #sql-out-stm</a>
              </li>
              <li><a href="#sec423">4.2.3. #sql-plsql</a>
              </li>
              <li><a href="#sec424">4.2.4. #sql-init-module</a>
              </li>
              <li><a href="#sec425">4.2.5. #sql-init-main</a>
              </li>
              <li><a href="#sec426">4.2.6. #sql-str-type</a>
              </li>
            </ul>
          </li>
          <li><a href="#sec43">4.3. Command line parameters</a>
          </li>
        </ul>
      </li>
      <li><a href="#sec5">5. Acknowledgements</a>
      </li>
      <li><a href="#sec6">6. Bibliography</a>
      </li>
      <li><a href="#secA">Appendix A. OTL class hierarchy</a>
      </li>
      <li><a href="#secB">Appendix B. Error message list</a>
      </li>
      <li><a href="#secC">Appendix C. OTL source code (otl.h)</a>
      </li>
      <li><a href="#secD">Appendix D. Pro*OTL / Pre-Pro*C
preprocessor's source code (ppc.C or ppc.cpp)</a>
      </li>
      <li><a href="#secE">Appendix E. How to install the OTL
library and Pro*OTL/Pre-Pro*C preprocessor</a>
      </li>
      <li><a href="#secF">Appendix F. Modules, generated by PPC for the
example from Chapter 4.</a>
        <ul>
          <li><a href="#secF1">Pro*C module (ppc_test.pc)</a>
          </li>
          <li><a href="#secF2">C++ module (ppc_test.C)</a>
          </li>
          <li><a href="#secF3">Interface header file (ppc_test.h)</a>
          </li>
          <li><a href="#secF4">Command line for the example from
Chapter 4.</a>
          </li>
        </ul>
      </li>
    </ul>
    <h2><a name="sec1">1. Introduction</a></h2>
    <p>
    <a name="sec1">This document provides information on the Oracle
Call Interface
Template Library (OTL). OTL is a new kind of C++ libraries, similar to
the Standard Template Library. This kind of libraries is easy to use,
since the user needs only to include C++ header files which contain
template classes and functions. There is no need to link additional
object libraries into C++ applications. The code, instantiated from
template classes and inline functions, is efficient and reliable in
terms of runtime performance and C++ strict type checking.
    </a></p>
    <p>
    <a name="sec1">OTL comprises of a set of template classes. The
templates allow the
user to create scalar host variables and host arrays, then dynamically
bind the variables and arrays with SQL statements or PL/SQL
blocks. OTL has a number of non-template classes which encapsulate the
Oracle Call Interface (OCI) functions and provide transparent
programming interface to them. </a></p>
    <p>
    <a name="sec1">OTL provides an optional exception handling
mechanism, given in the
form of the otl_exception class. This mechanism takes advantage of C++
exceptions compared to coding database applications in plain C. The
user does not need to check out return codes after each function
call. The code, instantiated from the OTL templates and inline
functions, is much nicer and cleaner in comparison with the code
generated by the Pro*C precompiler.
    </a></p>
    <p>
    <a name="sec1">In OTL, a concept of </a><a href="#sec33">SQL
streams</a> is
introduced. The SQL programming interface becomes unified and
homogeneous.
    </p>
    <p>
OTL has a simplified set of functions, called <a href="#sec34">Prosto*C</a>.
It provides basic functions, such as
connect/disconnect, printf/scanf, commit/rollback, etc. The word
"Prosto*C" is originated in the author's native language: "prosto"
means "simple". The idea here is to simplify the interface as much as
possible, without losing the functionality.
    </p>
    <p>
OTL is a database access function library. Also, this document
describes the <a href="#sec4">Pro*OTL / Pre-Pro*C
preprocessor</a> (PPC). PPC is a preprocessor which takes a directive
file on input and generates OTL and Pro*C code on output. Besides, PPC
produces a header file with prototypes of the generated functions and
data structures, used by the functions. The generated functions are
the "executable" form of the directives. The directives are more
declarative and much more compact than the corresponding
functions. The generated header file can be included in both C++ and
plain C modules.
    </p>
    <p>OTL, as a library, and PPC, as a preprocessor, are intended to
boost
productivity of Oracle database developers who work with C++ as well
as Pro*C. PPC is a pathway from traditional Pro*C to more advanced
C++ database APIs.
    </p>
    <p>
OTL and PPC compile with the following 32-bit C++ compilers:
    </p>
    <ul>
      <li>IBM AIX, C++ (xlC), 1.x and higher</li>
      <li>SunOS/Solaris, Sun C++, 4.x</li>
      <li>Unix, GNU C++ (g++), 2.7.x </li>
      <li>Windows 95, NT, Visual C++, 4.x, 32-bit</li>
    </ul>
    <p>
The author is hoping to get feedback from potential users of OTL and
that the OTL source code is clean enough to be ported across the
32-bit platforms, different from the mentioned above. </p>
    <p>
Besides, the author's goal is to eventually find a sponsor to make
this product commercial, in order to enhance, maintaion and support it
on the regular basis.
    </p>
    <p>
Despite the common opinion that Freeware products are not that good
and badly supported, the author believes that OTL &amp; PPC have
production quality and can be used successfully.
    </p>
The OTL source code resides in <a href="#secC">Appendix C</a>, PPC --
in <a href="#secD">Appendix D</a>. The whole page may be downloaded,
in order to get the source code. Examples may be clipped from the
text, copied to separate files and used. Comments and questions would
be appreciated very much. Email to <a href="mailto:skuchin@gmail.com">skuchin@gmail.com<gmailr></gmailr></a><a
 href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>.
    <p></p>
    <h2><a name="sec2">2. Getting started with OTL</a></h2>
    <h2><a name="sec21">2.1. Examples</a></h2>
    <p>
    <a name="sec21">Let's assume you want to create a table, fill it
out with a hundred
records and then select some of them. This may be accomplished by the
following code.
    </a></p>
    <h3><a name="sec211">2.1.1. Example 1 (with ordinary, non-template
host variables)</a></h3>
    <h4><a name="sec211">Source code</a></h4>
    <xmp><a name="sec211">
#include &lt;iostream&gt;
using namespace std;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
const int BUF_SIZE=50; // host array size
const int STR_SIZE=31; // string size
void insert() // insert rows into table
{ float f1[BUF_SIZE]; // float host array f1 without indicators char
f2[BUF_SIZE][STR_SIZE]; // string host array f2 without indicators
otl_cursor o(db); // create cursor int n=0; o.parse("insert into
test_tab values(:f1,:f2)"); // parse sql statement
o.bind_float(":f1",f1); // bind f1
o.bind_cstring(":f2",(char*)f2,STR_SIZE); // bind f2 for(int
i=1;i&lt;=100;++i){ ++n; f1[n-1]=i; // fill out host array f1
sprintf(f2[n-1],"Name%d",i); // fill out host array f2 if(n==BUF_SIZE){
// execute the sql statement when buffer gets // full o.exec(n); n=0; }
} if(n&gt;0) o.exec(n); db.commit(); // commit transaction
} /* insert */
void select()
{ float f1[BUF_SIZE]; // float host array f1 without indicators char
f2[BUF_SIZE][STR_SIZE]; // string host array f2 without indicators int
f; // host variable f without indicator otl_select_cursor
i(db,BUF_SIZE); // create specialized select cursor i.parse("select *
from test_tab where f1&gt;=:f and f1&lt;=:f*2"); // parse select
statement i.bind_float(1,f1); // bind f1 to column 1
i.bind_cstring(2,(char*)f2,STR_SIZE); // bind f2 to column 2
i.bind_int(":f",&amp;f); // bind f f=8; // assign 8 to f
while(i.next()){ // while not end-of-data int k=i.cur_row; // index of
current row in host arrays cout&lt;&lt;"f1="&lt;&lt;f1[k]&lt;&lt;",
f2="&lt;&lt;f2[k]&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ cerr&lt;&lt;p.msg&lt;&lt;endl; // print out error message }
db.logoff(); //disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec211">Output</a></h4>
    <xmp><a name="sec211">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
    </a></xmp>
    <h3><a name="sec212">2.1.2. Example 2 (with template instantiated
host variables)</a></h3>
    <h4><a name="sec212">Source code</a></h4>
    <xmp><a name="sec212">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
const int BUF_SIZE=50; // host array size
const int STR_SIZE=31; // string size
void insert()
// insert rows into table
{ otl_float_array&lt;BUF_SIZE&gt; f1; // float host array f1
otl_cstring_array&lt;BUF_SIZE,STR_SIZE&gt; f2; // C-string host array
f2 otl_cursor o(db); // create cursor int n=0; o.parse("insert into
test_tab values(:f1,:f2)"); // parse sql statement o.bind(":f1",f1); //
bind f1 o.bind(":f2",f2); // bind f2 for(int i=1;i&lt;=100;++i){ ++n;
f1.v[n-1]=i; // fill out host array f1 sprintf(f2.v[n-1],"Name%d",i);
// fill out host array f2 if(n==BUF_SIZE){ // execute sql statement
when buffer gets // full o.exec(n); n=0; } } if(n&gt;0) o.exec(n);
db.commit(); // commit transaction
} /* insert */
void select()
{ otl_float_array&lt;BUF_SIZE&gt; f1; // float host array f1
otl_cstring_array&lt;BUF_SIZE,STR_SIZE&gt; f2; // string host array f2
otl_int f; // host variable f otl_select_cursor i(db,BUF_SIZE); //
create specialized select cursor i.parse("select * from test_tab where
f1&gt;=:f and f1&lt;=:f*2"); // parse select statement i.bind(1,f1); //
bind f1 to column 1 i.bind(2,f2); // bind f2 to column 2
i.bind(":f",f); // bind f. f is input variable f.v=8; // assign 8 to f
while(i.next()){ // while not end-of-data int k=i.cur_row; // index of
current row in host arrays cout&lt;&lt;"f1="&lt;&lt;f1.v[k]&lt;&lt;",
f2="&lt;&lt;f2.v[k]&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec212">Output</a></h4>
    <xmp><a name="sec212">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
    </a></xmp>
    <h3><a name="sec213">2.1.3. Example 3 (with the extended "parse"
function)</a></h3>
    <h4><a name="sec213">Source code</a></h4>
    <xmp><a name="sec213">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
const int BUF_SIZE=50; // host array size
const int STR_SIZE=31; // string size
void insert()
// insert rows into table
{ otl_float_array&lt;BUF_SIZE&gt; f1(":f1"); // float host array f1
otl_cstring_array&lt;BUF_SIZE,STR_SIZE&gt; f2(":f2"); // C-string host
array f2 otl_cursor o(db); // create cursor int n=0; o.eparse("insert
into test_tab values(:f1,:f2)",&amp;f1,&amp;f2,0); // parse sql
statement and bind variables f1 and f2 with the // statement. the
variable list is NULL terminated for(int i=1;i&lt;=100;++i){ ++n;
f1.v[n-1]=i; // fill out host array f1 sprintf(f2.v[n-1],"Name%d",i);
// fill out host array f2 if(n==BUF_SIZE){ // execute sql statement
when buffer gets // full o.exec(n); n=0; } } if(n&gt;0) o.exec(n);
db.commit(); // commit transaction
} /* insert */
void select()
{ otl_float_array&lt;BUF_SIZE&gt; f1; // float host array f1
otl_cstring_array&lt;BUF_SIZE,STR_SIZE&gt; f2; // string host array f2
otl_int f(":f"); // host variable f otl_select_cursor i(db,BUF_SIZE);
// create specialized select cursor i.eparse("select * from test_tab
where f1&gt;=:f and f1&lt;=:f*2",&amp;f1,&amp;f2,&amp;f,0); // parse
select statement, bind input variable f and output columns // f1, f2
with the statement. f1 is treated as column 1 in the // select list, f2
-- as column 2. The variable list is NULL terminated f.v=8; // assign 8
to f while(i.next()){ // while not end-of-data int k=i.cur_row; //
index of current row in host arrays
cout&lt;&lt;"f1="&lt;&lt;f1.v[k]&lt;&lt;",
f2="&lt;&lt;f2.v[k]&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec213">Output</a></h4>
    <xmp><a name="sec213">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
    </a></xmp>
    <h3><a name="sec214">2.1.4. Example 4 (with Oracle LONG columns)</a></h3>
    <h4><a name="sec214">Source code</a></h4>
    <xmp><a name="sec214">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
const int BUF_SIZE=50; // host array size
const int LONG_STR_SIZE=2000; // LONG string size
void insert()
// insert rows into table
{ otl_float f1(":f1"); // float host variable f1
otl_long_varchar&lt;LONG_STR_SIZE&gt; f2(":f2"); // long varchar host
variable f2 otl_cursor o(db); // create cursor o.eparse("insert into
test_tab values(:f1,:f2)",&amp;f1,&amp;f2,0); // parse sql statement
and bind variables f1 and f2 with the // statement. the variable list
is NULL terminated for(int i=1;i&lt;=9;++i){ f1.v=i; // assign host
variable f1 f2.set_len(5); // set the long_varchar string length
f2[0]='N'; f2[1]='a'; f2[2]='m'; f2[3]='e'; f2[4]='0'+i; o.exec();
db.commit(); // commit transaction }
} /* insert */
void select()
{ otl_float f1; // float f1 otl_long_varchar&lt;LONG_STR_SIZE&gt; f2;
otl_int f(":f"); // host variable f otl_select_cursor i(db); // create
specialized select cursor i.eparse("select * from test_tab where
f1&gt;=:f and f1&lt;=:f*2",&amp;f1,&amp;f2,&amp;f,0); // parse select
statement, bind input variable f and output columns // f1, f2 with the
statement. f1 is treated as column 1 in the // select list, f2 -- as
column 2. The variable list is NULL terminated f.v=4; // assign 4 to f
while(i.next()){ // while not end-of-data
cout&lt;&lt;"f1="&lt;&lt;f1.v&lt;&lt;", f2="; for(int
j=0;j&lt;f2.len();++j) cout&lt;&lt;f2[j]; // print out the long_varchar
string cout&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
long)" ); // create table insert(); // insert records into table
select(); // select records from table } catch(otl_exception&amp; p){
// intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print out
error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec214">Output</a></h4>
    <xmp><a name="sec214">
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec215">2.1.5. Example 5 (with the otl_select_stream
class)</a></h3>
    <h4><a name="sec215">Source code</a></h4>
    <xmp><a name="sec215">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
const int BUF_SIZE=50; // host array size
const int STR_SIZE=31; // string size
void insert()
// insert rows into table
{ otl_float_array&lt;BUF_SIZE&gt; f1(":f1"); // float host array f1
otl_cstring_array&lt;BUF_SIZE,STR_SIZE&gt; f2(":f2"); // C-string host
array f2 otl_cursor o(db); // create cursor int n=0; o.eparse("insert
into test_tab values(:f1,:f2)",&amp;f1,&amp;f2,0); // parse sql
statement and bind variables f1 and f2 with the // statement. the
variable list is NULL terminated for(int i=1;i&lt;=100;++i){ ++n;
f1.v[n-1]=i; // fill out host array f1 sprintf(f2.v[n-1],"Name%d",i);
// fill out host array f2 if(n==BUF_SIZE){ // execute sql statement
when buffer gets // full o.exec(n); n=0; } } if(n&gt;0) o.exec(n);
db.commit(); // commit transaction
} /* insert */
void select()
{ otl_int f(":f"); // host variable f otl_select_stream i(db, "select *
from test_tab where f1&gt;=:f and f1&lt;=:f*2", BUF_SIZE, // size of
the buffer attached to the // stream &amp;f, // input variable :f2 0 //
NULL terminator of the variable list ); // create select stream int f1;
char f2[STR_SIZE]; f.v=8; // assign 8 to f i.rewind(); // rewind the
stream: re-execute the statement and fetch // first portion of rows.
while(!i.eof()){ // while not end-of-data i&gt;&gt;f1&gt;&gt;f2;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
f.v=4; // assign 4 to f i.rewind(); // rewind the stream: re-execute
the statement and fetch // first portion of rows. while(!i.eof()){ //
while not end-of-data i&gt;&gt;f1&gt;&gt;f2;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec215">Output</a></h4>
    <xmp><a name="sec215">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec216">2.1.6. Example 6 (with the otl_out_stream
class)</a></h3>
    <h4><a name="sec216">Source code</a></h4>
    <xmp><a name="sec216">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
const int BUF_SIZE=50; // host array size
const int STR_SIZE=31; // string size
void insert()
// insert rows into table
{ otl_float_array&lt;BUF_SIZE&gt; f1(":f1"); // float host array f1
otl_cstring_array&lt;BUF_SIZE,STR_SIZE&gt; f2(":f2"); // C-string host
array f2 otl_out_stream o(db, // connect object "insert into test_tab
values(:f1,:f2)", // SQL statement &amp;f1, // bind variable :f1
&amp;f2, // bind variable :f2 0 // end of variable list ); char
tmp[31]; for(int i=1;i&lt;=100;++i){ sprintf(tmp,"Name%d",i);
o&lt;&lt;(float)i&lt;&lt;tmp; }
} /* insert */
void select()
{ otl_int f(":f"); // host variable f otl_select_stream i(db, "select *
from test_tab where f1&gt;=:f and f1&lt;=:f*2", BUF_SIZE, // size of
the buffer attached to the // stream &amp;f, // input variable :f2 0 //
NULL terminator of the variable list ); // create select stream int f1;
char f2[STR_SIZE]; f.v=8; // assign 8 to f i.rewind(); // rewind the
stream: re-execute the statement and fetch // first portion of rows.
while(!i.eof()){ // while not end-of-data i&gt;&gt;f1&gt;&gt;f2;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
f.v=4; // assign 4 to f i.rewind(); // rewind the stream: re-execute
the statement and fetch // first portion of rows. while(!i.eof()){ //
while not end-of-data i&gt;&gt;f1&gt;&gt;f2;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec216">Output</a></h4>
    <xmp><a name="sec216">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec217">2.1.7. Example 7 (with the otl_inout_stream
class)</a></h3>
    <h4><a name="sec217">Source code</a></h4>
    <xmp><a name="sec217">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
void insert()
// insert rows into table
{ otl_inout_stream o(50, // buffer size "insert into test_tab
values(:f1&lt;float&gt;,:f2&lt;char[31]&gt;)", // SQL statement db //
connect object ); char tmp[32]; for(int i=1;i&lt;=100;++i){
sprintf(tmp,"Name%d",i); o&lt;&lt;(float)i&lt;&lt;tmp; }
} /* insert */
void select()
{ otl_select_stream i(50, // buffer size "select * from test_tab where
f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2", // SELECT statement db //
connect object ); // create select stream int f1; char f2[31];
i&lt;&lt;8; // assigning :f = 8 // SELECT automatically executes when
all input variables are // assigned. First portion of out rows is
fetched to the buffer while(!i.eof()){ // while not end-of-data
i&gt;&gt;f1&gt;&gt;f2; cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;",
f2="&lt;&lt;f2&lt;&lt;endl; } i&lt;&lt;4; // assigning :f = 4 // SELECT
automatically re-executes when all input variables are // assigned.
First portion of out rows is fetched to the buffer while(!i.eof()){ //
while not end-of-data i&gt;&gt;f1&gt;&gt;f2;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec217">Output</a></h4>
    <xmp><a name="sec217">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec218">2.1.8. Example 8 (with the otl_stream class)</a></h3>
    <h4><a name="sec218">Source code</a></h4>
    <xmp><a name="sec218">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
void insert()
// insert rows into table
{ otl_stream o(50, // buffer size "insert into test_tab
values(:f1&lt;float&gt;,:f2&lt;char[31]&gt;)", // SQL statement db //
connect object ); char tmp[32]; for(int i=1;i&lt;=100;++i){
sprintf(tmp,"Name%d",i); o&lt;&lt;(float)i&lt;&lt;tmp; }
} /* insert */
void select()
{ otl_stream i(50, // buffer size "select * from test_tab where
f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2", // SELECT statement db //
connect object ); // create select stream int f1; char f2[31];
i&lt;&lt;8; // assigning :f = 8 // SELECT automatically executes when
all input variables are // assigned. First portion of out rows is
fetched to the buffer while(!i.eof()){ // while not end-of-data
i&gt;&gt;f1&gt;&gt;f2; cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;",
f2="&lt;&lt;f2&lt;&lt;endl; } i&lt;&lt;4; // assigning :f = 4 // SELECT
automatically re-executes when all input variables are // assigned.
First portion of out rows is fetched to the buffer while(!i.eof()){ //
while not end-of-data i&gt;&gt;f1&gt;&gt;f2;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec218">Output</a></h4>
    <xmp><a name="sec218">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec219">2.1.9. Example 9 (with PL/SQL block)</a></h3>
    <h4><a name="sec219">Source code</a></h4>
    <xmp><a name="sec219">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
void plsql()
// invoking PL/SQL block
{ otl_stream o(5, // buffer size "begin " " :A&lt;int,inout&gt; :=
:A+1; " " :B&lt;char[31],out&gt; := :C&lt;char[31],in&gt;; " "end;", //
PL/SQL block db // connect object ); o&lt;&lt;1&lt;&lt;"Test String1";
// assigning :A = 1, :C = "Test String1" o&lt;&lt;2&lt;&lt;"Test
String2"; // assigning :A = 2, :C = "Test String2"
o&lt;&lt;3&lt;&lt;"Test String3"; // assigning :A = 3, :C = "Test
String3" o.flush(); // executing PL/SQL block 3 times int a; char
b[32]; while(!o.eof()){ // not end-of-data o&gt;&gt;a&gt;&gt;b;
cout&lt;&lt;"A="&lt;&lt;a&lt;&lt;", B="&lt;&lt;b&lt;&lt;endl; }
} /* plsql */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle plsql(); //
invoking PL/SQL block } catch(otl_exception&amp; p){ // intercept OTL
exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print out error message }
db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec219">Output</a></h4>
    <xmp><a name="sec219">
A=2, B=Test String1
A=3, B=Test String2
A=4, B=Test String3
    </a></xmp>
    <h3><a name="sec2110">2.1.10. Example 10 (with printf/scanf
functions)</a></h3>
    <h4><a name="sec2110">Source code</a></h4>
    <xmp><a name="sec2110">
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
void insert()
// insert rows into table
{ otl_stream o(50, // buffer size "insert into test_tab
values(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)", // SQL statement db //
connect object ); char tmp[32]; for(int i=1;i&lt;=100;++i){
sprintf(tmp,"Name%d",i); o.printf("%d %s",i,tmp); // write one row into
stream }
} /* insert */
void select()
{ otl_stream i(50, // buffer size "select * from test_tab where
f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2", // SELECT statement db //
connect object ); // create select stream int f1; char f2[31];
i&lt;&lt;8; // assigning :f = 8 // SELECT automatically executes when
all input variables are // assigned. First portion of out rows is
fetched to the buffer while(!i.eof()){ // while not end-of-data
i.scanf("%d %s",&amp;f1,f2); // read one row from stream
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
i&lt;&lt;4; // assigning :f = 4 // SELECT automatically re-executes
when all input variables are // assigned. First portion of out rows is
fetched to the buffer while(!i.eof()){ // while not end-of-data
i.scanf("%d %s",&amp;f1,f2); // read one row from stream
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
} /* select */
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table test_tab",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table test_tab(f1 number, f2
varchar2(30))" ); // create table insert(); // insert records into
table select(); // select records from table } catch(otl_exception&amp;
p){ // intercept OTL exceptions cerr&lt;&lt;p.msg&lt;&lt;endl; // print
out error message } db.logoff(); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec2110">Output</a></h4>
    <xmp><a name="sec2110">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec2111">2.1.11. Example 11 (with Prosto*C)</a></h3>
    <h4><a name="sec2111">Source code</a></h4>
    <xmp><a name="sec2111">
#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;otl.h&gt;
otl_connect* db=0; // pointer to connect object
void my_handler(char* msg, int code)
// my error handler
{ cout&lt;&lt;msg&lt;&lt;endl; if(db)db-&gt;rollback(); // on error,
roll back transaction if already // connected exit(1); // exit from the
program
}
void insert()
// insert rows into table
{ otl_stream* o=otl_stream_open // open OTL stream ( db, // connect
object "insert into test_tab
values(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)", // SQL statement 50 //
buffer size ); char tmp[32]; for(int i=1;i&lt;=100;++i){
sprintf(tmp,"Name%d",i); otl_printf(o,"%d %s",i,tmp); // write one row
into the stream } otl_stream_close(o); // Close OTL stream
} /* insert */
void select()
{ otl_stream* i=otl_stream_open // Open OTL stream ( db, // connect
object "select * from test_tab where f1&gt;=:f&lt;int&gt; and
f1&lt;=:f*2", // SELECT statement 50 // buffer size ); // create select
stream int f1; char f2[31]; otl_printf(i,"%d",8); // assigning :f = 8
// SELECT automatically executes when all input variables are //
assigned. First portion of out rows is fetched to the buffer
while(!otl_eof(i)){ // while not end-of-data otl_scanf(i,"%d
%s",&amp;f1,f2); // fetch a row from the stream
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl; }
otl_printf(i,"%d",4); // assigning :f = 4 // SELECT automatically
executes when all input variables are // assigned. First portion of out
rows is fetched to the buffer while(!otl_eof(i)){ // while not
end-of-data otl_scanf(i,"%d %s",&amp;f1,f2); // fetch a row from the
stream cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;",
f2="&lt;&lt;f2&lt;&lt;endl; } otl_stream_close(i); // Close OTL stream
} /* select */
int main()
{
// connect to Oracle db=otl_logon("scott/tiger", my_handler //
attaching error handler to the connect object ); otl_exec( db, "drop
table test_tab", 1 // ignore error ); // drop table otl_exec( db,
"create table test_tab(f1 number, f2 varchar2(30))" ); // create table
insert(); // insert records into table select(); // select records from
table otl_logoff(db); // disconnect from Oracle return 0;
} /* main */
    </a></xmp>
    <h4><a name="sec2111">Output</a></h4>
    <xmp><a name="sec2111">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
    </a></xmp>
    <h3><a name="sec22">2.2. Comparison with the other C++/database
libraries</a></h3>
    <a name="sec22"> </a>
    <p><a name="sec22">In this section, OTL is compared with the other
C++/database
libraries, namely:
    </a></p>
    <ul>
      <li>
        <a href="http://www.intelligent-objects.com./sqlobj.html">SQLObjects
(by Intelligent Objects)</a>
      </li>
      <li>
        <a href="http://www.roguewave.com/products/dbtools/dbtools.html">DBTools.h++
(by
Rogue Wave)</a>
      </li>
    </ul>
    <p>
SQLObjects and DBTools.h++ are both commercial, multi-platform,
multi-database C++ database access libraries. It is hard to
perform good comparison between them and OTL, since they provide
similar functionality but belong to the different
category. Nevertheless, OTL has advantage of being well suited
for a range of Oracle applications and platforms. It is portable
and easy-to-maintain within this range.
    </p>
    <p>
Multi-database C++ libraries lose the sense of "closeness" with
the database. They, most often, do not have so called "native
access" to the database. All their multi-database functionality
is based upon the monster called ODBC. Oracle has many advantages
compared to the other databases, such as Sybase, Informix, etc.
    </p>
    <p>
It is not such a bad idea to harness most of the power Oracle
provides:
    </p>
    <ul>
      <li>PL/SQL functions/procedures/packages</li>
      <li>Other Oracle SQL extentions</li>
      <li>Oracle Array Interface</li>
    </ul>
    <p>
Typical problem of accessing Oracle via ODBC is that no ODBC
driver provides transparent access to PL/SQL, especially with
    <b>OUT</b> or <b>IN OUT</b> parameters.
    </p>
    <p>
Often, it is critical to have fast interface. If the interface is
fast, then, most probably, it is not portable accross database
servers from different vendors. If the interface is portable and
unified, then it is awfully slow.
    </p>
    <p>
Considering the fact that a big segment of the database market is
covered by Oracle, it makes a lot of sense to develop an
interface unified for Oracle across most of the platforms on
which Oracle runs.
    </p>
    <p>
Let's consider a typical C++ interface to a database. It provides
a set of functions like:
    </p>
    <ul>
      <li>Connect/Disconnect</li>
      <li>Open/Close cursor</li>
      <li>Parse/Execute SQL statement</li>
      <li>Bind host variables</li>
      <li>Fetch rows from a SELECT statement</li>
      <li>Get and process database errors</li>
    </ul>
    <p>
Usually, such a layer of code is called access library. Some
vendors go far beyond that and provide <i>factories</i>, based upon
such access libraries. The factory is a GUI based front end which
generates the access library calls. Does it really improve the
developer's productivity? Sometimes, yes.
    </p>
    <p>
In contrast, OTL provides a multilayer class hierarchy and allows the
database programmer to decide which layer is more appropriate for each
case. The main advantage of OTL is that it provides the code layers
both as low as the Oracle Call Interface and as high as abstract and
unified <a href="#sec33">SQL stream</a> interface.
    </p>
    <p>
Therefore, OTL, in a sense, fills out the gap between the access layer
of code and the factory. The database programmer does not have to
learn tons of new front ends. He has to deals only with the same C++
code and the database.
    </p>
    <p>
It is not hard to imagine that it is rather easy to build up a
factory on top of OTL, as access library. The code, generated by
the factory would occupy less memory and would be more readable
than the code, generated into the calls of a low level access
library. The <a href="#sec4">Pro*OTL / Pre-Pro*C preprocessor</a>
may be the first step toward such a factory.
    </p>
    <p>
    </p>
    <h4><a name="sec221">2.2.1. OTL vs. SQLObjects (by Intelligent
Objects)</a></h4>
    <h4><a name="sec221">Sample Program in SQLObjects</a></h4>
    <xmp><a name="sec221">
Step 1 char szName[31]="";
Step 2 char szAddress[31]="";
Step 3 SQLObject *pDb=new SQLSybase(); // Instantiate SQLObject object
Step 4 pDb-&gt;sqlLogin(); // Log into the database
Step 5 pDb-&gt;sqlExec("SELECT name, address FROM customer"); //
execute the SQL command
Step 6 pDb-&gt;sqlBind(1,bindZSTRING,31,szName);
Step 7 pDb-&gt;sqlBind(2,bindZSTRING,31,szAddress); // Binds the host
variables to the column results
Step 8 while(pDb-&gt;sqlFetch() == TRUE) { cout &lt;&lt; szName
&lt;&lt; " " &lt;&lt; szAddress &lt;&lt; "\n"; } // Fetches the records
from the data source
Step 9 pDb-&gt;sqlDisconnect(); // Disconnects from the data source
Step 10 delete pDb; // Deletes the object
    </a></xmp>
    <h4><a name="sec221">The Same Sample Program in OTL streams</a></h4>
    <p>
    <a name="sec221">"As high as abstract and unified SQL stream
interface":
    </a></p>
    <xmp><a name="sec221">
Step 1 char szName[31];
Step 2 char szAddress[31];
Step 3 otl_stream s(20, // stream buffer size (in rows) "SELECT name,
address FROM customer", // SELECT statement db // connect object ; Step
4,5,6,7 // no explicit binding, no explicit execution
Step 8 while(!s.eof()) { s &gt;&gt; szName &gt;&gt; szAddress; // fetch
one row cout &lt;&lt; szName &lt;&lt; " " &lt;&lt; szAddress &lt;&lt;
endl; } // Fetches the records from the data source
Step 9, 10 // Automatic destructor will do the job
    </a></xmp>
    <h4><a name="sec221">The Same Sample Program in OTL lower code
layer </a></h4>
    <p>
    <a name="sec221">"As low as the Oracle Call Interface interface":
    </a></p>
    <xmp><a name="sec221">
Step 1 char szName[31];
Step 2 char szAddress[31];
Step 3 otl_select_cursor s(db); // db -- connect object // Instantiate
Cursor object
Step 4 // Everything is done in the constructor
Step 5 s.parse("SELECT name, address FROM customer"); // Parse the SQL
command
Step 6 s.bind_cstring(1,szName,30);
Step 7 s.bind_cstring(2,sAddress,30); // Binds the host variables to
the column results
Step 8 while(s.next()) { cout &lt;&lt; szName &lt;&lt; " " &lt;&lt;
szAddress &lt;&lt; endl; } // Fetches the records from the data source
Step 9, 10 // Automatic constructor will do the job
    </a></xmp>
    <h4><a name="sec222">2.2.2. OTL vs. DBTools.h++ (by Rogue Wave)</a></h4>
    <h4><a name="sec222">Sample Program in DBTools.h++</a></h4>
    <xmp><a name="sec222">
// This example establishes a connection to a SYBASE database, creates
// a table on the server, and uses the reader to read back the values.
// The values are then stored on a Memory Table and accessed row by
// row. This example can run on both WINDOWS and SUN/SOLARIS or
// SUNOS.
//#define UNIX // To run examples on Unix SunOS/Solaris
#define WINDOWS // To run example on WINDOWS
#include &lt;rw/db/db.h&gt;
#include &lt;rw/db/dbmgr.h&gt;
#ifdef WINDOWS
#include &lt;windows.h&gt;
#endif
void write(const RWCString&amp; w)
{
#ifdef WINDOWS MessageBox(0,w.data(),"DBTOOLS_BOX",MB_OK);
#elif defined(UNIX) cout &lt;&lt; w.data() &lt;&lt; endl;
#endif
}
void errorHandler(const RWDBStatus&amp; s)
{ char buf[1040]; sprintf(buf,"Message: %s ",s.message().data());
write(RWCString(buf));
}
#ifdef WINDOWS
#pragma argsused
int PASCAL WinMain(HINSTANCE , HINSTANCE, LPSTR, int )
{ RWCString serverType("bdbsdld.dll");
#elif defined(UNIX)
int main()
{ RWCString serverType("SYBASE");
#endif // Set the Error Handler
RWDBManager::setErrorHandler(errorHandler); // Establish Connection
RWDBDatabase adb = RWDBManager::database(serverType, "SYBASE100", // to
the database. "henri", "meli12", "SUPPORT"); if(!adb.isValid())
write("Hmmm !!! Cannot Connect. Exit..."); else { RWDBConnection
conn=adb.connection(); if(adb.table("TABLE1").exists())
adb.table("TABLE1").drop(); RWDBSchema mySchema;
mySchema.appendColumn("id_num",RWDBValue::Int);
mySchema.appendColumn("id_type", RWDBValue::String, 15);
mySchema.appendColumn("input_date", RWDBValue::DateTime);
mySchema.appendColumn("price", RWDBValue::Float);
adb.createTable("TABLE1",mySchema, conn); RWDBTable
tab=adb.table("TABLE1"); if(tab.exists()) write("Table 'TABLE1'
successfully created."); // Insert about 10 Values int
numberOfEntries=5; char buffer[1040]; RWDBDateTime date; float
price=1.5f; RWDBInserter ins = tab.inserter(); for(int i=0;
i&lt;numberOfEntries; i++) { sprintf(buffer,"Item%d",i);
date.addDays(1); ins &lt;&lt; i &lt;&lt; RWCString(buffer) &lt;&lt;
date &lt;&lt; &lt;&lt; i*price; ins.execute(conn); } // Select all of
items RWDBSelector sel = adb.selector(); sel &lt;&lt; tab; RWDBResult
res = sel.execute(conn); RWDBReader rdr=res.table().reader(conn);
RWDBMemTable memTab(rdr,numberOfEntries);
for(i=0;i&lt;memTab.entries(); i++) { sprintf(buffer,"ROW[%d] ID_NUMBER
%d ID_TYPE %s \n INPUT_DATE %s INPUT_PRICE %f\n", i,
(memTab[i][0]).asInt(), (memTab[i][1]).asString().data(),
(memTab[i][2]).asString().data(), (memTab[i][3]).asFloat());
write(RWCString(buffer)); } return 0; } return 0;
}
    </a></xmp>
    <h4><a name="sec222">The Same Sample Program in OTL</a></h4>
    <xmp><a name="sec222">
// This example establishes a connection to an Oracle database, creates
// a table on the server, and reads the values back.
#include &lt;stdio.h&gt;
#include &lt;iostream.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
void write(const char* w)
{ cout &lt;&lt; w &lt;&lt; endl; // Write a message
}
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle
otl_cursor::direct_exec ( db, "drop table TABLE1",
otl_exception::disabled // disable OTL exceptions ); // drop table
otl_cursor::direct_exec ( db, "create table TABLE1" "( " " id_num
number(8)," " id_type varchar2(15)," " input_date date," " price
number" ")" ); // create table write("Table 'TABLE1' successfully
created."); // Insert about 10 Values { int numberOfEntries=5; char
buffer[1040]; int date=0; float price=1.5f; otl_stream ins(50, //
buffer size (in rows) "insert into TABLE1 values(" "
:id_num&lt;int&gt;," " :id_type&lt;char[64]&gt;," "
sysdate+:input_date&lt;int&gt;," " :price&lt;float&gt;" ")", db //
connect object ); for(int i=0; i&lt;numberOfEntries; i++){
sprintf(buffer,"Item%d",i); ++date; ins &lt;&lt; i &lt;&lt; buffer
&lt;&lt; date &lt;&lt; (float) i*price; // insert one row into the
table } } // Select all of items { char buffer[1040]; int count=0; int
id_num; char id_type[64]; char input_date[32]; float price; otl_stream
sel(10, // buffer size (in rows) "select * TABLE1" db // connect object
); while(!sel.eof()){ sel &gt;&gt; id_num &gt;&gt; id_type &gt;&gt;
input_date &gt;&gt; price; // get one row sprintf(buffer, "ROW[%d]
ID_NUMBER %d ID_TYPE %s \n" "INPUT_DATE %s INPUT_PRICE %f\n", ++count,
id_num, id_type, input_date, price ); } } } catch(otl_exception&amp;
p){ // intercept OTL exceptions write(p.msg); } db.logoff(); //
disconnect from Oracle return 0;
}
    </a></xmp>
    <h2><a name="sec3">3. Library structure</a></h2>
    <a name="sec3"> </a>
    <p><a name="sec3">OTL falls into two parts: template classes to
create host variables
and arrays and non-template classes to provide programming interface
to the Oracle Call Interface.
    </a></p>
    <h3><a name="sec31">3.1. Host variable and array template classes</a></h3>
    <p>
    <a name="sec31">Two types of host objects are distinguished: scalar
variables and arrays. OTL has two generic template classes
(otl_variable and otl_array) from which the following
specialized classes are derived:
    </a></p>
    <ul>
      <li><a name="sec31"><i><b>Numerical data types</b></i>
        </a>
        <ul>
          <li><a name="sec31">otl_double, otl_double_array
            </a></li>
          <li><a name="sec31">otl_signed_char, otl_signed_char_array
            </a></li>
          <li><a name="sec31">otl_short_int, otl_short_int_array
            </a></li>
          <li><a name="sec31">otl_int, otl_int_array
            </a></li>
          <li><a name="sec31">otl_long_int, otl_long_int_array
            </a></li>
          <li><a name="sec31">otl_unsigned, otl_unsigned_array
            </a></li>
        </ul>
      </li>
    </ul>
    <ul>
      <li><a name="sec31"><i><b>String data types</b></i>
        </a>
        <ul>
          <li><a name="sec31">otl_ctring, otl_cstring_array
            </a></li>
          <li><a name="sec31">otl_varchar2, otl_varchar2_array
            </a></li>
          <li><a name="sec31">otl_long, otl_long_array
            </a></li>
          <li><a name="sec31">otl_varchar, otl_varchar_array
            </a></li>
          <li><a name="sec31">otl_varraw, otl_varraw_array
            </a></li>
          <li><a name="sec31">otl_raw, otl_raw_array
            </a></li>
          <li><a name="sec31">otl_char, otl_char_array
            </a></li>
          <li><a name="sec31">otl_charz, otl_charz_array
            </a></li>
        </ul>
      </li>
    </ul>
    <ul>
      <li><a name="sec31"><i><b>Data types for Oracle LONG and LONG RAW
columns</b></i>
        </a>
        <ul>
          <li><a name="sec31">otl_long_varchar
            </a></li>
          <li><a name="sec31">otl_long_varraw
            </a></li>
        </ul>
      </li>
    </ul>
    <ul>
      <li><a name="sec31"><i><b>Oracle internal data types (DATE,
ROWID, VARNUM and NUMBER)</b></i>
        </a>
        <ul>
          <li><a name="sec31">otl_date, otl_date_array
            </a></li>
          <li><a name="sec31">otl_rowid, otl_rowid_array
            </a></li>
          <li><a name="sec31">otl_varnum, otl_varnum_array;
            </a></li>
          <li><a name="sec31">otl_number, otl_number_array
            </a></li>
        </ul>
      </li>
    </ul>
    <p>
    <a name="sec31">The otl_variable and otl_array classes define the
following
kinds of buffers which are necessary for handling host
variables:
    </a></p>
    <ul>
      <li><a name="sec31">value buffer (data member <b>v</b>)
        </a></li>
      <li><a name="sec31">indicator buffer (data member <b>ind</b>)
        </a></li>
      <li><a name="sec31">returned length buffer (data member <b>rlen</b>)
        </a></li>
      <li><a name="sec31">returned code buffer (data member <b>rcode</b>)
        </a></li>
    </ul>
    <p></p>
    <p>
    <a name="sec31">These data members are defined to be public, so the
user has
access to them and may freely assign and change their
values.
    </a></p>
    <p>
    <a name="sec31">The otl_variable and otl_array classes have a
common parent
(otl_generic_variable) which contains information about the buffer
addresses, dimensions and data type codes. When a host variable or
array is constructed from an instantiated template, constructors of
the corresponding template classes initialize the data members of the
otl_generic_variable class. otl_cursor has a couple of the bind
functions which have the second parameter of the otl_generic_variable
type. Any template instantiated variables or arrays may be substituted
as actual parameters into those bind finctions.
    </a></p>
    <h3><a name="sec100">Class otl_generic_variable</a></h3>
    <xmp><a name="sec100">
class otl_generic_variable{
public:
    </a></xmp>
    <ul>
      <li><a name="sec100">Default constructor
        <xmp>otl_generic_variable();
        </xmp></a></li>
      <li><a name="sec100">Destructor
        <xmp>virtual ~otl_generic_variable();
        </xmp></a></li>
      <li><a name="sec100">Assigning a name to the variable
        <xmp>void copy_name(const char* aname);
        </xmp></a></li>
      <li><a name="sec100">Assigning a position (number) to the select
list item (column)
        <xmp>void copy_pos(const int apos);
        </xmp></a></li>
      <li><a name="sec100">For input variable/array
        <br>
        <br>
        </a>
        <ul>
          <li><a name="sec100">Set variable's value as NULL
            <xmp>virtual void set_null(int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Set variable's buffer length
            <xmp>virtual void set_len(int len, int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Set variable's value as NOT NULL
            <xmp>virtual void set_not_null(int ndx=0);
            </xmp></a></li>
        </ul>
      </li>
      <li><a name="sec100">For output variable/array
        <br>
        <br>
        </a>
        <ul>
          <li><a name="sec100">Check if variable's value is NULL
            <xmp>virtual int is_null(int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Check if variable's value has been
fetched OK
            <xmp>virtual int is_success(int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Check if variable's value is truncated
            <xmp>virtual int is_truncated(int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Get pointer to variable's buffer
            <xmp>virtual void* val(int ndx=0);
            </xmp></a></li>
        </ul>
      </li>
      <li><a name="sec100">Only for output arrays, defined in SELECT
statement
        </a>
        <ul>
          <a name="sec100"><br>
          <br>
          </a>
          <li><a name="sec100">Check if during fetch conversion error
occurred
            <xmp>virtual int is_invalid_conversion(int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Check if during fetch real overflow
occurred
            <xmp>virtual int is_real_overflow(int ndx=0);
            </xmp></a></li>
          <li><a name="sec100">Check if variable has unsupported data
type
            <xmp>virtual int is_unsupported_datatype(int ndx=0);
            </xmp></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<xmp><a name="sec100">
protected:
</a></xmp>
<ul>
  <li><a name="sec100">pointer to buffer
    <xmp>ub1* p_v; </xmp>
    </a></li>
  <li><a name="sec100">pointer to indicator variable/array
    <xmp>sb2* p_ind; </xmp>
    </a></li>
  <li><a name="sec100">pointer to column's returned length
    <xmp>ub2* p_rlen; </xmp>
    </a></li>
  <li><a name="sec100">poinetr column's returned code
    <xmp>ub2* p_rcode; </xmp>
    </a></li>
  <li><a name="sec100">external data type's code of the host
variable/array
    <xmp>int ftype; </xmp>
    </a></li>
  <li><a name="sec100">array element/variable size
    <xmp>int elem_size; </xmp>
    </a></li>
  <li><a name="sec100">host array size (=1 in case of scalar host
variable)
    <xmp>int array_size; </xmp>
    </a></li>
  <li><a name="sec100">variable name; <xmp>
char* name; </xmp>
    </a></li>
  <li><a name="sec100">select list item position
    <xmp>int pos; </xmp>
    </a></li>
</ul>
<xmp><a name="sec100">
};
</a></xmp>
<h3><a name="sec101">Class otl_variable</a></h3>
<p>
<a name="sec101">This is the OTL template variable class. It is the
base class for
constructing specialized host variable classes.
</a></p>
<xmp><a name="sec101">
template &lt;class T, int atype&gt;
class otl_variable: public otl_generic_variable{
public:
</a></xmp>
<ul>
  <li><a name="sec101">Default constructor
    <xmp>otl_variable();
    </xmp></a></li>
  <li><a name="sec101">Construct variable by the name of aname, e.g.
":F1"
    <xmp>otl_variable(const char* aname);
    </xmp></a></li>
  <li><a name="sec101">Construct variable/column, with its further use
in a select list
in the column_num position.
    <xmp> otl_variable(const int column_num);
    </xmp><br>
    </a>
    <hr size="3"><a name="sec101"><br>
    </a></li>
  <li><a name="sec101">host varibale of data type T
    <xmp>T v; </xmp>
    </a></li>
  <li><a name="sec101">indicator
    <xmp>sb2 ind; </xmp>
    </a></li>
  <li><a name="sec101">returned length
    <xmp>ub2 rlen; </xmp>
    </a></li>
  <li><a name="sec101">returned code
    <xmp>ub2 rcode; </xmp>
    </a></li>
</ul>
<xmp><a name="sec101">
};
</a></xmp>
<h3><a name="sec102">Class otl_array</a></h3>
<p>
<a name="sec102">This is the OTL template host array class. It is the
base class for
constructing specialized template array classes.
</a></p>
<xmp><a name="sec102">
template &lt;class T, int atype, short size&gt;
class otl_array: public otl_generic_variable{
public:
</a></xmp>
<ul>
  <li><a name="sec102">Default constructor
    <xmp>otl_array();
    </xmp></a></li>
  <li><a name="sec102">Construct array by the name of aname, e.g. ":F1"
    <xmp>otl_array(const char* aname);
    </xmp></a></li>
  <li><a name="sec102">Construct array-column, with its further use in
a select list in
the column_num position.
    <xmp>otl_array(const int column_num);
    </xmp><br>
    </a>
    <hr size="3"><a name="sec102"><br>
    </a></li>
  <li><a name="sec102">host array
    <xmp>T v[size];
    </xmp></a></li>
  <li><a name="sec102">indicator array
    <xmp>sb2 ind[size]; </xmp>
    </a></li>
  <li><a name="sec102">returned length array
    <xmp>ub2 rlen[size]; </xmp>
    </a></li>
  <li><a name="sec102">returned code array
    <xmp>ub2 rcode[size];
    </xmp></a></li>
</ul>
<xmp><a name="sec102">
};
</a></xmp>
<h3><a name="sec311">3.1.1. Specialized host variable classes</a></h3>
<ul>
  <li><a name="sec311"><i><b>Numerical data types</b></i>
    </a>
    <ul>
      <li><a name="sec311"><b>otl_double</b>, <i>example: otl_double
f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_float</b>, <i>example: otl_float
f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_signed_char</b>, <i>example:
otl_signed_char f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_short_int</b>, <i>example:
otl_short_int f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_long_int</b>, <i>example:
otl_long_int f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_unsigned</b>, <i>example:
otl_unsigned f1,f2;</i>
        </a></li>
    </ul>
  </li>
</ul>
<ul>
  <li><a name="sec311"><i><b>String data types</b></i>
    </a>
    <ul>
      <li><a name="sec311"><b>otl_cstring</b> <i>example:
otl_ctring&amp;ltSTR_SIZE&gt; f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_varchar2</b> <i>example:
otl_varchar2&amp;ltSTR_SIZE&gt; f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_long</b> <i>example:
otl_long&amp;ltSTR_SIZE&gt; f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_varchar</b>, <i>example:
otl_varchar&amp;ltSTR_SIZE&gt; f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_varraw</b>, <i>example:
otl_varraw&amp;ltSTR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec311"><b>otl_raw</b>, <i>example:
otl_raw&amp;ltSTR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec311"><b>otl_char</b>, <i>example:
otl_char&amp;ltSTR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec311"><b>otl_charz</b>, <i>example:
otl_charz&amp;ltSTR_SIZE&gt; f1,f2;</i> </a></li>
    </ul>
  </li>
</ul>
<ul>
  <li><a name="sec311"><i><b>Data types for Oracle LONG and LONG RAW
columns</b></i>
    </a>
    <p><a name="sec311">These two classes are used for reading and
writing objects of the
Oracle LONG and LONG RAW data types. The classes define operator[] to
access elements of the data array, the set_len() function to set up
string length on input and the len() function to get string length on
output.
    </a></p>
    <ul>
      <li><a name="sec311"><b>otl_long_varchar</b>, <i>example:
otl_long_varchar&amp;ltSTR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec311"><b>otl_long_varraw</b>, <i>example:
otl_long_varraw&amp;ltSTR_SIZE&gt; f1,f2;</i>
        </a></li>
    </ul>
  </li>
</ul>
<ul>
  <li><a name="sec311"><i><b>Oracle internal data types (DATE, ROWID,
VARNUM, NUMBER)</b></i>
    </a>
    <ul>
      <li><a name="sec311"><b>otl_date</b>, <i>example: otl_date f1,f2;</i>
        </a></li>
      <li><a name="sec311"><b>otl_rowid</b>, <i>example: otl_rowid
f1,f2;</i> </a></li>
      <li><a name="sec311"><b>otl_varnum</b>, <i>example: otl_varnum
f1,f2;</i> </a></li>
      <li><a name="sec311"><b>otl_number</b>, <i>example: otl_number
f1,f2;</i> </a></li>
    </ul>
  </li>
</ul>
<h3><a name="sec312">3.1.2. Specialized host array classes</a></h3>
<ul>
  <li><a name="sec312"><i><b>Numerical data types</b></i>
    </a>
    <ul>
      <li><a name="sec312"><b>otl_double_array</b>, <i>example:
otl_double_array&amp;ltARR_SIZE&gt; f1,f2;</i>
        </a></li>
      <li><a name="sec312"><b>otl_float_array</b>, <i>example:
otl_float_array&amp;ltARR_SIZE&gt; f1,f2;</i>
        </a></li>
      <li><a name="sec312"><b>otl_signed_char_array</b>, <i>example:
otl_signed_char_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_short_int_array</b>, <i>example:
otl_short_int_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_int_array</b>, <i>example:
otl_int_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_long_int_array</b>, <i>example:
otl_long_int_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_unsigned_array</b>, <i>example:
otl_unsigned_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
    </ul>
  </li>
</ul>
<ul>
  <li><a name="sec312"><i><b>String data types</b></i>
    </a>
    <ul>
      <li><a name="sec312"><b>otl_ctring_array</b>, <i>example:
otl_ctring_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_varchar2_array</b>, <i>example:
otl_varchar2_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_long_array</b>, <i>example:
otl_long_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_varchar_array</b>, <i>example:
otl_varchar_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_varraw_array</b>, <i>example:
otl_varraw_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_raw_array</b>, <i>example:
otl_raw_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_char_array</b>, <i>example:
otl_char_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_charz_array</b>, <i>example:
otl_charz_array&amp;ltARR_SIZE,STR_SIZE&gt; f1,f2;</i> </a></li>
    </ul>
  </li>
</ul>
<ul>
  <li><a name="sec312"><i><b>Oracle internal data types (DATE, ROWID,
VARNUM, NUMBER)</b></i>
    </a>
    <ul>
      <li><a name="sec312"><b>otl_date_array</b>, <i>example:
otl_date_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_rowid_array</b>, <i>example:
otl_rowid_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_varnum_array</b>, <i>example:
otl_varnum_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
      <li><a name="sec312"><b>otl_number_array</b>, <i>example:
otl_number_array&amp;ltARR_SIZE&gt; f1,f2;</i> </a></li>
    </ul>
  </li>
</ul>
<h2><a name="sec32">3.2. Oracle Call Interface "wrapper"</a></h2>
<h3><a name="sec103">Class otl_exception</a></h3>
<p>
<a name="sec103">This is the OTL exception class. Exceptions of this
type are
raised by the library functions (default mode), unless it is
prohibited explicitly in the otl_connect or otl_cursor class
constructors. In case of disabled exceptions OTL functions
return codes and it is the user's responsibility to check out
the codes and handle errors. The main advantage of using
this exception handling mechanism is that exceptions can be
processed in one catch block, instead of checking return
codes from every library function call.
</a></p>
<xmp><a name="sec103">
class otl_exception{
public:
</a></xmp>
<ul>
  <li><a name="sec103">This "enum" defines two constants which are used
in constructors
of the otl_connect, otl_cursor and otl_select_cursor classes.
    <xmp>enum{ disabled, enabled };
    </xmp></a></li>
  <li><a name="sec103">Create exception from LDA
    <xmp>otl_exception(Lda_Def&amp; lda);
    </xmp></a></li>
  <li><a name="sec103">Create exception from amsg and acode
    <xmp>otl_exception(const char* amsg,const int acode);
    </xmp></a></li>
  <li><a name="sec103">Copy constructor
    <xmp>otl_exception(const otl_exception&amp; p);
    </xmp></a></li>
  <li><a name="sec103">Default constructor
    <xmp> otl_exception();
    </xmp><br>
    </a>
    <hr size="3"><a name="sec103"><br>
    </a></li>
  <li><a name="sec103">error message buffer
    <xmp>unsigned char msg[1000]; </xmp>
    </a></li>
  <li><a name="sec103">error code
    <xmp>int code;
    </xmp></a></li>
</ul>
<xmp><a name="sec103">
};
</a></xmp>
<h3><a name="sec104">Class otl_object
</a>
<p><a name="sec104">This class is a parent of the otl_cursor and
otl_connect
classes. Its children inherit the following two properties: </a></p>
<ul>
  <li><a name="sec104">"connected" flag
    </a></li>
  <li><a name="sec104">"exception enabled" flag
    </a></li>
</ul>
<xmp><a name="sec104">
class otl_object{
public: </a></xmp>
<ul>
  <li><a name="sec104">Default constructor
    <xmp>otl_object();
    </xmp></a></li>
  <li><a name="sec104">Destructor
    <xmp>virtual ~otl_object();
    </xmp><br>
    </a>
    <hr size="3"><a name="sec104"><br>
    </a></li>
  <li><a name="sec104">"connected" flag
    <xmp>int connected; </xmp>
    </a></li>
</ul>
<xmp><a name="sec104">
protected:
</a></xmp>
<ul>
  <li><a name="sec104">"exception enabled" flag
    <xmp>int ex_enabled; </xmp>
    </a></li>
</ul>
<xmp><a name="sec104">
};
</a></xmp></h3>
<h3><a name="sec105">Class otl_connect</a></h3>
<p>
<a name="sec105">This class encapsulates the Oracle Call Interface
functions
which have Logon Descriptor Area as their first
parameter. In other words, otl_connect is the class for
creating "connect" objects.
</a></p>
<xmp><a name="sec105">
class otl_connect: public otl_object{
public:
</a></xmp>
<ul>
  <li><a name="sec105">Create "connect" object. Exceptions are allowed
to raise by
default
    <xmp>otl_connect(int exception_enabled=otl_exception::enabled);
    </xmp></a></li>
  <li><a name="sec105">Create "connect" object and connect to Oracle
using the
"connect_str" connect string; by default, exceptions are allowed to
raise
    <xmp> otl_connect(const char* connect_str, int
exception_enabled=otl_exception::enabled );
    </xmp></a></li>
  <li><a name="sec105">Destructor
    <xmp>~otl_connect();
    </xmp></a></li>
  <li><a name="sec105">Concurrent logon; OCI application is allowed to
have more than one
concurrent logon. Returns 1 on success, 0 on failure.
    <xmp>int rlogon(const char* connect_str);
    </xmp></a></li>
  <li><a name="sec105">Get valid LDA from Pro*C. Returns 1 on success,
0 on failure.
    <xmp>int sqllda(void);
    </xmp></a></li>
  <li><a name="sec105">Exclusive logon. there may be only one logon of
this type
performed in OCI application (for more details see OCI doc.). Returns
1 on success, 0 on failure.
    <xmp>int logon(const char* connect_str);
    </xmp></a></li>
  <li><a name="sec105">Disconnect from / log off Oracle. Returns 1 on
success, 0 on
failure.
    <xmp>int logoff(void);
    </xmp></a></li>
  <li><a name="sec105">Commit current transaction. Returns 1 on
success, 0 on failure.
    <xmp>int commit(void);
    </xmp></a></li>
  <li><a name="sec105">Roll back current transaction. Returns 1 on
success, 0 on failure.
    <xmp>int rollback(void);
    </xmp></a></li>
  <li><a name="sec105">Break current OCI call. Returns 1 on success, 0
on failure.
    <xmp>int obreak(void);
    </xmp></a></li>
  <li><a name="sec105">Set auto commit mode on. Returns 1 on success, 0
on failure.
    <xmp>int auto_commit_on(void);
    </xmp></a></li>
  <li><a name="sec105">Set auto commit mode off. Returns 1 on success,
0 on failure.
    <xmp>int auto_commit_off(void);
    </xmp><br>
    </a>
    <hr size="3"><a name="sec105"><br>
    </a></li>
  <li><a name="sec105">Logon Descriptor Area
    <xmp>Lda_Def lda; </xmp>
    </a></li>
  <li><a name="sec105">reference to "V7 return code"
    <xmp>ub2&amp; rc; </xmp>
    </a></li>
</ul>
<xmp><a name="sec105">
};
</a></xmp>
<h3><a name="sec106">Class otl_column_desc</a></h3>
<a name="sec106">This class is data structure which contains a select
item
(column) descriptive information. The information may be
obtained by the otl_cursor::describe_column function call
(see the otl_cursor class).
<xmp>class otl_column_desc{
public:
</xmp></a>
<ul>
  <li><a name="sec106">field name
    <xmp>sb1 name[241]; </xmp>
    </a></li>
  <li><a name="sec106">field name length
    <xmp>sb4 nlen; </xmp>
    </a></li>
  <li><a name="sec106">field size as the field is represented inside
ORACLE <xmp>
sb4 dbsize; </xmp>
    </a></li>
  <li><a name="sec106">internal datatype code
    <xmp>sb2 dbtype; </xmp>
    </a></li>
  <li><a name="sec106">numeric field scale: NUMBER(scale,precision)
    <xmp>sb2 scale; </xmp>
    </a></li>
  <li><a name="sec106">numeric field precision
    <xmp>sb2 prec; </xmp>
    </a></li>
  <li><a name="sec106">maximum display size of the field
    <xmp>sb4 dsize; </xmp>
    </a></li>
  <li><a name="sec106">NULLs are allowed <xmp>
sb2 nullok; </xmp>
    </a></li>
</ul>
<xmp><a name="sec106">
};
</a></xmp>
<h3><a name="sec107">Class otl_cursor</a></h3>
<p>
<a name="sec107">This class is a general-purpose cursor class.
</a></p>
<xmp><a name="sec107">
class otl_cursor: public otl_object{
public:
</a></xmp>
<ul>
  <li><a name="sec107">Create "cursor" object. by default, exceptions
are allowed to
raise.
    <xmp>otl_cursor(int exception_enabled=otl_exception::enabled);
    </xmp></a></li>
  <li><a name="sec107">Create "cursor" object and open cursor via
"connect"
    <xmp>otl_cursor(otl_connect&amp; connect, // reference to "connect"
object int exception_enabled=otl_exception::enabled );
    </xmp></a></li>
  <li><a name="sec107">Close cursor (if opened) and destruct object
    <xmp>~otl_cursor();
    </xmp></a></li>
  <li><a name="sec107">Open cursor via "connect". Returns 1 on success,
0 on failure
    <xmp>int open(otl_connect&amp; connect);
    </xmp></a></li>
  <li><a name="sec107">Close cursor. Returns 1 on success, 0 on failure
    <xmp>int close(void);
    </xmp></a></li>
  <li><a name="sec107">Cancel a query after desired number of rows have
been
fetched. Returns 1 on success, 0 on failure
    <xmp>int cancel(void);
    </xmp></a></li>
  <li><a name="sec107">Set rollback options for non-fatal Oracle
errors. For more info
see the OCI manual, the "oopt" function. Returns 1 on success, 0 on
failure
    <xmp>int option(int rbopt, int waitopt);
    </xmp></a></li>
  <li><a name="sec107">Fetch a portion of a LONG or LONG RAW column.
For more info see the
OCI manual, the "oflng" function. Returns 1 on success, 0 on failure
    <xmp>int fetch_long(int column_num, // column number: 1,2,... void*
buf, // pointer to buffer sb4 bufl, // buffer size int dtype, // buffer
data type, see ext* "enum" ub4* retl, // returned length sb4 offset //
offset );
    </xmp></a></li>
  <li><a name="sec107">Parse sql statement. Returns 1 on success, 0 on
failure
    <xmp>int parse(const char* sqlstm);
    </xmp></a></li>
  <li><a name="sec107">Parse sql statement; bind variable and select
list items; variable
list needs to be terminated with 0 pointer; Returns 1 on success, 0 on
failure. if variable list contains variables which are SELECT statement
output columns and if the variables don't have "column_num"
defined, then the parse function enumerates the variables as follows:<br>
    <br>
    </a>
    <ul>
      <li><a name="sec107">eparse("select...",&amp;f1,&amp;f2,&amp;f3,0);<br>
        <br>
        </a>
        <ul>
          <li><a name="sec107">f1 -- column 1
            </a></li>
          <li><a name="sec107">f2 -- column 2
            </a></li>
          <li><a name="sec107">f3 -- column 3
            </a></li>
        </ul>
      </li>
    </ul>
    <a name="sec107"><br>
    <xmp>
int eparse(const char* sqlstm,...);
    </xmp></a></li>
  <li><a name="sec107">Execute statement iters times. Returns 1 on
success, 0 on failure
    <xmp>int exec(short iters=1);
    </xmp></a></li>
  <li><a name="sec107">Combined operation: Parse+Bind+Execute. Parse
sqlstm. Bind
variables. Execute statement iters times. Returns 1 on success, 0 on
failure
    <xmp>int exec(const char* sqlstm, // SQL statement short iters, //
number of iterations ... // NULL terminated host variable list );
    </xmp></a></li>
  <li><a name="sec107">Fetch iters number of rows. Returns 1 on
success, 0 on failure
    <xmp>int fetch(short iters=1);
    </xmp></a></li>
  <li><a name="sec107">Combined operation -- execute statement + fetch
iters number of
rows. Returns 1 on success, 0 on failure
    <xmp>int exfet(short iters=1);
    </xmp></a></li>
  <li><a name="sec107">Functions to bind placeholders<br>
    <br>
    </a>
    <ul>
      <li><a name="sec107">Bind host variable/array (instantiated
template) to
placeholder. Returns 1 on success, 0 on failure
        <xmp>int bind(const char* name, // placeholder name: ":F1",
":F2" otl_generic_variable&amp; v // reference to host variable/array
);
        </xmp></a></li>
      <li><a name="sec107">Bind "ordinary" host variable/array to
placeholder. Returns 1 on
success, 0 on failure
        <xmp>int bind(const char* name, // placeholder name: ":f1",
":f2" void* buf, // pointer to host variable/array int elem_size,
//array element/ variable size in bytes int ftype, // Oracle external
data type code sb2* indp=0 // pointer to indicator variable/array );
        </xmp></a></li>
      <li><a name="sec107">Bind template host variable/array with
already defined
name. Returns 1 on success, 0 on failure
        <xmp>int bind(otl_generic_variable&amp; v);
        </xmp></a></li>
    </ul>
    <a name="sec107"><br>
    <br>
    </a></li>
  <li><a name="sec107">Functions to bind select list items (columns)<br>
    <br>
    </a>
    <ul>
      <li><a name="sec107">Bind host variable/array (instantiated
template) to
column. Returns 1 on success, 0 on failure
        <xmp>int bind(int column_num, // column number: 1,2,...
otl_generic_variable&amp; v // reference to variable/array );
        </xmp></a></li>
      <li><a name="sec107">bind "ordinary" host variable/array to
column. Returns 1 on
success, 0 on failure
        <xmp>int bind(int column_num, // column number: 1,2,... void*
buf, // pointer to host variable/array int elem_size, // array
element/variable size in bytes int ftype, // Oracle external data type
code sb2* indp=0, // pointer to indicator array/varibale ub2* rlen=0,
// pointer to returned length array/variable ub2* rcode=0 // pointer to
returned code array variable );
        </xmp></a></li>
    </ul>
  </li>
  <li><a name="sec107">Specialized function to bind columns<br>
    <br>
    </a>
    <ul>
      <li><a name="sec107">Bind C-style (null terminated) string
variable/array to
column. Returns 1 on success, 0 on failure
        <xmp>int bind_cstring(int column_num, // column number: 1,2,...
char* buf, // pointer to C-string variable/array int elem_size, //
array element/variable size sb2* indp=0, // pointer to indicator
array/variable ub2* rlen=0, // pointer to returned length
array/variable ub2* rcode=0 // pointer to returned code array/variable
);
        </xmp></a></li>
      <li><a name="sec107">Bind int variable/array to column. Returns 1
on success, 0 on
failure
        <xmp>int bind_int(int column_num, // column number: 1,2,...
int* buf, // pointer to int variable/array sb2* indp=0, // pointer to
indicator array/variable ub2* rlen=0, // pointer to returned length
array/variable ub2* rcode=0 // pointer to returned code array/variable
);
        </xmp></a></li>
      <li><a name="sec107">Bind short int variable/array to column.
Returns 1 on success, 0 on
failure
        <xmp>int bind_short(int column_num,// column number: 1,2,...
short* buf, // pointer to short int variable/array sb2* indp=0, //
pointer to indicator array/variable ub2* rlen=0, // pointer to returned
length array/variable ub2* rcode=0 // pointer to returned code
array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind long int variable/array to column.
Returns 1 on success, 0 on
failure
        <xmp>int bind_long_int(int column_num, // column number:
1,2,... long* buf, // pointer to long int variable/array sb2* indp=0,
// pointer to indicator array/variable ub2* rlen=0, // pointer to
returned length array/variable ub2* rcode=0 // pointer to returned code
array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind float variable/array to column. Returns
1 on success, 0 on
failure
        <xmp>int bind_float(int column_num,// column number: 1,2,...
float* buf, // pointer to float variable/array sb2* indp=0, // pointer
to indicator array/variable ub2* rlen=0, // pointer to returned length
array/variable ub2* rcode=0 // pointer to returned code array/variable
);
        </xmp></a></li>
      <li><a name="sec107">Bind double variable/array to column.
Returns 1 on success, 0 on
failure
        <xmp>int bind_double(int column_num,// column number: 1,2,...
double* buf, // pointer to double variable/array sb2* indp=0, //
pointer to indicator array/variable ub2* rlen=0, // pointer to returned
length array/variable ub2* rcode=0 // pointer to returned code
array/variable );
        </xmp></a></li>
    </ul>
    <a name="sec107"><br>
    <br>
    </a></li>
  <li><a name="sec107">Specialized functions to bind placeholders<br>
    <br>
    </a>
    <ul>
      <li><a name="sec107">Bind C-style (null terminated) string
variable/array to
column. Returns 1 on success, 0 on failure
        <xmp>int bind_cstring(const char* name, // placeholder name:
":F1", ":F2" char* buf, // pointer to C-string variable/array int
elem_size, // array element/variable size sb2* indp=0 // pointer to
indicator array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind int variable/array to placeholder.
Returns 1 on success, 0 on
failure
        <xmp>int bind_int(const char* name, // placeholder name: ":F1",
":F2" int* buf, // pointer to int variable/array sb2* indp=0 // pointer
to indicator array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind short int variable/array to
placeholder. Returns 1 on success,
0 on failure
        <xmp>int bind_short(const char* name, // placeholder name:
":F1", ":F2" short* buf, // pointer to short int variable/array sb2*
indp=0 // pointer to indicator array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind long int variable/array to placeholder.
Returns 1 on success,
0 on failure
        <xmp>int bind_long_int(const char* name, // placeholder name:
":F1", ":F2" long* buf, // pointer to long int variable/array sb2*
indp=0 // pointer to indicator array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind float variable/array to placeholder.
Returns 1 on success, 0
on failure
        <xmp>int bind_float(const char* name, // placeholder name:
":F1", ":F2" float* buf, // pointer to float variable/array sb2* indp=0
// pointer to indicator array/variable );
        </xmp></a></li>
      <li><a name="sec107">Bind double variable/array to placeholder.
Returns 1 on success, 0
on failure
        <xmp>int bind_double(const char* name, // placeholder name:
":F1", ":F2" double* buf, // pointer to double variable/array sb2*
indp=0 // pointer to indicator array/variable );
        </xmp></a></li>
    </ul>
    <a name="sec107"><br>
    <br>
    </a></li>
  <li><a name="sec107">Static (in class) function to immediately
execute a constant SQL
statement. Returns 1 on success, 0 on failure
    <xmp>static int direct_exec(otl_connect&amp; db, // connect object
const char* stm, // statement int
exception_enabled=otl_exception::enabled // exception_enabled flag );
    </xmp></a></li>
  <li><a name="sec107">Check "end-of-file" condition when fetching rows
from select
statement. Returns 1 when "EOF", 0 otherwise
    <xmp>int eof(void);
    </xmp></a></li>
  <li><a name="sec107">Describe select item (column)
    <xmp>int describe_column(otl_column_desc&amp; col_desc, // column
descriptor structure int column_num // column number: 1,2,... );
    </xmp></a></li>
  <li><a name="sec107">"End-of-description" condition check
    <xmp>int end_of_desc(void);
    </xmp></a></li>
  <li><a name="sec107">Parse statement and bind variables
    <xmp>int parse(const char* sqlstm, // SQL statement
otl_generic_variable** v // pointer to variable list );
    </xmp><br>
    </a>
    <hr size="3"><a name="sec107"><br>
    </a></li>
  <li><a name="sec107">Cursor Descriptor Area
    <xmp>Cda_Def cda; </xmp>
    </a></li>
  <li><a name="sec107">convenient references to some of the CDA fields<br>
    <br>
    </a>
    <ul>
      <li><a name="sec107">reference to "rows processed count"
        <xmp>ub4&amp; rpc; </xmp>
        </a></li>
      <li><a name="sec107">reference to "OCI function code"
        <xmp>ub2&amp; ft; </xmp>
        </a></li>
      <li><a name="sec107">reference to "V7 return code"
        <xmp>ub2&amp; rc; </xmp>
        </a></li>
      <li><a name="sec107">reference to "parse error offset"
        <xmp>ub2&amp; peo; </xmp>
        </a></li>
    </ul>
  </li>
</ul>
<xmp><a name="sec107">
};
</a></xmp>
<h3><a name="sec108">Class otl_select_cursor</a></h3>
<a name="sec108">This class is a cursor class, specialized for SELECT
statements. <xmp>
class otl_select_cursor : public otl_cursor{
public:
</xmp></a>
<ul>
  <li><a name="sec108">General constructor
    <xmp>otl_select_cursor(otl_connect&amp; db, // connect object short
arr_size=1, // attached host array size int
exception_enabled=otl_exception::enabled // exception enabled flag );
    </xmp></a></li>
  <li><a name="sec108">Fetch first row. rows are fetched in batches.
"cur_row" points to
current row in host array attached to select statement. cur_row==-1
if no rows have been fetched. Returns 1 on success, 0 on failure.
    <xmp>int first(void);
    </xmp></a></li>
  <li><a name="sec108">Fetch next row. "cur_row" points to current row.
cur_row==-1
after fetch sequence is complete. Returns 1 on success, 0 on failure.
    <xmp>int next(void);
    </xmp><br>
    </a>
    <hr size="3"><a name="sec108"><br>
    </a></li>
  <li><a name="sec108">index of current row in host array
    <xmp>int cur_row; </xmp>
    </a></li>
  <li><a name="sec108">number of rows in the buffer after most recent
fetch
    <xmp>int cur_size; </xmp>
    </a></li>
  <li><a name="sec108">row count -- total number of rows fetched
    <xmp>int row_count; </xmp>
    </a></li>
  <li><a name="sec108">size of host array attached to select statement
    <xmp>int array_size; </xmp>
    </a></li>
</ul>
<xmp><a name="sec108">
};
</a></xmp>
<h3><a name="sec200">Class otl_dynamic_variable</a></h3>
<p>
<a name="sec200">This class is used in the otl_select_stream class to
dynamically
allocate a list of output columns of SELECT statement and any other
automatically created bind variables (e.g. in a SQL stream).
</a></p>
<xmp><a name="sec200">
class otl_dynamic_variable: public otl_generic_variable{
public:
</a></xmp>
<ul>
  <li><a name="sec200">Dynamically construct a select list item
(column)
    <xmp>otl_dynamic_variable( const int column_num, // column
number/position in select // list const ftype, // external data type of
the column const elem_size, // host array element/variable size const
short array_size=1 // array size );
    </xmp></a></li>
  <li><a name="sec200">Dynamically construct host variable/array
    <xmp>otl_dynamic_variable( const char *aname, // varable/array name
const ftype, // external data type const elem_size, // variable/array
element size const short array_size=1 // array size );
    </xmp></a></li>
  <li><a name="sec200">Default constructor
    <xmp> otl_dynamic_variable();
    </xmp></a></li>
  <li><a name="sec200">Destructor
    <xmp>~otl_dynamic_variable();
    </xmp></a></li>
  <li><a name="sec200">Allocate memory and initialize variable/array
    <xmp>void init(const int ftype, // external data types const int
elem_size, // array element/variable size const short array_size //
array size );
    </xmp></a></li>
  <li><a name="sec200">return dynamic variable's external data type
    <xmp>int get_ftype(void);
    </xmp></a></li>
  <li><a name="sec200">return dynamic variable's elem_size
    <xmp>int get_elem_size(void);
    </xmp></a></li>
</ul>
<xmp><a name="sec200">
};
</a></xmp>
<h3><a name="sec109">Class otl_err_info</a></h3>
<a name="sec109">This is the OTL error info class. It is intended for
using
in case of manual error handling. The class allows to get
more detailed error information about the current Oracle
error.
<xmp>class otl_err_info: public otl_exception{
public:
</xmp></a>
<ul>
  <li><a name="sec109">Default constructor
    <xmp>otl_err_info();
    </xmp></a></li>
  <li><a name="sec109">Create error info object from otl_connect object
    <xmp>otl_err_info(otl_connect&amp; connect);
    </xmp></a></li>
  <li><a name="sec109">Create error info object from otl_cursor object
    <xmp>otl_err_info(otl_cursor&amp; cur);
    </xmp></a></li>
  <li><a name="sec109">Read error info into existing error info
descriptor
    <xmp> void get_info(otl_connect&amp; connect); void
get_info(otl_cursor&amp; cur);
    </xmp></a></li>
</ul>
<xmp><a name="sec109">
};
</a></xmp>
<h2><a name="sec33">3.3. OTL stream interface</a></h2>
<p>
<a name="sec33">In OTL, SQL streams are introduced. The idea here is to
combine
streams and SQL. Such a combination provides new quality and
simplicity in programming interface to SQL. The Oracle Array
Interface naturally transforms into buffered stream operations.
</a></p>
<p>
<a name="sec33">The SQL streams are intended for SQL or PL/SQL
statements which have
input and/or output bind variables. Any statement can be treated as a
functional element with input/output parameters. There are functions
to put objects into a stream, that is, to assign values to input
variables. Also, there are functions to get objects from the stream,
that is, to get values from output variables.
</a></p>
<a name="sec33"><b><xmp> +--&gt; I1 I2 ... In | | | | | V V V |
+------------------+ +--| SQL statement or | | PL/SQL block |
+-+-----+------+---+ | | | V V V O1 O2 ... Ok
</xmp></b></a>
<p><a name="sec33">When values of all input variables of the functional
element
are filled out then the element is executed. Resulting
values are assigned to the output variables right after the
execution. Sets of input and output variables are allowed to
overlap (see the picture).
</a></p>
<p>
<a name="sec33">Logically, a SQL stream is a structured stream with
input
and output rows. The format of the input row is defined by a
set of output variables of the stream. Similarly, the output
row is defined by input variables of the stream. When
objects are written into the stream, values are actually
assigned to the input variables. Likewise, when objects are
read from the stream, values are read from the output
variables of the stream.
</a></p>
<p>
<a name="sec33">SQL streams are similar to buffered files. A SQL
statement
or PL/SQL block is opened as an ordinary buffered file. The
logic of the SQL stream operations remains the same as the
file operations with the only exception -- the SQL stream
has separate input and output buffers which may overlap.
</a></p>
<p>
<a name="sec33">The SQL stream in C++ has a flush function for flushing
its input
buffer when the buffer gets full and a collection of &gt;&gt; and
&lt;&lt;
operators for reading and writing objects of different data types. The
most important advantage of the SQL streams is their unified interface
to SQL statements and PL/ SQL blocks of any kind. This mean that
application developers need to remember just a few syntactical
constructs and function names which they already got familiar with
when they started working with C++ streams.
</a></p>
<p>
<a name="sec33">Inside the SQL stream there is a small parser for
parsing </a><a href="#sec205">declarations of bind variables</a> and
their data
types. There is no need to declare C/C++ host variables and bind them
with placeholders by special bind function calls. All necessary
buffers are created dynamically inside the stream. The stream just
needs to be opened for reading input values and writing output values.
</p>
<p>
The OTL stream interface requires use of the OTL exceptions. This
means that potentially any OTL stream operation can throw an exception
of the otl_exception type. In order intercept the exception and
prevent the program from aborting, wrap up the OTL stream code with
the corresponding try &amp; catch block.
</p>
<p>
For more detail on the stream class hierarchy, see <a href="#secA">Appendix
A.</a>
</p>
<h3><a name="sec201">Class otl_select_stream</a></h3>
<p>
<a name="sec201">This is the OTL select stream class. The user does not
need to
manually attach output columns to SELECT statement because the
statement is automatically parsed and the output columns are allocated
in the class constructor.
</a></p>
<p>
<a name="sec201">This class may issue the following otl_exceptions:
</a></p>
<ul>
  <li><a name="sec201">Incompatible data types in stream operation,
code=32000
    </a></li>
  <li><a name="sec201">Not all input variables have been initialized,
code=32009
    </a></li>
  <li><a name="sec201">No input variables have beed defined in SELECT
statement, code=32004
    </a></li>
</ul>
<xmp><a name="sec201">
class otl_select_stream: public otl_select_cursor{
public:
</a></xmp>
<ul>
  <li>
    <a name="sec201">General conctructor. SELECT statement is parsed,
all input host
variables and output columns are automatically bound.
    <xmp>otl_select_stream(otl_connect&amp; db, // connect object const
char* sqlstm, // SELECT statement const short arr_size, // output host
arrays size ... // NULL terminated list of pointers to input host //
variables. );
    </xmp></a></li>
  <li><a name="sec201">General conctructor. SELECT statement is parsed,
all input host
variables and output columns are automatically bound. The difference
between this constructor and the constuctor above is that this
constuctor takes a pointer to an array of pointer to the host
variable/array list, instead of taking them from stack, as the above
constuctor does. This allows the user to dynamically create host
variables, say, in a loop, and collect pointers to the variables into
an array.
    <xmp>otl_select_stream( otl_connect&amp; db, // connect object
const char* sqlstm, // SELECT statement otl_p_generic_variable* avp, //
Pointer to NULL terminated list of // pointers to input hots //
variables const short arr_size=1 // output host arrays size );
    </xmp></a></li>
  <li><a name="sec201">General conctructor. SELECT statement is parsed,
all input host
variables and output columns are automatically allocated and
bound. This constructor allows the user to use </a><a href="#sec205">extended
place-holder declarations</a>.
    <xmp>otl_select_stream( const short arr_size, // output host arrays
size const char* sqlstm, // SELECT statement otl_connect&amp; db //
connect object );
    </xmp></li>
  <li>Destructor
    <xmp>~otl_select_stream();
    </xmp></li>
  <li>Rewind stream, SQL statement is re-executed. Input host variables
of SELECT statement may be re-assigned before calling this
function.
    <xmp>void rewind(void); </xmp>
  </li>
  <li>Test if NULL has been fetched during last stream operation
    <xmp>int is_null(void);
    </xmp></li>
  <li>Test if "end-of-file" has been reached. Returns 1 when
"end-of-file".
    <xmp>int eof(void);
    </xmp></li>
  <li>Read objects from stream
    <xmp>otl_select_stream&amp; operator&gt;&gt;(char&amp; c);
otl_select_stream&amp; operator&gt;&gt;(unsigned char&amp; c);
otl_select_stream&amp; operator&gt;&gt;(char* s);
otl_select_stream&amp; operator&gt;&gt;(unsigned char* s);
otl_select_stream&amp; operator&gt;&gt;(int&amp; n);
otl_select_stream&amp; operator&gt;&gt;(unsigned&amp; u);
otl_select_stream&amp; operator&gt;&gt;(short&amp; sh);
otl_select_stream&amp; operator&gt;&gt;(long int&amp; l);
otl_select_stream&amp; operator&gt;&gt;(float&amp; f);
otl_select_stream&amp; operator&gt;&gt;(double&amp; d);
    </xmp></li>
  <li>Write input values to the stream (initialize input variables)
    <xmp>otl_select_stream&amp; operator&lt;&lt;(const char c);
otl_select_stream&amp; operator&lt;&lt;(const unsigned char c);
otl_select_stream&amp; operator&lt;&lt;(const char* s);
otl_select_stream&amp; operator&lt;&lt;(const unsigned char* s);
otl_select_stream&amp; operator&lt;&lt;(const int n);
otl_select_stream&amp; operator&lt;&lt;(const unsigned u);
otl_select_stream&amp; operator&lt;&lt;(const short sh);
otl_select_stream&amp; operator&lt;&lt;(const long int l);
otl_select_stream&amp; operator&lt;&lt;(const float f);
otl_select_stream&amp; operator&lt;&lt;(const double d);
    </xmp></li>
  <li>Get info on SELECT list items
    <xmp>int select_list_len(void);
int column_ftype(int ndx=0);
int column_size(int ndx=0);
    </xmp></li>
  <li>Get column's internal info
    <xmp>otl_column_desc* sl_desc; // column descriptor array
    </xmp></li>
  <li>Set flag "delete input host variables"
    <xmp>void set_delete_var(const int should_delete=0);
    </xmp></li>
  <li> Special constructor. It parses SELECT statement and gets SELECT
list information. This constructor can be used when the user does not
really want to fetch rows via this stream but wants to get information
on the SELECT list (output columns).
    <xmp>otl_select_stream(const char* sqlstm, // SELECT statement
otl_connect&amp; db, // connect object const char* dummy_par // dummy
parameter (needed for // making the function // prototype unique );
    </xmp></li>
</ul>
<xmp>
};
</xmp>
<h3><a name="sec202">Class otl_out_stream</a></h3>
<p>
<a name="sec202">This is the OTL output class. This class is used for
the following SQL
statements:
</a></p>
<ul>
  <li><a name="sec202">DELETE
    </a></li>
  <li><a name="sec202">UPDATE
    </a></li>
  <li><a name="sec202">INSERT
    </a></li>
  <li><a name="sec202">PL/SQL block with input host variables only
    </a></li>
</ul>
<p>
<a name="sec202">This class may issue the following otl_exceptions:
</a></p>
<ul>
  <li><a name="sec202">Incompatible data types in stream operation,
code=32000
    </a></li>
  <li><a name="sec202">Row must be full for flushing output stream,
code=32004
    </a></li>
</ul>
<xmp><a name="sec202">
class otl_out_stream: public otl_cursor{
public:
</a></xmp>
<ul>
  <li><a name="sec202">Default constructor
    <xmp>otl_out_stream(otl_connect&amp; db):otl_cursor(db){}
    </xmp></a></li>
  <li><a name="sec202"> General conctructor. SQL statement is parsed,
all ouput host
variables are automatically bound.
    <xmp>otl_out_stream(otl_connect&amp; db, // connect object const
char* sqlstm, // SQL statement ... // NULL terminated list of pointers
to input hots // variables. );
    </xmp></a></li>
  <li><a name="sec202">General conctructor. SQL statement is parsed,
all ouput host
variables are automatically bound.
    <xmp>otl_out_stream(otl_connect&amp; db, // connect object const
char* sqlstm, // SQL statement otl_p_generic_variable* avp // Pointer
to NULL terminated list of pointers // to input hots variables. );
    </xmp></a></li>
  <li><a name="sec202">General conctructor. SQL statement is parsed,
all host variables
are automatically allocated and bound. This constructor allows the
user to use </a><a href="#sec205">extended place-holder
declarations</a>.
    <xmp>otl_out_stream( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db // connect object );
    </xmp></li>
  <li>Destructor
    <xmp>~otl_out_stream();
    </xmp></li>
  <li>Write objects into stream
    <xmp>otl_out_stream&amp; operator&lt;&lt;(const char c);
otl_out_stream&amp; operator&lt;&lt;(const unsigned char c);
otl_out_stream&amp; operator&lt;&lt;(const char* s);
otl_out_stream&amp; operator&lt;&lt;(const unsigned char* s);
otl_out_stream&amp; operator&lt;&lt;(const int n);
otl_out_stream&amp; operator&lt;&lt;(const unsigned u);
otl_out_stream&amp; operator&lt;&lt;(const short sh);
otl_out_stream&amp; operator&lt;&lt;(const long int l);
otl_out_stream&amp; operator&lt;&lt;(const float f);
otl_out_stream&amp; operator&lt;&lt;(const double d);
otl_out_stream&amp; operator&lt;&lt;(const otl_null n); // write Oracle
NULL into stream
    </xmp></li>
  <li>Flush stream buffer. SQL statement is executed as many times as
rows have been entered into the stream buffer.
    <xmp>virtual void flush(void);
    </xmp></li>
  <li>Clean up stream buffer without flushing it.
    <xmp>virtual void clean(void);
    </xmp></li>
  <li>Set "auto-commit" flag. When the buffer is flushed, current
transaction is automatically commited, if the flag is set. When
otl_out_stream is opened, by default, "auto-commit" flag is set, and
when the stream buffer is flushed, current transaction commits. In
order to unset the flag, use this function.
    <xmp>void set_commit(int auto_commit=0);
    </xmp></li>
  <li>Set flag "delete host variables". This flag is used, when, for
example, the user allocate host variables in dynamic memory and wants
the stream destuctor to automatically deallocate the occupied memory.
    <xmp>void set_delete_var(const int should_delete=0);
    </xmp></li>
</ul>
<xmp>
};
</xmp>
<h3><a name="sec203">Class otl_inout_stream</a></h3>
<p>
<a name="sec203">This is the OTL input/output stream class. It is used
primarily for
PL/SQL blocks with input and output parameters. Though, this stream
class can be used for SQL statements and PL/SQL blocks with input or
output parameters only.
</a></p>
<p><a name="sec203">This class may issue the following otl_exceptions:
</a></p>
<ul>
  <li><a name="sec203">Incompatible data types in stream operation,
code=32000
    </a></li>
  <li><a name="sec203">Row must be full for flushing output stream,
code=32001
    </a></li>
</ul>
<xmp><a name="sec203">
class otl_inout_stream: public otl_out_stream{
public:
</a></xmp>
<ul>
  <li><a name="sec203">General conctructor. SQL statement is parsed,
all host input and
output hostvariables are automatically allocated and bound.This
constructor allows the user to use </a><a href="#sec205">extended
place-holder declarations</a>.
    <xmp>otl_inout_stream( short arr_size, // host array size const
char* sqlstm, // SQL statement otl_connect&amp; db // connect object );
    </xmp></li>
  <li>Destructor
    <xmp>~otl_inout_stream();
    </xmp></li>
  <li>Test if all data has been already read from the stream
    <xmp>int eof(void);
    </xmp></li>
  <li>Flush stream's output buffer. It actually means to execute the
SQL
statement as many times as rows entered to the output buffer. The
stream is automatically flushed when the buffer gets full.
    <xmp>void flush(void); </xmp>
  </li>
  <li>Clean up buffer without flushing it.
    <xmp>void clean(void);
    </xmp></li>
  <li>Rewind stream
    <xmp>void rewind(void);
    </xmp></li>
  <li>Test if NULL was fetched from the stream
    <xmp>int is_null(void);
    </xmp></li>
  <li>Read objects from stream
    <xmp>otl_inout_stream&amp; operator&gt;&gt;(char&amp; c);
otl_inout_stream&amp; operator&gt;&gt;(unsigned char&amp; c);
otl_inout_stream&amp; operator&gt;&gt;(char* s);
otl_inout_stream&amp; operator&gt;&gt;(unsigned char* s);
otl_inout_stream&amp; operator&gt;&gt;(int&amp; n);
otl_inout_stream&amp; operator&gt;&gt;(unsigned&amp; u);
otl_inout_stream&amp; operator&gt;&gt;(short&amp; sh);
otl_inout_stream&amp; operator&gt;&gt;(long int&amp; l);
otl_inout_stream&amp; operator&gt;&gt;(float&amp; f);
otl_inout_stream&amp; operator&gt;&gt;(double&amp; d);
    </xmp></li>
</ul>
<xmp>
};
</xmp>
<h3><a name="sec204">Class otl_stream</a></h3>
<p>
<a name="sec204">This is the OTL stream class. It is a general-purpose
and most
advanced stream class, unified for streams of all types. This class
may issue the following otl_exceptions:
</a></p>
<ul>
  <li><a name="sec204">Incompatible data types in stream operation,
code=32000
    </a></li>
  <li><a name="sec204">Row must be full for flushing output stream,
code=32001
    </a></li>
  <li><a name="sec204">Not all input variables have been initialized,
code=32004
    </a></li>
  <li><a name="sec204">No input variables have been defined in SQL
statement, code=32004
    </a></li>
</ul>
<xmp><a name="sec204">
class otl_stream{
public:
</a></xmp>
<ul>
  <li><a name="sec204">General conctructor. SQL statement is parsed,
all host input and
output host variables are automatically allocated and bound. This
constructor allows the user to use </a><a href="#sec205">extended
place-holder declarations</a>.
    <xmp>otl_stream( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db // connect object );
    </xmp></li>
  <li>Default constructor
    <xmp>otl_stream();
    </xmp></li>
  <li>Desctructor
    <xmp>~otl_stream();
    </xmp></li>
  <li>Test if all data has been already read from the stream
    <xmp>int eof(void);
    </xmp></li>
  <li>Flush stream's output buffer. It actually means to execute the
SQL
statement as many times as rows entered to the output buffer. The
stream is automatically flushed when the buffer gets full.
    <xmp>void flush(void); </xmp>
  </li>
  <li>Clean up buffer without flushing it.
    <xmp>void clean(void);
    </xmp></li>
  <li>Rewind stream
    <xmp>void rewind(void);
    </xmp></li>
  <li>Test if NULL was fetched from the stream
    <xmp>int is_null(void);
    </xmp></li>
  <li>Set "auto-commit" flag. When the buffer is flushed, current
transaction is automatically commited, if the flag is set. By default,
the flag is set. In order to prevent current transaction from
"auto-commit", uset the flag using this function.
    <xmp>void set_commit(int auto_commit=0);
    </xmp></li>
  <li>Open stream
    <xmp>void open( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db // connect object );
    </xmp></li>
  <li>Close stream
    <xmp>void close(void);
    </xmp></li>
  <li>Test if the stream was opened okay
    <xmp>int good(void);
    </xmp></li>
  <li>Read objects from stream
    <xmp>otl_stream&amp; operator&gt;&gt;(char&amp; c);
otl_stream&amp; operator&gt;&gt;(unsigned char&amp; c);
otl_stream&amp; operator&gt;&gt;(char* s);
otl_stream&amp; operator&gt;&gt;(unsigned char* s);
otl_stream&amp; operator&gt;&gt;(int&amp; n);
otl_stream&amp; operator&gt;&gt;(unsigned&amp; u);
otl_stream&amp; operator&gt;&gt;(short&amp; sh);
otl_stream&amp; operator&gt;&gt;(long int&amp; l);
otl_stream&amp; operator&gt;&gt;(float&amp; f);
otl_stream&amp; operator&gt;&gt;(double&amp; d);
    </xmp></li>
  <li>Write objects into stream
    <xmp>otl_stream&amp; operator&lt;&lt;(const char c);
otl_stream&amp; operator&lt;&lt;(const unsigned char c);
otl_stream&amp; operator&lt;&lt;(const char* s);
otl_stream&amp; operator&lt;&lt;(const unsigned char* s);
otl_stream&amp; operator&lt;&lt;(const int n);
otl_stream&amp; operator&lt;&lt;(const unsigned u);
otl_stream&amp; operator&lt;&lt;(const short sh);
otl_stream&amp; operator&lt;&lt;(const long int l);
otl_stream&amp; operator&lt;&lt;(const float f);
otl_stream&amp; operator&lt;&lt;(const double d);
otl_stream&amp; operator&lt;&lt;(const otl_null n); // write Oracle
NULL into stream
    </xmp></li>
  <li>C-style printf/scanf functions
    <xmp>void printf(const char* fmt,...);
void scanf(const char* fmt,...);
    </xmp>
    <p>The following format specifiers are supported:
    </p>
    <ul>
      <li><b>%d</b> -- int
      </li>
      <li><b>%u</b> -- unsigned </li>
      <li><b>%ld</b> -- long int
      </li>
      <li><b>%f</b> -- float
      </li>
      <li><b>%lf</b> -- double
      </li>
      <li><b>%c</b> -- char
      </li>
      <li><b>%s</b> -- string
      </li>
      <li><b>%N</b> -- specifier for writing NULL into streams
      </li>
    </ul>
  </li>
</ul>
<xmp>
};
</xmp>
<h3><a name="sec205">Stream bind variable declarations</a></h3>
<p>
<a name="sec205">This section explains in detail how to declare bind
variables (or
extended place-holders) in the SQL streams.
</a></p>
<p>
<a name="sec205">A SQL statement or PL/SQL block may have placeholders
which are
usually connected with the corresponding bind variables in the
program. In Pro*C the user needs to declare such variables directly in
the program. OTL provides the same functionality in another way. There
is a small parser which parses a SQL statament or PL/SQL block
declaration and allocates corresponding bind variables dynamically
inside the stream.
</a></p>
<p>
<a name="sec205">The following data types for extneded place-holder
declarations are
available:
</a></p>
<ul>
  <li><a name="sec205">int
    </a></li>
  <li><a name="sec205">unsigned
    </a></li>
  <li><a name="sec205">short
    </a></li>
  <li><a name="sec205">long -- (long integer)
    </a></li>
  <li><a name="sec205">float
    </a></li>
  <li><a name="sec205">double
    </a></li>
  <li><a name="sec205">char[length]
    </a></li>
</ul>
<p>
<a name="sec205">For PL/SQL blocks, special qualifiers are introduced
to distinguish
between input and output variables:
</a></p>
<li><a name="sec205">in -- input variable
  </a></li>
<li><a name="sec205">out -- output variable
  </a></li>
<li><a name="sec205">inout -- input/output variable
  </a>
  <h4><a name="sec205">Examples</a></h4>
  <p>
  <a name="sec205">Here is a number of examples:
  </a></p>
  <a name="sec205"><i><xmp> begin :rc&lt;int,out&gt; := my_func(
:salary&lt;float,in&gt;, :ID&lt;int,inout&gt;,
:name&lt;char[32],out&gt; ); end;
  </xmp></i> </a>
  <p><a name="sec205">Invoke the my_func function; return the function
result into
the :rc variable; the function has three parameters: salary
(input), ID (iput/output), name (output)
  </a></p>
  <a name="sec205"><i><xmp> select * from tab1 where f1 &gt;
:f1&lt;double&gt;
  </xmp></i> </a>
  <p><a name="sec205">Select all columns from the tab1 table where f1
is greater
than :f1
  </a></p>
  <a name="sec205"><i><xmp> insert into tab1 values( :f1&lt;double&gt;,
:f2&lt;char[32]&gt;, :f3&lt;int&gt; )
  </xmp></i> </a>
  <p><a name="sec205">Insert row { :f1(double), :f2(string),
:f3(integer) } into the tab1
table.
  </a></p>
  <h2><a name="sec34">3.4. Prosto*C</a></h2>
  <p>
  <a name="sec34">The name Prosto*C is originated in the author's
native language --
"prosto" means "simple". Prosto*C is supposed to provide a simplified
set of procedures for interfacing with SQL or PL/SQL. In Prosto*C, the
mechanism of handling errors is slightly different from the
otl_exception mechanism. Each connect object is supplied with the
error handler -- a procedure, which is invoked each time when an error
occurs (see also </a><a href="#sec2111">2.1.11.</a>). </p>
Prosto*C provides a set of functions which is very similar to the C
"stdio" interface: scanf(), printf(), etc.
  <p></p>
  <p>
Here is the list of Prosto*C functions:
  </p>
  <ul>
    <li>Typedef which defines Prosto*C error handler prototype
      <xmp>typedef void (*otl_error_handler)(char* err_msg,int
err_code);
      </xmp></li>
    <li>Connect to Oracle using the "connect" string and attach the
"handler" function to the connect object. The function returns a
pointer to the corresponding connect object
      <xmp>otl_connect* otl_logon(char* connect,otl_error_handler
handler=0);
      </xmp></li>
    <li>"Pro*C" connect. Primary connection is done in a Pro*C module
using EXEC SQL CONNECT...; Attach the "handler" function to the
connect object. The function returns a pointer to the corresponding
connect object.
      <xmp>otl_connect* otl_proC_logon(otl_error_handler handler=0);
      </xmp></li>
    <li>Disconnect from Oracle. "db" -- connect object. Returns 1 on
success, 0 -- on failure.
      <xmp>int otl_logoff(otl_connect* db);
      </xmp></li>
    <li>Commit transaction. "db" -- connect object.
      <xmp>void otl_commit(otl_connect* db);
      </xmp></li>
    <li>Roll back transaction. "db" -- connect object.
      <xmp>void otl_rollback(otl_connect* db);
      </xmp></li>
    <li>Execute constant SQL statement. Returns 1 on success, 0 -- on
failure
      <xmp>int otl_exec(otl_connect* db,char* stm,int ignore_error=0);
      </xmp>
      <ul>
        <li>db -- connect object
        </li>
        <li>stm -- SQL statement
        </li>
        <li>ignore_error -- "ignore error" flag. If the flag is set up,
then the error handler function is not called.
        </li>
      </ul>
      <br>
    </li>
    <li>Open OTL stream. Returns pointer to stream on success, 0 -- on
failure.
      <xmp>otl_stream* otl_stream_open(otl_connect* db, char* stm,
short bufsize=1);
      </xmp>
      <ul>
        <li>db -- connect object
        </li>
        <li>stm -- SQL statement </li>
        <li>bufsize -- size of the buffer, attached to the stream
        </li>
      </ul>
      <br>
    </li>
    <li>Close OTL stream
      <xmp>void otl_stream_close(otl_stream* f);
      </xmp></li>
    <li>Check out the "EOF" condition on the "f" stream
      <xmp>int otl_eof(otl_stream* f);
      </xmp></li>
    <li>Check out if Oracle NULL has been fetched from the stream
      <xmp> int otl_is_null(otl_stream* f);
      </xmp></li>
    <li>Set "auto-commit" flag. When the buffer is flushed, current
transaction is automatically commited, if the flag is set
      <xmp> void otl_set_commit(otl_stream* f,int auto_commit=1);
      </xmp></li>
    <li>Flush stream buffer. SQL statement is executed as many times as
the
rows have been entered into the stream buffer
      <xmp>void otl_flush(otl_stream* f);
      </xmp></li>
    <li>C-style printf/scanf functions
      <xmp>void otl_printf(otl_stream* f, const char* fmt,...);
void otl_scanf(otl_stream* f, const char* fmt,...);
      </xmp>
      <p>The following format specifiers are supported:
      </p>
      <ul>
        <li><b>%d</b> -- int
        </li>
        <li><b>%u</b> -- unsigned </li>
        <li><b>%ld</b> -- long int
        </li>
        <li><b>%f</b> -- float
        </li>
        <li><b>%lf</b> -- double
        </li>
        <li><b>%c</b> -- char
        </li>
        <li><b>%s</b> -- string
        </li>
        <li><b>%N</b> -- specifier for writing NULL into streams
        </li>
      </ul>
    </li>
  </ul>
  <br>
  <h2><a name="sec4">4. Pro*OTL / Pre-Pro*C preprocessor (PPC)</a></h2>
  <p>
  <a name="sec4">PPC is a preprocessor which reads a directive file on
input and can
generate both Pro*C and OTL code on output. When the preprocessor
starts up, it connects to the database, parses directives and then
generates the output code. The output code consists of a Pro*C file, a
C++ file with OTL function calls and a header file with the prototypes
of the functions, generated by PPC.
  </a></p>
  <p>
  <a name="sec4">The directives fall into three main categories:
  </a></p>
  <ul>
    <li><a name="sec4">"SELECT" directive<br>
      <br>
      </a></li>
    <li><a name="sec4">"Output" directive for
      </a>
      <ul>
        <a name="sec4"><br>
        </a>
        <li><a name="sec4">INSERT
          </a></li>
        <li><a name="sec4">UPDATE
          </a></li>
        <li><a name="sec4">DELETE
          </a></li>
        <li><a name="sec4">PL/SQLblocks with input parameters only
          </a></li>
      </ul>
      <a name="sec4"><br>
      </a></li>
    <li><a name="sec4">"Arbitrary PL/SQL block" directive
      </a></li>
  </ul>
  <a name="sec4"><br>
  </a>
  <h3><a name="sec41">4.1. Getting started with PPC</a></h3>
  <p>
  <a name="sec41">Let's consider similar examples as described in </a><a
 href="#sec2">Chapter 2</a>: examples <a href="#sec28">8</a> and <a
 href="#sec29">9</a>. In the
"scott/tiger" user, create the following table, using SQLPlus:
  </p>
  <xmp> create table test_tab(f1 number, f2 varchar2(30));
  </xmp>
  <p>Let's assume that the example comprises of two modules: main and
auxiliary. The main module has the main function which connects to the
database and call functions from the auxiliary module. Source code of
the auxiliary module is generated by the PPC preprocessor from the
directive file. The directive file is unified for both Pro*C and C++,
but the output for Pro*C and C++ is different (see examples
below). The interface functions are the same and can be used both in
Pro*C and C++.
  </p>
  <p>
Here is the source code of the directive file (ppc_test.ppc):
  </p>
  <xmp>
/* ppc_test.ppc - directive file; ppc_test.h - generated header file
with interface functions and data structures; ppc_test.C - generated
C++ module with OTL function calls; ppc_test.pc - generated Pro*C
module;
*/
#include &lt;ppc_test.h&gt; /* generated header file */
/* PPC standard prolog for an auxiliary (not main) module */
#sql-init-module
#sql-str-type &lt;CSTR,1&gt;
/* type equivalence directive */
/* SELECT statement directive. "Sel" is the directive label. 50 is the
internal host arrays size.
*/
#sql-select &lt;Sel,50&gt;
SELECT *
FROM TEST_TAB
WHERE F1&gt;=:F&lt;int&gt; AND F1&lt;=:F*2
ORDER BY F1
##
/* ## is a directive terminator */
/* "Output" statement directive. "Ins" is the directive label. 50 is
the internal host arrays size.
*/
#sql-out-stm &lt;Ins,50&gt;
INSERT INTO TEST_TAB
( F1, F2
) VALUES
( :F1&lt;float&gt;, :F2&lt;char[31]&gt;
)
##
/* "Arbitrary PL/SQL block" directive. "PL" is the directive label. 1
is a dummy parameter which does not matter in the current release of
PPC. Put 1 for compatibility with the future versions. :A is IN/OUT
parameter; :B is OUT parameter; :C is IN parameter;
*/
#sql-plsql &lt;PL,1&gt;
BEGIN :A&lt;int,inout&gt; := :A+1; :B&lt;char[31],out&gt; :=
:C&lt;char[31],in&gt;;
END;
##
#ifdef __cplusplus
/* Function for C++. In the main C++ module, the user needs to call
this function, in order to pass over a pointer to the actual database
connect object into the C++ module, generated by PPC. This function can
be eliminated if only Pro*C is used.
*/
void assign_db(otl_connect* adb)
{ db=adb; // db is a static (in the module) pointer // to the database
connect object
}
/* Function for C++. In the main C++ module, the user needs to call
this function just before disconnecting from the database, in order to
close the static "hot" cursor in this file. This function can be
eliminated if only Pro*C is used.
*/
void close_hotcur(void)
{ hotcur.close(); // close static hot cursor
}
#endif
  </xmp>Here is the header file (ppc_test.h), generated from the
directive
file by PPC:
  <xmp>#ifndef __PPC_TEST_H
#define __PPC_TEST_H
#ifdef __cplusplus
extern "C"{
#endif
/* C-structure, corresponding to the "Sel" statement. The SELECT list
has been automatically extracted from the database dictionary and the
structure generated. The structure is a container for one output row of
the "Sel" statement.
*/
struct struct_Sel{ double F1; /* F1 number */ short F1_IND; /* F1's
indicator */ char F2[31]; /* F2 varchar2(30) */ short F2_IND;/* F2's
indicator */
};
typedef struct struct_Sel Sel; /* typedef declaration */
void Sel_open( int F /* F is the integer input host variable :F */
); /* Open the "Sel" statement */
void Sel_close(void); /* Close the "Sel" statement */
int Sel_get(Sel* out); /* Get one row and put it into the "Sel"
structure */
void Ins_open(int auto_commit); /* Open the "Ins" statement.
"auto_commit" is the auto-commit flag. If the flag is set then: -
commit transaction right after the internal host arrays get full and
the "Ins" statement is executed; - commit transaction right after the
"Ins" statement is closed;
*/
void Ins_put( float F1, /* input float host variable :F1 */ char* F2 /*
input char[31] host variable :f2 */
); /* Put one row into the "Ins" statement's internal buffer. The
statement is automatically executed when the buffer gets full.
*/
void Ins_flush(void); /* "Flush" internal buffer, no matter how full it
is. This means that the "Ins" statement executes as many times as rows
the buffer contains. If the "auto_commit" flag was set, then the
current transaction commits.
*/
void Ins_close(void);
/* Close the "Ins" statement: call the Ins_flush() function, then
deallocate all internal resources and quit.
*/
void PL_exec( int* A, /* IN/OUT integer parameter :A */ char* B,/* OUT
char[31] parameter :B */ char* C /* IN char[31] parameter :C
); /* Execute the "PL" PL/SQL block */
#ifdef __cplusplus
}
#endif
#endif
  </xmp>
  <p>For more information on this example, see <a href="#secF">Appendix
F</a>.
  </p>
  <h4><a name="sec411">Example in Pro*C</a></h4>
  <p>
  <a name="sec411">In this section, source code of the Pro*C main
module (ppc_main.pc) is
given. It needs to be preprocessed by Pro*C, compiled by C and linked
with the ppc_test.pc module (see the above example).
  </a></p>
  <h5><a name="sec411">Source code</a></h5>
  <xmp><a name="sec411">
#include &lt;ppc_test.h&gt;
#include &lt;stdio.h&gt;
EXEC SQL INCLUDE SQLCA;
typedef char CSTR[80];
EXEC SQL BEGIN DECLARE SECTION; EXEC SQL TYPE CSTR IS STRING(80); CSTR
UserId;
EXEC SQL END DECLARE SECTION;
/* Define error handler */
void sqlerror(void)
{ EXEC SQL WHENEVER SQLERROR CONTINUE;
fprintf(stderr,"\n%s\n",sqlca.sqlerrm.sqlerrmc); EXEC SQL ROLLBACK
RELEASE; exit(1);
}
EXEC SQL WHENEVER SQLERROR DO sqlerror();
void Insert()
/* insert rows into table */
{int i; Ins_open(1); /* open "Ins" statement with "auto_commit" flag
set */ for(i=0;i&lt;100;++i){ char F2[32]; sprintf(F2,"Name%d",i);
Ins_put(i,F2); /* write one row into the database */ } Ins_close(); /*
close statement */
} /* insert */
void Select()
/* select rows from table */
{ Sel p; /* one row containter */ Sel_open(8); /* open "Sel" statement
with the :F input parameter = 8 */
/* fetch rows from the table */ while(!Sel_get(&amp;p)){ /* not
end-of-data */ printf("f1=%g, f2=%s\n",p.F1,p.F2); } Sel_close(); /*
close the statement */
/* re-open "Sel" statement with :F = 4 */ Sel_open(4);
/* fetch rows from the table */ while(!Sel_get(&amp;p)){ /* not
end-of-data */ printf("f1=%g, f2=%s\n",p.F1,p.F2); } Sel_close(); /*
close the statement */
} /* select */
void plsql()
/* execute the "PL" PL/SQL block */
{ int a; char b[31]; char c[31];
/* assigning :A = 1, :C = "Test String1" */ a=1; strcpy(c,"Test
String1"); PL_exec(&amp;a,b,c); /* execute the block */ printf("A=%d,
B=%s\n",a,b); /* print out results */
/* assigning :A = 2, :C = "Test String2" */ a=2; strcpy(c,"Test
String2"); PL_exec(&amp;a,b,c); /* execute the block */ printf("A=%d,
B=%s\n",a,b); /* print out results */
/* assigning :A = 3, :C = "Test String3" */ a=3; strcpy(c,"Test
String3"); PL_exec(&amp;a,b,c); /* execute the block */ printf("A=%d,
B=%s\n",a,b); /* print out results */
} /* plsql */
int main()
{ strcpy(UserId,"scott/tiger"); EXEC SQL CONNECT :UserId; /* connect to
Oracle as scott/tiger */ EXEC SQL TRUNCATE TABLE TEST_TAB; /* truncate
table */ Insert(); /* insert rows */ Select(); /* select rows */
plsql(); /* execute PL/SQL block */ EXEC SQL COMMIT WORK; /* disconnect
from Oracle */
} /* main */
  </a></xmp>
  <h5><a name="sec411">Output</a></h5>
  <xmp><a name="sec411">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
A=1, B=Test String1
A=2, B=Test String2
A=3, B=Test String3
  </a></xmp>
  <h4><a name="sec412">Example in C++</a></h4>
  <p>
  <a name="sec412">In this section, source code of the C++ main module
(ppc_main.C) is
given. It needs to be compiled by C++ and linked with the
ppc_test.C module (see the above example).
  </a></p>
  <h5><a name="sec412">Source code</a></h5>
  <xmp><a name="sec412">
#include &lt;ppc_test.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream.h&gt;
#include &lt;otl.h&gt;
otl_connect db; // connect object
void Insert()
// insert rows into table
{ Ins_open(1);
// open "Ins" statement with "auto_commit" flag set for(int
i=0;i&lt;100;++i){ char F2[32]; sprintf(F2,"Name%d",i); Ins_put(i,F2);
// write one row into the database } Ins_close(); // close statement
} /* insert */
void Select()
// select rows from table
{ Sel p; // one row container Sel_open(8); // open "Sel" statement with
the :F input parameter = 8 // fetch rows from the table
while(!Sel_get(&amp;p)){ // not end-of-data printf("f1=%g,
f2=%s\n",p.F1,p.F2); } Sel_close(); // close the statement Sel_open(4);
// re-open the statement with :F = 4
// fetch rows from the table while(!Sel_get(&amp;p)){ // not
end-of-data printf("f1=%g, f2=%s\n",p.F1,p.F2); } Sel_close(); // close
the statement
} /* select */
void plsql()
// execute the "PL" PL/SQL block
{ int a; char b[31]; char c[31];
// assigning :A = 1, :C = "Test String1" a=1; strcpy(c,"Test String1");
PL_exec(&amp;a,b,c); // execute the block printf("A=%d, B=%s\n",a,b);
// print out results
// assigning :A = 2, :C = "Test String2" a=2; strcpy(c,"Test String2");
PL_exec(&amp;a,b,c); // execute the block printf("A=%d, B=%s\n",a,b);
// print out results
// assigning :A = 3, :C = "Test String3" a=3; strcpy(c,"Test String3");
PL_exec(&amp;a,b,c); // execute the block printf("A=%d, B=%s\n",a,b);
// print out results
} /* plsql */
// define prototypes of the assign_db and close_hotcur functions
// from the ppc_test.C module.
extern "C" void assign_db(otl_connect* db);
extern "C" void close_hotcur(void);
int main()
{ try{ db.rlogon("scott/tiger"); // connect to Oracle as scott/tiger
assign_db(&amp;db); // initialize internal pointer to the actual
connect // object in the ppc_test.C module
otl_cursor::direct_exec(db,"truncate table test_tab"); // truncate
table Insert(); // insert rows Select(); // select rows plsql(); //
execute PL/SQL block }catch(otl_exception&amp; p){ // intercept OTL
exceptions cout&lt;&lt;p.msg&lt;&lt;endl; // print out error message }
close_hotcur(); // close the hot cursor from ppc_test.C db.logoff(); //
disconnect from Oracle return 0;
} /* main */
  </a></xmp>
  <h5><a name="sec412">Output</a></h5>
  <xmp><a name="sec412">
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
A=1, B=Test String1
A=2, B=Test String2
A=3, B=Test String3
  </a></xmp>
  <h5><a name="sec412">Notes</a></h5>
  <p>
  <a name="sec412">It is possible to encapsulate all database
functionality in separate
Pro*C and PPC modules and use the modules without using OTL. The user
can define Pro*C connect and disconnect functions separately in a
Pro*C file, together with the other "handmade" Pro*C
procedures. Additionally, a few directive files can be defined to
automatically generate Pro*C code. Then, all this stuff can be
"objectified" (encapsulated) in C++ classes and the classes can be
used in the C++ main module.
  </a></p>
  <p>
  <a name="sec412">The user needs to keep in mind the technique of
invoking plain C
functions from C++.
  </a></p>
  <h3><a name="sec42">4.2. Directives</a></h3>
  <a name="sec42">PPC source code files consist of directives which may
be mixed with
real code in plain C, C++ or Pro*C (non-directive code is not
processed and remains intact). The directive starts with <b>#</b> at
the beginning of line. Some directives have names, arguments and
special terminators, the other -- do not. By format, the directives
are similar to the C preprocessor commands. Inside the directive body,
  </a><a href="#sec205">extended place-holder declarations</a> are
allowed.
  <h4><a name="sec421">4.2.1. #sql-select</a></h4>
  <p>
  <a name="sec421">This is the "SELECT" directive. On output, it
generates a set of
functions to select rows according to the given SELECT statement. The
directive format is as follows:
  </a></p>
  <xmp><a name="sec421">
#sql-select &lt;Label,BufSize&gt; end-of-line ... &lt;SELECT
Statement&gt; ...
## end-of-line
  </a></xmp>
  <dl>
    <dt><a name="sec421"><br>
      <b>&lt;Label&gt;</b>
      </a></dt>
    <dd><a name="sec421"><br>
Statement label
      </a></dd>
    <dt><a name="sec421"><br>
      <b>&lt;BufSize&gt;</b>
      </a></dt>
    <dd><a name="sec421"><br>
Defines the size of internal host arrays, attached to the
SELECT statment
      </a></dd>
    <dt><a name="sec421"><br>
      <b>&lt;SELECT Statement&gt;</b>
      </a></dt>
    <dd><a name="sec421"><br>
SELECT statement body. Can be multi-line.
      </a></dd>
    <dt><a name="sec421"><br>
      <b>##</b>
      </a></dt>
    <dd><a name="sec421"><br>
SELECT statement terminator. Starts at the beginning of line
      </a></dd>
  </dl>
  <a name="sec421"><br>
  <br>
  </a>
  <p><a name="sec421"><b>Example</b></a></p>
  <xmp><a name="sec421">
#sql-select &lt;Sel,50&gt;
SELECT *
FROM TEST_TAB
WHERE F1&gt;=:F&lt;int&gt; AND F1&lt;=:F*2
ORDER BY F1
##
  <br>
  </a></xmp>
  <p><a name="sec421"><b>Generated code</b></a></p>
  <xmp><a name="sec421">
struct struct_&lt;Label&gt;{ ... &lt;SELECT list items&gt; ...
}; /* One output row container */
typedef struct struct_&lt;Label&gt; &lt;Label&gt;;
void &lt;Label&gt;_open( /* open statement */ ... &lt;Input variable
list&gt; ..
);
void &lt;Label&gt;_close(void); /* close statement */
int &lt;Label&gt;_get(&lt;Label&gt;* out); /* get one rows from the
fetch sequence */
  </a></xmp>
  <p><a name="sec421">For more detail, see </a><a href="#secF">Appendix
F</a> and <a href="#sec41">"Getting Started with PPC"</a>.
  </p>
  <h4><a name="sec422">4.2.2. #sql-out-stm</a></h4>
  <p>
  <a name="sec422">This is the "output" directive. It is called
"output" similar to the
  </a><a href="#sec33">OTL streams</a>. A stream is called output,
when the user can write objects into the stream. This directive is
used for:
  </p>
  <p></p>
  <ul>
    <br>
    <li>INSERT
    </li>
    <li>UPDATE
    </li>
    <li>DELETE
    </li>
    <li>PL/SQLblocks with input parameters only
    </li>
  </ul>
  <p>
On the output, the directive generates a set of functions to write
rows to the database, according to the given SQL statement or PL/SQL
block. The directive format is as follows:
  </p>
  <xmp>
#sql-out-stm &lt;Label,BufSize&gt; end-of-line ... &lt;SQL Statement or
PL/SQL block with input parameters only&gt; ...
##
  </xmp>
  <dl>
    <dt><br>
      <b>&lt;Label&gt;</b>
    </dt>
    <dd><br>
Statement label
    </dd>
    <dt><br>
      <b>&lt;BufSize&gt;</b>
    </dt>
    <dd><br>
Defines the size of internal host arrays, attached to the
statment
    </dd>
    <dt><br>
      <b>&lt;SQL Statement or PL/SQL block with input parameters
only&gt;</b>
    </dt>
    <dd><br>
Statement body. Can be multi-line.
    </dd>
    <dt><br>
      <b>##</b>
    </dt>
    <dd><br>
Statement terminator. Starts at the beginning of line
    </dd>
  </dl>
  <br>
  <br>
  <p><b>Example</b></p>
  <xmp>
#sql-out-stm &lt;Ins,50&gt;
INSERT INTO TEST_TAB
( F1, F2
) VALUES
( :F1&lt;float&gt;, :F2&lt;char[31]&gt;
)
##
  </xmp><br>
  <p><b>Generated code</b></p>
  <xmp>
void &lt;Label&gt;_open(int auto_commit); /* open statement */
void &lt;Label&gt;_put( /* write one row */ ... &lt;Parameter list&gt;
...
);
void &lt;Label&gt;_flush(void); /* "flush" internal buffer */
void &lt;Label&gt;_close(void); /* close statement */
  </xmp>
  <p>For more detail, see <a href="#secF">Appendix F</a> and <a
 href="#sec41">"Getting Started with PPC"</a>.
  </p>
  <h4><a name="sec423">4.2.3. #sql-plsql</a></h4>
  <p>
  <a name="sec423">This is the "arbitrary PL/SQL block" directive. On
the output, the
directive generates the "exec" function to execute the PL/SQL block,
given in the directive. The directive format is as follows:
  </a></p>
  <xmp><a name="sec423">
#sql-plsql &lt;Label,BufSize&gt; end-of-line ... &lt;PL/SQL block&gt;
...
## end-of-line
  </a></xmp>
  <dl>
    <dt><a name="sec423"><br>
      <b>&lt;Label&gt;</b>
      </a></dt>
    <dd><a name="sec423"><br>
Statement label
      </a></dd>
    <dt><a name="sec423"><br>
      <b>&lt;BufSize&gt;</b>
      </a></dt>
    <dd><a name="sec423"><br>
Defines the size of internal host arrays, attached to the
statment. In the current release of PPC should be always 1.
      </a></dd>
    <dt><a name="sec423"><br>
      <b>&lt;PL/SQL block&gt;</b>
      </a></dt>
    <dd><a name="sec423"><br>
Statement body. Can be multi-line.
      </a></dd>
    <dt><a name="sec423"><br>
      <b>##</b>
      </a></dt>
    <dd><a name="sec423"><br>
Statement terminator. Starts at the beginning of line
      </a></dd>
  </dl>
  <a name="sec423"><br>
  <br>
  </a>
  <p><a name="sec423"><b>Example</b></a></p>
  <xmp><a name="sec423">
#sql-plsql &lt;PL,1&gt;
BEGIN :A&lt;int,inout&gt; := :A+1; :B&lt;char[31],out&gt; :=
:C&lt;char[31],in&gt;;
END;
##
  <br>
  </a></xmp>
  <p><a name="sec423"><b>Generated code</b></a></p>
  <xmp><a name="sec423">
void &lt;Label&gt;_exec( /* execute PL/SQL block */ ... &lt;Parameter
list&gt; ...
);
  </a></xmp>
  <p><a name="sec423">For more detail, see </a><a href="#secF">Appendix
F</a> and <a href="#sec41">"Getting Started with PPC"</a>.
  </p>
  <h4><a name="sec424">4.2.4. #sql-init-module</a></h4>
  <p>
  <a name="sec424">This is the "module's standard prolog" directive. On
output, the
directive generates a piece of code, typical for non-main modules. </a></p>
  <xmp><a name="sec424">
#sql-init-module end-of-line
  <br>
  </a></xmp>
  <p><a name="sec424"><b>Example</b></a></p>
  <xmp><a name="sec424">
#sql-init-module
  <br>
  </a></xmp>
  <p><a name="sec424"><b>Generated code</b></a></p>
  <p>
  </p>
  <p>
  <a name="sec424">For more detail, see </a><a href="#secF">Appendix F</a>
and <a href="#sec41">"Getting Started with PPC"</a>.
  </p>
  <h4><a name="sec425">4.2.5. #sql-init-main</a></h4>
  <p>
  <a name="sec425">This is the "main module's standard prolog"
directive. On output, the
directive generates a piece of code, typical for main modules.
  </a></p>
  <xmp><a name="sec425">
#sql-init-main end-of-line
  <br>
  </a></xmp>
  <p><a name="sec425"><b>Example</b></a></p>
  <xmp><a name="sec425">
#sql-init-main
  <br>
  </a></xmp>
  <p><a name="sec425"><b>Generated code</b></a></p>
  <p>
  </p>
  <p>
  <a name="sec425">For more detail, see </a><a href="#secF">Appendix F</a>
and <a href="#sec41">"Getting Started with PPC"</a>.
  </p>
  <h4><a name="sec426">4.2.6. #sql-str-type</a></h4>
  <p>
  <a name="sec426">This is the "string type equivalence" directive. It
has effect only
in Pro*C. The directive format is as follows:
  </a></p>
  <xmp><a name="sec426">
#sql-str-type &lt;StringType,Flag&gt; end-of-line
  </a></xmp>
  <dl>
    <dt><a name="sec426"><br>
      <b>&lt;StringType&gt;</b>
      </a></dt>
    <dd><a name="sec426"><br>
C-string type, defined as a typedef. PPC uses the "StringType"
identifier in generating Pro*C internal string variables.
      </a></dd>
    <dt><a name="sec426"><br>
      <b>&lt;Flag&gt;</b>
      </a></dt>
    <dd><a name="sec426"><br>
if &lt;flag&gt;==1 then the string type equivalence is
enforced. if &lt;flag&gt;==0 then the string type equivalence is off.
      </a></dd>
  </dl>
  <p></p>
  <a name="sec426"><br>
  </a>
  <p><a name="sec426"><b>Example</b></a></p>
  <xmp><a name="sec426">
typedef char C_STR[256];
...
#sql-str-type &lt;C_STR,1&gt;
...
  <br>
  </a></xmp>
  <p><a name="sec426"><b>Generated code</b></a></p>
  <p>
  <a name="sec426">None.
  </a></p>
  <h3><a name="sec43">4.3. Command line parameters</a></h3>
  <p>
  <a name="sec43">All command line parameter are positional. Parameters
inside <b>[]</b>
are optional. The format of PPC command line is as follows:
  </a></p>
  <xmp><a name="sec43"> ppc &lt;connect_string&gt; &lt;input_file&gt;
&lt;proc-file&gt; &lt;h-file&gt; &lt;#define&gt;
[&lt;macro-def-file&gt; [&lt;OTL-module&gt;]]
  </a></xmp>
  <dl>
    <dt><a name="sec43"><br>
      <b>1. connect_string</b>
      </a></dt>
    <dd><a name="sec43"><br>
Database connect sting
      </a></dd>
    <dt><a name="sec43"><br>
      <b>2. input_file</b>
      </a></dt>
    <dd><a name="sec43"><br>
Input PPC directive file
      </a></dd>
    <dt><a name="sec43"><br>
      <b>3. proc-file</b>
      </a></dt>
    <dd><a name="sec43"><br>
Output Pro*C file
      </a></dd>
    <dt><a name="sec43"><br>
      <b>4. h-file</b>
      </a></dt>
    <dd><a name="sec43"><br>
Output interface header file (contains PPC-generated external function
prototypes and data structures
      </a></dd>
    <dt><a name="sec43"><br>
      <b>5. #define</b>
      </a></dt>
    <dd><a name="sec43"><br>
#define for the interface header file
      </a></dd>
    <dt><a name="sec43"><br>
      <b>6. macro-def-file</b>
      </a></dt>
    <dd><a name="sec43"><br>
File, containing macro definitions to be used with the OTL
streams (see the file for more detail)
      </a></dd>
    <dt><a name="sec43"><br>
      <b>7. OTL-module</b>
      </a></dt>
    <dd><a name="sec43"><br>
Output C++ module which contains OTL function calls
      </a></dd>
  </dl>
  <a name="sec43"><br>
  <br>
  </a>
  <p><a name="sec43"><b>Examples</b>
  </a></p>
  <p><xmp><a name="sec43"> ppc scott/tiger sample.ppc sample.pc
sample.h __SAMPLE_H ppc scott/tiger sample.ppc sample.pc sample.h
__SAMPLE_H dummy.h sample.C
  </a></xmp></p>
  <h2><a name="sec5">5. Acknowledgements</a></h2>
  <p>
  <a name="sec5">Vladimir Shipunov and Igor Galichin (Siberian Trade
Bank, Novosibirsk,
Russia) have discussed with me some ideas how to implement basic
classes.
  </a></p>
  <p>
  <a name="sec5">Peter Muth, Hannelore Eisner, Achim Kraiss and other
members of the
VODAK team in </a><a href="http://www.darmstadt.gmd.de/IPSI/">GMD IPSI</a>
(Darmstadt,
Germany) have given me good knowledge on Object Oriented Databases and
I do not regret about the time I spent with them. The knowledge was
very useful in the development of the OTL.
  </p>
  <p>
Especially, I would like to thank <a
 href="http://www.darmstadt.gmd.de/IPSI/gmdda.ip.staff.neuh.html">Prof.Dr.
Erich
Neuhold</a> who granted me a visiting researcher position in GMD IPSI.
  </p>
  <p>
Sergei Trapeznikov's and my hard work on numerous Oracle projects at
  <a href="http://www.empros.com">Siemens / Empros</a> inspired me to
develop PPC. I wish Sergei Trapeznikov all the best in his career at
  <a href="http://www.sabre.com/sabr_grp/sdt/sdt.htm">SDT</a>.
  </p>
  <p>
Many thanks to my wife Irina for her patience and understanding that
this work is important to me.
  </p>
  <h2><a name="sec6">6. Bibliography</a></h2>
  <ul>
    <li><a name="sec6">[1] Programmer's Guide to the Oracle Call
Interface.
      </a></li>
    <li><a name="sec6">[2] PL/SQL User's Guide and Reference.
      </a></li>
    <li><a name="sec6">[3] Oracle 7 Server. Messages and Codes Manual.
      </a></li>
  </ul>
  <h2><a name="secA">Appendix A. OTL class hierarchy</a></h2>
  <a name="secA"><b><xmp> otl_object | +------&gt;otl_connect |
+------&gt;otl_cursor | +------&gt;otl_select_cursor | | |
+------&gt;otl_select_stream | | | otl_stream +------&gt;otl_out_stream
| +------&gt;otl_inout_stream otl_generic_variable |
+--&gt;otl_dynamic_variable | +--&gt;otl_variable | | |
+---&gt;otl_cstring | otl_varchar2 | otl_long | otl_varchar |
otl_varraw | otl_raw | otl_long_raw | otl_char | otl_charz |
otl_long_varchar | otl_long_varraw | +-&gt;otl_array |
+----&gt;otl_date_array otl_rowid_array otl_varnum_array
otl_number_array otl_double_array otl_float_array otl_signed_char_array
otl_short_int_array otl_int_array otl_long_int_array otl_unsigned_array
otl_cstring_array otl_varchar2_array otl_long_array otl_varchar_array
otl_varraw_array otl_raw_array otl_long_raw_array otl_char_array
otl_charz_array otl_exception | +----&gt;otl_err_info
  </xmp></b></a>
  <h2><a name="secB">Appendix B. Error message list</a></h2>
  <p>
  <a name="secB">A few error codes are defined by OTL. It is necessary
because a
runtime error can occur during debugging of a program. All the error
codes defined can be issued only from member functions of the stream
classes. Error reporting and handling is implemented via the normal
mechanism of the OTL exceptions.
  </a></p>
  <p>
  <a name="secB">The user can catch an exception raised not by an
Oracle error but by
one of the &lt;&lt; or &gt;&gt; operators of the stream classes.
  </a></p>
  <dl>
    <dt><a name="secB"><b>Code=32000</b>: Incompatible data types in
stream operation
      </a></dt>
    <dd><a name="secB"><br>
      <b>Cause</b>: The data type of a variable used in the current
stream operation is not compatible with the declared stream format.
      <br>
      <br>
      <b>Action</b>: Check placeholders and their data types
declaration.
      </a></dd>
    <dt><a name="secB"><br>
      <b>Code=32001</b>: Row must be full for flushing output stream
      </a></dt>
    <dd><a name="secB"><br>
      <b>Cause</b>: Stream is open for output and has a format of
output rows. An output row is a tuple of all output variables put
together. The current output row is not filled yet but the flush
function is invoked. The stream buffer cannot be flushed until the
current row of the output buffer is full.
      <br>
      <br>
      <b>Action</b>: Fill the row first, then flush the stream.
      </a></dd>
    <dt><a name="secB"><br>
      <b>Code=32004</b>: Not all input variables have been initialized
      </a></dt>
    <dd><a name="secB"><br>
      <b>Cause</b>: stream has input variables but not all the
variables have been initialized. An attempt to read data from the
stream was made.
      <br>
      <br>
      <b>Action</b>: Assign all the input variables first.
      </a></dd>
    <dt><a name="secB"><br>
      <b>Code=32004</b>: No input variables have been defined in SQL
statement
      </a></dt>
    <dd><a name="secB"><br>
      <b>Cause</b>: Stream has no input variables. An attempt to write
objects to the stream via one of the &lt;&lt; operators was made.
      <br>
      <br>
      <b>Action</b>: Do not call the &lt;&lt; operators for streams
which have no input variables defined.
      </a></dd>
  </dl>
  <h2><a name="secC">Appendix C. OTL source code (otl.h)</a></h2>
  <xmp><a name="secC">
//
// The OCI Template Library 1.0.6.5
// Copyright (C) Sergei Kuchin, 1996, 1997, 1998
// Author: Sergei Kuchin
// This library is free software. Permission to use, copy, // modify
and redistribute it for any purpose is hereby granted // without fee,
provided that the above copyright notice appear // in all copies. //
#ifndef __OTL_H #define __OTL_H // Functions are defined as INLINE.
Those, who don't like inline
// functions and prefer to have a separate C++ module with the
// functions, can define INLINE as empty string and split up otl.h
// into two files: otl.h and otl.C (otl.cpp).
#define INLINE inline
#define OTL_DEBUG_ // OTL uses the ociapr.h file (OCI standard header
file, recommended
// for ANSI C compilers). In Unix, OCI header files reside in the
// $ORACLE_HOME/rdbms/demo directory.
extern "C"{
#include &lt;ociapr.h&gt;
}
#ifdef OTL_DEBUG
#include &lt;iostream.h&gt;
#endif
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
// Oracle internal data types (see Programmer's Guide to the
// Oracle Call Interface, chapter 3)
// enum otl_internal_type{ const int inVarChar2=1; const int
inNumber=2; const int inLong=8; const int inRowId=11; const int
inDate=12; const int inRaw=23; const int inLongRaw=24; const int
inChar=96; const int inMslabel=106;
//};
// Oracle external data types (see Programmer's Guide to the
// Oracle Call Interface, chapter 3)
//enum otl_external_type{ const int extVarChar2=inVarChar2; const int
extNumber=inNumber; const int extInt=3; const int extFloat=4; const int
extCChar=5; const int extVarNum=6; const int extLong=inLong; const int
extVarChar=9; const int extRowId=inRowId; const int extDate=inDate;
const int extVarRaw=15; const int extRaw=inRaw; const int
extLongRaw=inLongRaw; const int extUInt=68; const int
extLongVarChar=94; const int extLongVarRaw=95; const int
extChar=inChar; const int extCharZ=97; const int extMslabel=inMslabel;
//};
// Container data types for some of Oracle external data types defined
// in Programmer's Guide to the Oracle Call Interface, chapter 3:
typedef ub1 otl_date_intern[7]; // date Oracle internal format
typedef ub1 otl_rowid_intern[14]; // rowid in Oracle internal format
typedef char otl_cchar_rowid[19]; // rowid in text format
typedef ub1 otl_varnum_intern[22]; // varnum in internal format
typedef ub1 otl_number_intern[21]; // number in Oracle 21-byte binary
// format // Error codes and messages, used in an exception raised in
the
// otl_select_stream class and otl_out_stream_class
const int otl_error_code_0=32000; #define otl_error_msg_0 "Incompatible
data types in stream operation"
const int otl_error_code_1=32004; #define otl_error_msg_1 "No input
variables have been defined in SQL statement"
const int otl_error_code_2=32004; #define otl_error_msg_2 "Not all
input variables have been initialized"
const int otl_error_code_3=32001; #define otl_error_msg_3 "Row must be
full for flushing output stream"
// OTL "Blocked Call" class. It is used for "non-blocking" Oracle
// connections. The otl_blocked_call exception is raised when the
// current call of an OCI function is blocked.
class otl_blocked_call{
public: otl_blocked_call(){}; ~otl_blocked_call(){};
};
const int otl_blocked=3123; // Return code, indicating that the most //
recent Oracle call has been blocked
const int otl_blocking=3128; // Return code, indicating that the //
current Oracle connection is still blocking
const int otl_nonblocking=1; // Return code, indicating that the //
current connection is nonblocking
// OTL exception class. Exceptions of this type are raised by the
// library functions (default mode), unless it is prohibited
// explicitly in the otl_connect or otl_cursor class constructors
// (see below). In case of disabled exceptions OTL functions
// return codes and it the user's responsibility to check out the
// codes and handle errors. The main advantage of using this
// exception handling mechanism is that exceptions can be<br>
// processed in one catch block, instead of checking return codes<br>
// from every library function call. <br>
  <br>
class otl_exception{<br>
  <br>
public:<br>
  <br>
// This "enum" defines two constants which are used in<br>
// constructors of the otl_connect, otl_cursor and<br>
// otl_select_cursor classes.<br>
  <br>
enum{ disabled, enabled };<br>
  <br>
unsigned char msg[1000]; // error message buffer<br>
unsigned char* stm_text;// sql that caused the error<br>
int code; // error code<br>
  <br>
// Create exception from LDA<br>
otl_exception(Lda_Def&amp; lda,const char* sqlstm=0)<br>
{if(lda.rc==otl_blocked)throw otl_blocked_call();<br>
init(lda,sqlstm);<br>
}<br>
  <br>
// Create exception from amsg and acode<br>
otl_exception(const char* amsg,const int acode,const char* sqlstm=0)<br>
{if(acode==otl_blocked)throw otl_blocked_call();<br>
init(amsg,acode,sqlstm);<br>
}<br>
  <br>
// Copy constructor<br>
otl_exception(const otl_exception&amp; p)<br>
{init((char*)p.msg,p.code,(const char*)p.stm_text);}<br>
  <br>
// Default constructor<br>
otl_exception(){stm_text=0;}<br>
  <br>
// Destructor<br>
~otl_exception(){delete[] stm_text;stm_text=0;}<br>
  <br>
// Init-function<br>
void init(const char* amsg,const int acode,const char* sqlstm)<br>
{stm_text=0;<br>
code=acode;<br>
if(sqlstm) {<br>
stm_text=new unsigned char[strlen(sqlstm)+1];<br>
strcpy((char*)stm_text,sqlstm);<br>
}<br>
}<br>
  <br>
// Init-function<br>
void init(const otl_exception&amp; p)<br>
{init((const char*)p.msg,p.code,(const char*)p.stm_text);}<br>
  <br>
protected:<br>
  <br>
INLINE void init(Lda_Def&amp; lda,const char* sqlstm=0); <br>
// get error code and message<br>
  <br>
};<br>
  <br>
// Parent for otl_cursor and otl_connect classes<br>
class otl_object{<br>
  <br>
public:<br>
int connected; // "connected" flag<br>
  <br>
// Default constructor<br>
INLINE otl_object();<br>
  <br>
// Destructor<br>
virtual ~otl_object(){};<br>
  <br>
  <br>
protected:<br>
int ex_enabled; // "exception enabled" flag<br>
  <br>
};<br>
  <br>
class otl_out_stream;<br>
  <br>
// Connect class. Object of this class are used for connecting to<br>
// Oracle.<br>
class otl_connect: public otl_object{<br>
  <br>
public:<br>
  <br>
Lda_Def lda; // Logon Descriptor Area (see OCI doc. for more<br>
// details)<br>
  <br>
ub2&amp; rc; // reference to "V7 return code"<br>
  <br>
// Create "connect" object<br>
INLINE otl_connect(int exception_enabled=otl_exception::enabled);<br>
// exceptions are allowed to raise by default<br>
  <br>
// Create "connect" object and connect to Oracle using the<br>
// "connect_str" connect string; by default, exceptions are<br>
// allowed to raise<br>
INLINE otl_connect(const char* connect_str, <br>
int exception_enabled=otl_exception::enabled<br>
);<br>
  <br>
// Destructor<br>
INLINE ~otl_connect();<br>
  <br>
// Concurrent logon; OCI application is allowed to have more than one<br>
// concurrent logon. Returns 1 on success, 0 on failure.<br>
INLINE int rlogon(const char* connect_str // Connect string<br>
);<br>
  <br>
// Test if connection is in blocking mode. Returns "otl_blocking" if<br>
// connection is blocking, "otl_nonblocking" if connection is<br>
// non-blocking and 0 on failure.<br>
INLINE int test_blocking(void);<br>
  <br>
// Set nonblocking connection mode. Returns 1 on success, 0 on<br>
// failure.<br>
INLINE int set_nonblocking(void);<br>
  <br>
// Clear nonblocking connection mode. In other words, set blocking<br>
// connection mode.<br>
INLINE int clear_nonblocking(void);<br>
  <br>
// Get valid LDA from Pro*C. Returns 1 on success, 0 on failure.<br>
INLINE int sqllda(void);<br>
  <br>
// Get valid LDA from X/Open. Returns 1 on success, 0 on failure.<br>
INLINE int sqlld2(const char* dbname);<br>
  <br>
// Exclusive logon. there may be only one logon of this type performed<br>
// in OCI application (for more details see OCI doc.). Returns 1 on<br>
// success, 0 on failure.<br>
INLINE int logon(const char* connect_str);<br>
  <br>
// Disconnect from / log off Oracle. Returns 1 on success, 0 on<br>
// failure.<br>
INLINE int logoff(void);<br>
  <br>
// Commit current transaction. Returns 1 on success, 0 on failure.<br>
INLINE int commit(void);<br>
  <br>
// Roll back current transaction. Returns 1 on success, 0 on failure.<br>
INLINE int rollback(void);<br>
  <br>
// Break current OCI call. Returns 1 on success, 0 on failure.<br>
INLINE int obreak(void);<br>
  <br>
// Set auto commit mode on. Returns 1 on success, 0 on failure.<br>
INLINE int auto_commit_on(void);<br>
  <br>
// Set auto commit mode off. Returns 1 on success, 0 on failure.<br>
INLINE int auto_commit_off(void);<br>
  <br>
// Thread safe initialization. Returns 1 on success, 0 on failure.<br>
// This function needs to be called only once at the very beginning of<br>
// the program. This function works in Oracle 7.3 only.<br>
INLINE static int thread_safe_init(void);<br>
  <br>
protected:<br>
  <br>
unsigned char hda[512]; // private logon area<br>
int proc_connect; // connected via Pro*C EXEC SQL CONNECT...;<br>
  <br>
friend otl_out_stream;<br>
  <br>
  <br>
public:<br>
  <br>
void* handler; // reserved for use in Prosto*C <br>
};<br>
  <br>
  <br>
// Select list item (column) descriptor<br>
class otl_column_desc{<br>
  <br>
public:<br>
sb1 name[241]; // field name<br>
sb4 nlen; // field name length<br>
sb4 dbsize; // field size as the field is presented inside ORACLE <br>
sb2 dbtype; // internal datatype code<br>
sb2 scale; // numeric field scale: NUMBER(scale,precision)<br>
sb2 prec; // numeric field precision<br>
sb4 dsize; // maximum display size of the field<br>
sb2 nullok; // NULLs are allowed <br>
  <br>
};<br>
  <br>
  <br>
class otl_cursor;<br>
class otl_ref_cursor;<br>
class otl_select_stream;<br>
class otl_ref_select_stream;<br>
class otl_out_stream;<br>
class otl_inout_stream;<br>
  <br>
// OTL generic variable -- parent of the otl_variable, otl_array<br>
// template classes and otl_dynamic_variable. This class is needed in<br>
// order to pass over internal info about actual host variables and<br>
// arrays, instantiated from the templates.<br>
  <br>
class otl_generic_variable{<br>
public:<br>
  <br>
// Default constructor<br>
INLINE otl_generic_variable();<br>
  <br>
// Destructor<br>
INLINE virtual ~otl_generic_variable();<br>
  <br>
// Assigning a name to the variable<br>
INLINE void copy_name(const char* aname);<br>
  <br>
// Assigning a position (number) to the select list item (column)<br>
INLINE void copy_pos(const int apos);<br>
  <br>
// For more detail on indicator, returned length and returned code<br>
// arrays see Programmer's Guide to the Oracle Call Interface<br>
  <br>
// For input variable/array:<br>
  <br>
INLINE virtual void set_null(int ndx=0);<br>
// Set variable's value as NULL<br>
  <br>
INLINE virtual void set_len(int len, int ndx=0);<br>
// Set variable's buffer length<br>
  <br>
INLINE virtual void set_not_null(int ndx=0);<br>
// Set variable's value as NOT NULL<br>
  <br>
// For output variable/array:<br>
  <br>
INLINE virtual int is_null(int ndx=0);<br>
// Check if variable's value is NULL<br>
  <br>
INLINE virtual int is_success(int ndx=0);<br>
// Check if variable's value has been fetched OK.<br>
  <br>
INLINE virtual int is_truncated(int ndx=0);<br>
// Check if variable's value is truncated <br>
  <br>
INLINE virtual void* val(int ndx=0);<br>
// Get pointer to variable's buffer<br>
  <br>
// Only for output arrays, defined in select statement:<br>
  <br>
INLINE virtual int is_invalid_conversion(int ndx=0);<br>
// Check if during fetch conversion error occurred<br>
  <br>
INLINE virtual int is_real_overflow(int ndx=0);<br>
// Check if during fetch real overflow occurred<br>
  <br>
INLINE virtual int is_unsupported_datatype(int ndx=0);<br>
// Check if variable has unsupported data type<br>
  <br>
// Used only for PLSQL tables: set/get PLSQL table size<br>
INLINE virtual void set_tab_len(int new_len);<br>
INLINE virtual int get_tab_len(void);<br>
  <br>
protected:<br>
  <br>
friend otl_cursor;<br>
friend otl_ref_cursor;<br>
friend otl_select_stream;<br>
friend otl_ref_select_stream;<br>
friend otl_out_stream;<br>
friend otl_inout_stream;<br>
  <br>
ub1* p_v; // pointer to buffer<br>
sb2* p_ind; // pointer to indicator variable/array<br>
ub2* p_rlen; // pointer to column's returned length<br>
ub2* p_rcode; // poinetr column's returned code<br>
int ftype; // external data type's code of the host variable/array<br>
int elem_size; // array element/variable size<br>
int array_size; // host array size (=1 in case of scalar host variable)<br>
char* name; // variable name; <br>
int pos; // select list item position<br>
  <br>
// Used only for PLSQL tables<br>
ub4 max_tab_len; // maximum length (of PLSQL table)<br>
ub4 cur_tab_len; // current length (of PLSQL table)<br>
  <br>
};<br>
  <br>
// pointer to otl_generic_variable<br>
typedef otl_generic_variable* otl_p_generic_variable;<br>
  <br>
// OTL dynamic variable/array class. Used in otl_select_stream to<br>
// automatically allocate default select list items based on the<br>
// information from the describe_column function.<br>
  <br>
class otl_dynamic_variable: public otl_generic_variable{<br>
public:<br>
  <br>
// Dynamically construct a select list item (column)<br>
INLINE otl_dynamic_variable(<br>
const int column_num, // column number/position in select<br>
// list <br>
const int Aftype, // external data type of the column<br>
const int Aelem_size, // host array element/variable size<br>
const short Aarray_size=1 // array size<br>
);<br>
  <br>
// Dynamically construct host variable/array<br>
INLINE otl_dynamic_variable(<br>
const char *aname, // varable/array name<br>
const int Aftype, // external data type <br>
const int Aelem_size, // variable/array element size<br>
const short Aarray_size=1 // array size<br>
);<br>
  <br>
// Default constructor<br>
INLINE otl_dynamic_variable();<br>
  <br>
// Destructor<br>
INLINE ~otl_dynamic_variable();<br>
  <br>
// Allocate memory and initialize variable/array<br>
INLINE void init(const int Aftype, // external data types<br>
const int Aelem_size, // array element/variable size<br>
const short Aarray_size // array size<br>
);<br>
  <br>
// return dynamic variable's external data type<br>
INLINE int get_ftype(void);<br>
  <br>
// return dynamic variable's elem_size<br>
INLINE int get_elem_size(void);<br>
  <br>
};<br>
  <br>
// OTL (general-purpose) cursor class<br>
  <br>
class otl_cursor: public otl_object{<br>
  <br>
public:<br>
  <br>
Cda_Def cda; // Cursor Descriptor Area<br>
  <br>
// convenient references to some of the CDA fields<br>
ub4&amp; rpc; // reference to "rows processed count"<br>
ub2&amp; ft; // reference to "OCI function code"<br>
ub2&amp; rc; // reference to "V7 return code"<br>
ub2&amp; peo; // reference to "parse error offset"<br>
char* stm_text; // SQL Statement Text<br>
  <br>
// Create "cursor" object. by default, exceptions are allowed to<br>
// raise.<br>
INLINE otl_cursor(int exception_enabled=otl_exception::enabled);<br>
  <br>
// Create "cursor" object and open cursor via "connect"<br>
INLINE otl_cursor(otl_connect&amp; connect, // reference to "connect"
object<br>
int exception_enabled=otl_exception::enabled<br>
);<br>
  <br>
// Close cursor (if opened) and destruct object<br>
INLINE ~otl_cursor();<br>
  <br>
// Open cursor via "connect". Returns 1 on success, 0 on failure<br>
INLINE int open(otl_connect&amp; connect);<br>
  <br>
// Close cursor. Returns 1 on success, 0 on failure<br>
INLINE virtual int close(void);<br>
  <br>
// Cancel a query after desired number of rows have been<br>
// fetched. Returns 1 on success, 0 on failure<br>
INLINE int cancel(void);<br>
  <br>
// Set rollback options for non-fatal Oracle errors. For more info see<br>
// the OCI manual, the "oopt" function. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int option(int rbopt, int waitopt);<br>
  <br>
// Fetch a portion of a LONG or LONG RAW column. For more info see the<br>
// OCI manual, the "oflng" function. Returns 1 on success, 0 on failure<br>
INLINE int fetch_long(int column_num, // column number: 1,2,...<br>
void* buf, // pointer to buffer<br>
sb4 bufl, // buffer size<br>
int dtype, // buffer data type, see ext* "enum"<br>
ub4* retl, // returned length<br>
sb4 offset // offset<br>
);<br>
  <br>
// Parse sql statement. Returns 1 on success, 0 on failure<br>
INLINE int parse(const char* sqlstm);<br>
  <br>
  <br>
// Extended Parse function -- eparse:<br>
// Parse sql statement;<br>
// bind variable and select list items;<br>
// variable list needs to be terminated with 0 pointer;<br>
// Returns 1 on success, 0 on failure.<br>
  <br>
// if variable list contains variables which are SELECT statement's<br>
// output columns and if the variables don't have "column_num"<br>
// defined, then the parse function enumerates the variables as follows:<br>
//<br>
// eparse("select...",&amp;f1,&amp;f2,&amp;f3,0);<br>
// f1 -- column 1<br>
// f2 -- column 2<br>
// f3 -- column 3<br>
// <br>
INLINE int eparse(const char* sqlstm,...);<br>
  <br>
// Execute statement iters times. Returns 1 on success, 0 on failure<br>
INLINE int exec(short iters=1);<br>
  <br>
// Combined operation: Parse+Bind+Execute (Extended Exec function)<br>
// Parse sqlstm;<br>
// Bind variables;<br>
// Execute statement iters times. <br>
// Returns 1 on success, 0 on failure<br>
INLINE int eexec(const char* sqlstm, // SQL statement<br>
short iters, // number of iterations<br>
... // NULL terminated list of pointers to bind variables<br>
);<br>
  <br>
  <br>
// Fetch iters number of rows. Returns 1 on success, 0 on failure<br>
INLINE int fetch(short iters=1);<br>
  <br>
// Combined operation -- execute statement + fetch iters number of<br>
// rows. Returns 1 on success, 0 on failure<br>
INLINE int exfet(short iters=1);<br>
  <br>
  <br>
// --------------- Functions to bind placeholders ------------------ <br>
  <br>
  <br>
// Bind host variable/array (instantiated template) to<br>
// placeholder. Returns 1 on success, 0 on failure<br>
INLINE virtual int bind(const char* name, // placeholder name: ":F1",
":F2"<br>
otl_generic_variable&amp; v <br>
// reference to host variable/array<br>
);<br>
  <br>
// Bind host array (instantiated template) with placeholder as PLSQL<br>
// table. Returns 1 on success, 0 on failure<br>
INLINE virtual int bind_tab(const char* name, // placeholder name:
":F1", ":F2"<br>
otl_generic_variable&amp; v <br>
// reference to host array <br>
);<br>
  <br>
// Bind "ordinary" host variable/array to placeholder. Returns 1 on<br>
// success, 0 on failure<br>
INLINE int bind(const char* name, // placeholder name: ":f1", ":f2"<br>
void* buf, // pointer to host variable/array<br>
int elem_size, //array element/ variable size in bytes<br>
int ftype, // Oracle external data type code<br>
sb2* indp=0 // pointer to indicator variable/array <br>
);<br>
  <br>
// Bind template host variable/array with already defined<br>
// name. Returns 1 on success, 0 on failure<br>
INLINE virtual int bind(otl_generic_variable&amp; v);<br>
  <br>
// Bind template host array with already defined name of placeholder<br>
// as PLSQL table. Returns 1 on success, 0 on failure.<br>
INLINE virtual int bind_tab(otl_generic_variable&amp; v);<br>
  <br>
  <br>
// ------------ Functions to bind select items (columns)
----------------- <br>
  <br>
  <br>
// Bind host variable/array (instantiated template) to column. Returns<br>
// 1 on success, 0 on failure<br>
INLINE virtual int bind(int column_num, // column number: 1,2,...<br>
otl_generic_variable&amp; v // reference to variable/array<br>
);<br>
  <br>
// bind "ordinary" host variable/array to column. Returns 1 on<br>
// success, 0 on failure<br>
INLINE int bind(int column_num, // column number: 1,2,...<br>
void* buf, // pointer to host variable/array<br>
int elem_size, // array element/variable size in bytes<br>
int ftype, // Oracle external data type code<br>
sb2* indp=0, // pointer to indicator array/varibale<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array variable<br>
);<br>
  <br>
  <br>
// ------------- Specialized bind functions ------------------ <br>
  <br>
// Functions to bind "ordinary" host variables/arrays of different<br>
// data types.<br>
  <br>
  <br>
// ------------- Specialized function to bind columns ------------- <br>
  <br>
  <br>
// Bind C-style (null terminated) string variable/array to<br>
// column. Returns 1 on success, 0 on failure<br>
INLINE int bind_cstring(int column_num, // column number: 1,2,...<br>
char* buf, // pointer to C-string variable/array<br>
int elem_size, // array element/variable size<br>
sb2* indp=0, // pointer to indicator array/variable<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array/variable<br>
);<br>
  <br>
// Bind int variable/array to column. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int bind_int(int column_num, // column number: 1,2,...<br>
int* buf, // pointer to int variable/array<br>
sb2* indp=0, // pointer to indicator array/variable<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array/variable<br>
);<br>
  <br>
// Bind short int variable/array to column. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int bind_short(int column_num,// column number: 1,2,...<br>
short* buf, // pointer to short int variable/array<br>
sb2* indp=0, // pointer to indicator array/variable<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array/variable<br>
);<br>
  <br>
// Bind long int variable/array to column. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int bind_long_int(int column_num, // column number: 1,2,...<br>
long* buf, // pointer to long int variable/array<br>
sb2* indp=0, // pointer to indicator array/variable<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array/variable<br>
);<br>
  <br>
// Bind float variable/array to column. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int bind_float(int column_num,// column number: 1,2,...<br>
float* buf, // pointer to float variable/array<br>
sb2* indp=0, // pointer to indicator array/variable<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array/variable<br>
);<br>
  <br>
// Bind double variable/array to column. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int bind_double(int column_num,// column number: 1,2,...<br>
double* buf, // pointer to double variable/array<br>
sb2* indp=0, // pointer to indicator array/variable<br>
ub2* rlen=0, // pointer to returned length array/variable<br>
ub2* rcode=0 // pointer to returned code array/variable<br>
);<br>
  <br>
  <br>
// ----------- Specialized function to bind placeholders ------------- <br>
  <br>
// Bind C-style (null terminated) string variable/array to<br>
// column. Returns 1 on success, 0 on failure<br>
INLINE int bind_cstring(const char* name, // placeholder name: ":F1",
":F2"<br>
char* buf, // pointer to C-string variable/array<br>
int elem_size, // array element/variable size<br>
sb2* indp=0 // pointer to indicator array/variable<br>
);<br>
  <br>
// Bind int variable/array to placeholder. Returns 1 on success, 0 on<br>
// failure<br>
INLINE int bind_int(const char* name, // placeholder name: ":F1", ":F2"<br>
int* buf, // pointer to int variable/array<br>
sb2* indp=0 // pointer to indicator array/variable<br>
);<br>
  <br>
// Bind short int variable/array to placeholder. Returns 1 on success,<br>
// 0 on failure<br>
INLINE int bind_short(const char* name, // placeholder name: ":F1",
":F2"<br>
short* buf, // pointer to short int variable/array<br>
sb2* indp=0 // pointer to indicator array/variable<br>
);<br>
  <br>
// Bind long int variable/array to placeholder. Returns 1 on success,<br>
// 0 on failure<br>
INLINE int bind_long_int(const char* name, // placeholder name: ":F1",
":F2"<br>
long* buf, // pointer to long int variable/array<br>
sb2* indp=0 // pointer to indicator array/variable<br>
);<br>
  <br>
// Bind float variable/array to placeholder. Returns 1 on success, 0<br>
// on failure<br>
INLINE int bind_float(const char* name, // placeholder name: ":F1",
":F2"<br>
float* buf, // pointer to float variable/array<br>
sb2* indp=0 // pointer to indicator array/variable<br>
);<br>
  <br>
// Bind double variable/array to placeholder. Returns 1 on success, 0<br>
// on failure<br>
INLINE int bind_double(const char* name, // placeholder name: ":F1",
":F2"<br>
double* buf, // pointer to double variable/array<br>
sb2* indp=0 // pointer to indicator array/variable<br>
);<br>
  <br>
// -------------- End of Specialized bind functions --------------- <br>
  <br>
  <br>
// Static (in class) function to immediately execute a constant SQL<br>
// statement. Returns 1 on success, 0 on failure<br>
INLINE static int direct_exec(otl_connect&amp; db, // connect object<br>
const char* stm, // statement<br>
int exception_enabled=otl_exception::enabled<br>
// exception_enabled flag<br>
);<br>
  <br>
// Check "end-of-file" condition when fetching rows from select<br>
// statement. Returns 1 when "EOF", 0 otherwise<br>
INLINE int eof(void);<br>
  <br>
// describe select item (column)<br>
INLINE virtual int describe_column(<br>
otl_column_desc&amp; col_desc, // column descriptor structure<br>
int column_num // column number: 1,2,...<br>
);<br>
  <br>
// "End-of-description" condition check<br>
INLINE int end_of_desc(void);<br>
  <br>
// Parse statement and bind variables<br>
INLINE int parse(const char* sqlstm, // SQL statement<br>
otl_generic_variable** v // pointer to variable list<br>
);<br>
  <br>
protected:<br>
  <br>
// Internal stuff<br>
  <br>
int vl_len; // variable list length<br>
otl_p_generic_variable* vl; // variable list<br>
otl_connect* adb; // pointer to connect object<br>
  <br>
INLINE void alloc_var(otl_p_generic_variable* vp);<br>
  <br>
// Parse sql statement. Returns 1 on success, 0 on failure<br>
INLINE int parse(void);<br>
  <br>
};<br>
  <br>
// Specialized cursor -- OTL select cursor class<br>
class otl_select_cursor: public otl_cursor{<br>
  <br>
public:<br>
  <br>
int cur_row; // index of current row in host array<br>
int cur_size; // number of rows in the buffer after most recent fetch<br>
int row_count; // row count -- total number of rows fetched<br>
int array_size; // size of host array attached to select statement<br>
  <br>
  <br>
// General constructor<br>
INLINE otl_select_cursor(otl_connect&amp; db, // connect object<br>
short arr_size=1, // attached host array size<br>
int exception_enabled=otl_exception::enabled<br>
// exception enabled flag<br>
);<br>
  <br>
// Default constructor<br>
INLINE otl_select_cursor(int exception_enabled=otl_exception::enabled);<br>
  <br>
  <br>
// Open cursor<br>
INLINE int open(otl_connect&amp; db, // connect object<br>
short arr_size=1, // attached host array size<br>
int exception_enabled=otl_exception::enabled<br>
// exception enabled flag<br>
);<br>
  <br>
// Close cursor<br>
INLINE int close(void);<br>
  <br>
// Fetch first row. rows are fetched in batches. "cur_row" points to<br>
// current row in host array attached to select statement.<br>
// cur_row==-1 if no rows have been fetched. Returns 1 on success, 0<br>
// on failure.<br>
INLINE int first(void);<br>
  <br>
// Fetch next row. "cur_row" points to current row. cur_row==-1 after<br>
// fetch sequence is complete. Returns 1 on success, 0 on failure.<br>
INLINE int next(void);<br>
  <br>
};<br>
  <br>
const int otl_var_list_size=256; <br>
// maximum size of OTL select list<br>
  <br>
// Specialized cursor -- OTL reference cursor class. This<br>
// class implements Cursor References which were introduced in<br>
// Oracle 7.2<br>
class otl_ref_cursor: public otl_cursor{<br>
  <br>
public:<br>
  <br>
int cur_row; // index of current row in host array<br>
int cur_size; // number of rows in the buffer after most recent fetch<br>
int row_count; // row count -- total number of rows fetched<br>
int array_size; // size of host array attached to select statement<br>
  <br>
// General constructor<br>
INLINE otl_ref_cursor(otl_connect&amp; db, // connect object<br>
const char* cur_placeholder_name,<br>
// cursor reference placeholder name<br>
short arr_size=1, // attached host array size<br>
int exception_enabled=otl_exception::enabled<br>
// exception enabled flag<br>
);<br>
  <br>
// Default constructor<br>
INLINE otl_ref_cursor(int exception_enabled=otl_exception::enabled<br>
// exception enabled flag<br>
);<br>
  <br>
// Close cursor (if opened) and destruct object<br>
INLINE ~otl_ref_cursor();<br>
  <br>
// Open cursor<br>
INLINE int open(otl_connect&amp; db, // connect object<br>
const char* cur_placeholder_name,<br>
// cursor reference placeholder name<br>
short arr_size=1, // attached host array size<br>
int exception_enabled=otl_exception::enabled<br>
// exception enabled flag<br>
);<br>
  <br>
// Close cursor<br>
INLINE int close(void);<br>
  <br>
// Fetch first row. rows are fetched in batches. "cur_row" points to<br>
// current row in host array attached to select statement.<br>
// cur_row==-1 if no rows have been fetched. Returns 1 on success, 0<br>
// on failure.<br>
INLINE int first(void);<br>
  <br>
// Fetch next row. "cur_row" points to current row. cur_row==-1 after<br>
// fetch sequence is complete. Returns 1 on success, 0 on failure.<br>
INLINE int next(void);<br>
  <br>
// Bind host variable/array (instantiated template) to column. Returns<br>
// 1 on success, 0 on failure<br>
INLINE int bind(int column_num, // column number: 1,2,...<br>
otl_generic_variable&amp; v // reference to variable/array<br>
);<br>
  <br>
// Bind template host variable/array with already defined<br>
// name. Returns 1 on success, 0 on failure<br>
INLINE int bind(otl_generic_variable&amp; v);<br>
  <br>
// Bind host variable/array (instantiated template) to<br>
// placeholder. Returns 1 on success, 0 on failure<br>
INLINE int bind(const char* name, // placeholder name: ":F1", ":F2"<br>
otl_generic_variable&amp; v // reference to host variable/array<br>
);<br>
  <br>
// Describe reference cursor's select item list. Returns 1 on success,<br>
// 0 on failure.<br>
INLINE int describe_select(<br>
otl_column_desc* desc, // pointer to array of column<br>
// descriptors<br>
int&amp; desc_len // actual number of columns<br>
);<br>
  <br>
protected:<br>
  <br>
int rvl_len; // variable list length<br>
otl_p_generic_variable* rvl; // reference cursor variable (column) list<br>
int vl_cur_len; // Current size of the vl array<br>
otl_cursor sel_cur; // cursor, used for the reference cursor<br>
char cur_placeholder[64]; // Reference cursor placeholder name<br>
};<br>
  <br>
const int otl_max_long_size=32760;<br>
// max default size of LONG and LONG RAW internal data types in<br>
// otl_select_stream.<br>
  <br>
// OTL Select Stream class. Dynamically allocates default select list<br>
// items (output columns) by the information from the describe_column<br>
// function. <br>
// This class may issue the following otl_exceptions:<br>
//<br>
// Incompatible data types in stream operation, code=32000<br>
// Not all input variables have been initialized, code=32004<br>
// No input variables have beed defined in SELECT statement, code=32004<br>
//<br>
class otl_select_stream: public otl_select_cursor{<br>
public:<br>
  <br>
// General conctructor. SELECT statement is parsed, all input host<br>
// variables and output columns are automatically bound.<br>
INLINE otl_select_stream(otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SELECT statement <br>
const short arr_size, // output host arrays size<br>
... // NULL terminated list of pointers to input host<br>
// variables. <br>
);<br>
  <br>
// General conctructor. SELECT statement is parsed, all input host<br>
// variables and output columns are automatically bound. The<br>
// difference between this constructor and the constuctor above is<br>
// that this constuctor takes a pointer to an array of pointer to the<br>
// host variable/array list, instead of taking them from stack, as the<br>
// above constuctor does. This allows the user to dynamically create<br>
// host variables, say, in a loop, and collect pointers to the variables<br>
// into an array.<br>
INLINE otl_select_stream(otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SELECT statement <br>
otl_p_generic_variable* avp,<br>
// Pointer to NULL terminated list of<br>
// pointers to input hots<br>
// variables<br>
const short arr_size=1 // output host arrays size<br>
);<br>
  <br>
// General conctructor. SELECT statement is parsed, all input host<br>
// variables and output columns are automatically allocated and<br>
// bound. This constructor allows the user to use extended<br>
// place-holder declarations:<br>
//<br>
// :NAME&lt;DATA_TYPE&gt;<br>
//<br>
// The following data types are available in the extended<br>
// declarations:<br>
//<br>
// :VAR&lt;char[&lt;length&gt;]&gt;, e.g. :F1&lt;char[32]&gt;<br>
// :VAR&lt;int&gt;<br>
// :VAR&lt;short&gt;<br>
// :VAR&lt;long&gt;<br>
// :VAR&lt;unsigned&gt;<br>
// :VAR&lt;float&gt;<br>
// :VAR&lt;double&gt;<br>
// <br>
INLINE otl_select_stream(<br>
const short arr_size, // output host arrays size<br>
const char* sqlstm, // SELECT statement <br>
otl_connect&amp; db // connect object<br>
);<br>
  <br>
  <br>
// Destructor<br>
INLINE ~otl_select_stream();<br>
  <br>
// Rewind stream, SQL statement is re-executed. Input host variables<br>
// of SELECT statement may be re-assigned before calling this<br>
// function.<br>
INLINE void rewind(void);<br>
  <br>
// Test if NULL has been fetched during last stream operation<br>
INLINE int is_null(void);<br>
  <br>
// Test if "end-of-file" has been reached. Returns 1 when<br>
// "end-of-file".<br>
INLINE int eof(void);<br>
  <br>
// Read objects from stream<br>
  <br>
INLINE otl_select_stream&amp; operator&gt;&gt;(char&amp; c);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(unsigned char&amp; c);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(char* s);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(unsigned char* s);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(int&amp; n);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(unsigned&amp; u);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(short&amp; sh);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(long int&amp; l);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(float&amp; f);<br>
INLINE otl_select_stream&amp; operator&gt;&gt;(double&amp; d);<br>
  <br>
// Write input values to the stream<br>
// (initialize input variables)<br>
  <br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const char c);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const unsigned char c);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const char* s);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const unsigned char* s);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const int n);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const unsigned u);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const short sh);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const long int l);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const float f);<br>
INLINE otl_select_stream&amp; operator&lt;&lt;(const double d);<br>
  <br>
  <br>
// Get info on SELECT list items<br>
  <br>
INLINE int select_list_len(void);<br>
INLINE int column_ftype(int ndx=0);<br>
INLINE int column_size(int ndx=0);<br>
  <br>
// Get column's internal info<br>
  <br>
otl_column_desc* sl_desc; // column descriptor array<br>
  <br>
  <br>
// Set flag "delete input host variables"<br>
INLINE void set_delete_var(const int should_delete=0);<br>
  <br>
protected:<br>
  <br>
otl_dynamic_variable* sl; // Select list -- output columns.<br>
int sl_len; // Select list length<br>
  <br>
int null_fetched; // "NULL fetched" flag<br>
int ret_code; // "return code" variable<br>
int cur_col; // current column index<br>
int cur_in; // current input variable index<br>
int executed; // "statement executed" flag<br>
  <br>
// Internal stuff<br>
  <br>
int should_delete_flag; // "should delete host variables" flag<br>
  <br>
INLINE void init(int);<br>
INLINE void get_next(void);<br>
INLINE int check_type(int type_code);<br>
INLINE void look_ahead(void);<br>
INLINE void bind_all(void);<br>
INLINE void get_select_list(void);<br>
  <br>
INLINE void get_in_next(void);<br>
INLINE int check_in_type(int type_code,int tsize);<br>
  <br>
INLINE void check_in_var(void);<br>
INLINE void check_if_executed(void);<br>
  <br>
public:<br>
  <br>
// Special constructor. It parses SELECT statement and gets SELECT<br>
// list information. This constructor can be used when the user does<br>
// not really want to fetch rows via this stream but wants to get<br>
// information on the SELECT list (output columns).<br>
  <br>
INLINE otl_select_stream(const char* sqlstm, // SELECT statement <br>
otl_connect&amp; db, // connect object<br>
const char* dummy_par // dummy parameter (needed for<br>
// making the function<br>
// prototype unique<br>
);<br>
  <br>
  <br>
};<br>
  <br>
class otl_ref_select_stream: public otl_ref_cursor{<br>
public:<br>
  <br>
// General conctructor. PLSQL block is parsed, all input host<br>
// variables and output columns are automatically bound.<br>
INLINE otl_ref_select_stream(<br>
otl_connect&amp; db, // connect object<br>
const char* sqlstm, // PLSQL block<br>
const char* cur_placeholder,<br>
// reference cursor placeholder<br>
const short arr_size, // output host arrays size<br>
... // NULL terminated list of pointers to input host<br>
// variables. <br>
);<br>
  <br>
// General conctructor. PLSQL block is parsed, all input host<br>
// variables and output columns are automatically bound. The<br>
// difference between this constructor and the constuctor above is<br>
// that this constuctor takes a pointer to an array of pointer to the<br>
// host variable/array list, instead of taking them from stack, as the<br>
// above constuctor does. This allows the user to dynamically create<br>
// host variables, say, in a loop, and collect pointers to the variables<br>
// into an array.<br>
INLINE otl_ref_select_stream(<br>
otl_connect&amp; db, // connect object<br>
const char* sqlstm, // PLSQL block<br>
const char* cur_placeholder,<br>
// reference cursor placeholder<br>
otl_p_generic_variable* avp,<br>
// Pointer to NULL terminated list of<br>
// pointers to input hots<br>
// variables<br>
const short arr_size=1 // output host arrays size<br>
);<br>
  <br>
// General conctructor. PLSQL block is parsed, all input host<br>
// variables and output columns are automatically allocated and<br>
// bound. This constructor allows the user to use extended<br>
// place-holder declarations:<br>
//<br>
// :NAME&lt;DATA_TYPE&gt;<br>
//<br>
// The following data types are available in the extended<br>
// declarations:<br>
//<br>
// :VAR&lt;char[&lt;length&gt;]&gt;, e.g. :F1&lt;char[32]&gt;<br>
// :VAR&lt;int&gt;<br>
// :VAR&lt;short&gt;<br>
// :VAR&lt;long&gt;<br>
// :VAR&lt;unsigned&gt;<br>
// :VAR&lt;float&gt;<br>
// :VAR&lt;double&gt;<br>
// <br>
INLINE otl_ref_select_stream(<br>
const short arr_size, // output host arrays size<br>
const char* sqlstm, // PLSQL block <br>
const char* cur_placeholder,<br>
// reference cursor placeholder<br>
otl_connect&amp; db // connect object<br>
);<br>
  <br>
  <br>
// Destructor<br>
INLINE ~otl_ref_select_stream();<br>
  <br>
// Rewind stream, PLSQL block is re-executed. Input host variables<br>
// of the block may be re-assigned before calling this<br>
// function.<br>
INLINE void rewind(void);<br>
  <br>
// Test if NULL has been fetched during last stream operation<br>
INLINE int is_null(void);<br>
  <br>
// Test if "end-of-file" has been reached. Returns 1 when<br>
// "end-of-file".<br>
INLINE int eof(void);<br>
  <br>
// Read objects from stream<br>
  <br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(char&amp; c);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(unsigned char&amp;
c);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(char* s);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(unsigned char* s);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(int&amp; n);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(unsigned&amp; u);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(short&amp; sh);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(long int&amp; l);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(float&amp; f);<br>
INLINE otl_ref_select_stream&amp; operator&gt;&gt;(double&amp; d);<br>
  <br>
// Write input values to the stream<br>
// (initialize input variables)<br>
  <br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const char c);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const unsigned char
c);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const char* s);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const unsigned char*
s);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const int n);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const unsigned u);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const short sh);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const long int l);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const float f);<br>
INLINE otl_ref_select_stream&amp; operator&lt;&lt;(const double d);<br>
  <br>
  <br>
// Get info on SELECT list items<br>
  <br>
INLINE int select_list_len(void);<br>
INLINE int column_ftype(int ndx=0);<br>
INLINE int column_size(int ndx=0);<br>
  <br>
// Get column's internal info<br>
  <br>
otl_column_desc* sl_desc; // column descriptor array<br>
  <br>
  <br>
// Set flag "delete input host variables"<br>
INLINE void set_delete_var(const int should_delete=0);<br>
  <br>
protected:<br>
  <br>
otl_dynamic_variable* sl; // Select list -- output columns.<br>
int sl_len; // Select list length<br>
  <br>
int null_fetched; // "NULL fetched" flag<br>
int ret_code; // "return code" variable<br>
int cur_col; // current column index<br>
int cur_in; // current input variable index<br>
int executed; // "statement executed" flag<br>
  <br>
// Internal stuff<br>
  <br>
int should_delete_flag; // "should delete host variables" flag<br>
  <br>
INLINE void init(int);<br>
INLINE void get_next(void);<br>
INLINE int check_type(int type_code);<br>
INLINE void look_ahead(void);<br>
INLINE void get_select_list(void);<br>
  <br>
INLINE void get_in_next(void);<br>
INLINE int check_in_type(int type_code,int tsize);<br>
  <br>
INLINE void check_in_var(void);<br>
INLINE void check_if_executed(void);<br>
  <br>
};<br>
  <br>
  <br>
// OTL NULL class. This class is used only for writing NULL into OTL<br>
// stream classes.<br>
class otl_null{<br>
public:<br>
otl_null(){}<br>
~otl_null(){}<br>
};<br>
  <br>
  <br>
// OTL output stream. It should be used for the following SQL
statements:<br>
// <br>
// DELETE;<br>
// UPDATE;<br>
// INSERT;<br>
// PL/SQL block with input parameters;<br>
//<br>
class otl_out_stream: public otl_cursor{<br>
public:<br>
  <br>
// Default constructor<br>
INLINE otl_out_stream(otl_connect&amp; db);<br>
  <br>
  <br>
// General conctructor. SQL statement is parsed, all ouput host<br>
// variables are automatically bound.<br>
INLINE otl_out_stream(otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SQL statement <br>
...// NULL terminated list of pointers to input host<br>
// variables.<br>
);<br>
  <br>
// General conctructor. SQL statement is parsed, all ouput host<br>
// variables are automatically bound.<br>
INLINE otl_out_stream(otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SQL statement <br>
otl_p_generic_variable* avp<br>
// Pointer to NULL terminated list of pointers<br>
// to input hots variables.<br>
  <br>
);<br>
  <br>
  <br>
// General conctructor. SQL statement is parsed, all host variables<br>
// are automatically allocated and bound. This constructor allows the<br>
// user to use extended place-holder declarations:<br>
//<br>
// :NAME&lt;DATA_TYPE&gt;<br>
//<br>
// The following data types are available in the extended<br>
// declarations:<br>
//<br>
// :VAR&lt;char[&lt;length&gt;]&gt;, e.g. :F1&lt;char[32]&gt;<br>
// :VAR&lt;int&gt;<br>
// :VAR&lt;short&gt;<br>
// :VAR&lt;long&gt;<br>
// :VAR&lt;unsigned&gt;<br>
// :VAR&lt;float&gt;<br>
// :VAR&lt;double&gt;<br>
// <br>
INLINE otl_out_stream(<br>
short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db // connect object<br>
);<br>
  <br>
  <br>
// Destructor<br>
INLINE ~otl_out_stream();<br>
  <br>
// Write objects into stream<br>
  <br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const char c);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const unsigned char c);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const char* s);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const unsigned char* s);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const int n);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const unsigned u);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const short sh);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const long int l);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const float f);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const double d);<br>
INLINE otl_out_stream&amp; operator&lt;&lt;(const otl_null n); // write
Oracle NULL into stream<br>
  <br>
// Flush stream buffer. SQL statement is executed as many times as the<br>
// rows have been entered into the stream buffer.<br>
INLINE virtual void flush(void);<br>
  <br>
// Clean up stream buffer without flushing it.<br>
INLINE virtual void clean(void);<br>
  <br>
// Set "auto-commit" flag. When the buffer is flushed, current<br>
// transaction is automatically commited, if the flag is set.<br>
INLINE void set_commit(int auto_commit=0);<br>
  <br>
  <br>
// Set flag "delete host variables"<br>
INLINE void set_delete_var(const int should_delete=0);<br>
  <br>
protected:<br>
  <br>
int auto_commit_flag; // "auto-commit" flag<br>
int dirty; // "dirty buffer" flag<br>
int should_delete_flag; // "should delete" flag<br>
  <br>
int cur_x; //current variable/array index (X-coordinate)<br>
int cur_y; // current array element index (Y-coordinate)<br>
  <br>
short array_size; // host variables/arrays size<br>
otl_connect* connect; // connect object<br>
  <br>
int in_exception_flag; // "in exception" flag<br>
int in_destruct_flag; // "in destructor" flag<br>
  <br>
INLINE void init(otl_connect&amp; db,int should_delete=0);<br>
INLINE void get_next(void);<br>
INLINE int check_type(int type, int tsize);<br>
INLINE void check_buf(void);<br>
  <br>
};<br>
  <br>
  <br>
// OTL input/output stream. It is used primarily for PL/SQL blocks<br>
// with input and output parameters. Though, this stream class can be<br>
// used for SQL statements and PL/SQL blocks with input or output<br>
// parameters only.<br>
//<br>
class otl_inout_stream: public otl_out_stream{<br>
public:<br>
  <br>
// General conctructor. SQL statement is parsed, all host input and<br>
// output hostvariables are automatically allocated and bound. This<br>
// constructor allows the user to use extended place-holder<br>
// declarations:<br>
//<br>
// :NAME&lt;DATA_TYPE,ACCESS_TYPE&gt;<br>
//<br>
// The following data types are available in the extended<br>
// declarations:<br>
//<br>
// :VAR&lt;char[&lt;length&gt;]&gt;, e.g. :F1&lt;char[32]&gt;<br>
// :VAR&lt;int&gt;<br>
// :VAR&lt;short&gt;<br>
// :VAR&lt;long&gt;<br>
// :VAR&lt;unsigned&gt;<br>
// :VAR&lt;float&gt;<br>
// :VAR&lt;double&gt;<br>
// <br>
// The following access types are available in the extended<br>
// declarations:<br>
//<br>
// in -- input variable<br>
// out -- output variable<br>
// inout -- input/output variable<br>
// <br>
INLINE otl_inout_stream(<br>
short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db // connect object<br>
);<br>
  <br>
INLINE ~otl_inout_stream();<br>
  <br>
// Test if all data has been already read from the stream<br>
INLINE int eof(void);<br>
  <br>
// Flush stream's output buffer. It actually means to execute the SQL<br>
// statement as many times as rows entered to the output buffer. The<br>
// stream is automatically flushed when the buffer gets full.<br>
INLINE void flush(void); <br>
  <br>
// Clean up buffer without flushing it.<br>
INLINE void clean(void);<br>
  <br>
// Rewind stream<br>
INLINE void rewind(void);<br>
  <br>
  <br>
// Test if NULL was fetched from the stream<br>
INLINE int is_null(void);<br>
  <br>
// Read objects from stream<br>
  <br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(char&amp; c);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(unsigned char&amp; c);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(char* s);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(unsigned char* s);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(int&amp; n);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(unsigned&amp; u);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(short&amp; sh);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(long int&amp; l);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(float&amp; f);<br>
INLINE otl_inout_stream&amp; operator&gt;&gt;(double&amp; d);<br>
  <br>
protected:<br>
  <br>
// Internal stuff<br>
  <br>
otl_p_generic_variable* in_vl; // input variable list<br>
int iv_len; // input variable list length<br>
int cur_in_x; // current input array index (input X-coordinate)<br>
int cur_in_y; // current input array element index (input Y-coordinate)<br>
int in_y_len; // input variable list length<br>
int null_fetched; // "NULL fetched" flag<br>
otl_p_generic_variable* avl; // list of all variables<br>
int avl_len; // length of list of all variables<br>
  <br>
INLINE void get_in_next(void);<br>
INLINE int check_in_type(int type_code,int tsize);<br>
INLINE int is_null_intern(void);<br>
  <br>
};<br>
  <br>
// OTL stream class. This is a general-purpose stream class, unified<br>
// for streams of all types.<br>
class otl_stream{<br>
public:<br>
  <br>
// General conctructor. SQL statement is parsed, all host input and<br>
// output host variables are automatically allocated and bound. This<br>
// constructor allows the user to use extended place-holder<br>
// declarations:<br>
//<br>
// :NAME&lt;DATA_TYPE,ACCESS_TYPE&gt;<br>
//<br>
// The following data types are available in the extended<br>
// declarations:<br>
//<br>
// :VAR&lt;char[&lt;length&gt;]&gt;, e.g. :F1&lt;char[32]&gt;<br>
// :VAR&lt;int&gt;<br>
// :VAR&lt;short&gt;<br>
// :VAR&lt;long&gt;<br>
// :VAR&lt;unsigned&gt;<br>
// :VAR&lt;float&gt;<br>
// :VAR&lt;double&gt;<br>
// <br>
// The following access types are available in the extended<br>
// declarations:<br>
//<br>
// in -- input variable<br>
// out -- output variable<br>
// inout -- input/output variable<br>
//<br>
// Access types need to be defined only for PL/SQL blocks to avoid<br>
// ambiguity. <br>
INLINE otl_stream(short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db, // connect object<br>
const char* ref_cur_placeholder=0<br>
// reference cursor placeholder, e.g. ":cur"<br>
);<br>
  <br>
INLINE otl_stream();<br>
  <br>
// Desctructor<br>
INLINE ~otl_stream();<br>
  <br>
// Test if all data has been already read from the stream<br>
INLINE int eof(void);<br>
  <br>
// Flush stream's output buffer. It actually means to execute the SQL<br>
// statement as many times as rows entered to the output buffer. The<br>
// stream is automatically flushed when the buffer gets full.<br>
INLINE void flush(void); <br>
  <br>
// Clean up buffer without flushing it.<br>
INLINE void clean(void);<br>
  <br>
// Rewind stream<br>
INLINE void rewind(void);<br>
  <br>
// Test if NULL was fetched from the stream<br>
INLINE int is_null(void);<br>
  <br>
// Set "auto-commit" flag. When the buffer is flushed, current<br>
// transaction is automatically commited, if the flag is set.<br>
INLINE void set_commit(int auto_commit=0);<br>
  <br>
// Open stream<br>
INLINE void open(short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db, // connect object<br>
const char* ref_cur_placeholder=0<br>
// reference cursor placeholder, e.g. ":cur"<br>
);<br>
// Close stream<br>
INLINE void close(void);<br>
  <br>
// Test if the stream was opened okay<br>
INLINE int good(void);<br>
  <br>
// Read objects from stream<br>
  <br>
INLINE otl_stream&amp; operator&gt;&gt;(char&amp; c);<br>
INLINE otl_stream&amp; operator&gt;&gt;(unsigned char&amp; c);<br>
INLINE otl_stream&amp; operator&gt;&gt;(char* s);<br>
INLINE otl_stream&amp; operator&gt;&gt;(unsigned char* s);<br>
INLINE otl_stream&amp; operator&gt;&gt;(int&amp; n);<br>
INLINE otl_stream&amp; operator&gt;&gt;(unsigned&amp; u);<br>
INLINE otl_stream&amp; operator&gt;&gt;(short&amp; sh);<br>
INLINE otl_stream&amp; operator&gt;&gt;(long int&amp; l);<br>
INLINE otl_stream&amp; operator&gt;&gt;(float&amp; f);<br>
INLINE otl_stream&amp; operator&gt;&gt;(double&amp; d);<br>
  <br>
  <br>
// Write objects into stream<br>
  <br>
INLINE otl_stream&amp; operator&lt;&lt;(const char c);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const unsigned char c);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const char* s);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const unsigned char* s);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const int n);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const unsigned u);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const short sh);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const long int l);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const float f);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const double d);<br>
INLINE otl_stream&amp; operator&lt;&lt;(const otl_null n); // write
Oracle NULL into stream<br>
  <br>
  <br>
// C-like printf/scanf functions<br>
// The following format specifiers are supported:<br>
//<br>
// %d - int<br>
// %u - unsigned <br>
// %ld - long int<br>
// %f - float<br>
// %lf - double<br>
// %c - char<br>
// %s - string<br>
//<br>
// There is a specifier for writing NULL into stream:<br>
//<br>
// %N - NULL<br>
//<br>
// This couple of functions is intended for those who likes the C<br>
// style better than C++ streams.<br>
  <br>
INLINE void printf(const char* fmt,...);<br>
INLINE void scanf(const char* fmt,...);<br>
  <br>
protected:<br>
  <br>
otl_ref_select_stream* ref_ss; // reference (cursor) select stream<br>
otl_select_stream* ss; // ordinary select stream<br>
otl_inout_stream* io; // input/ouput stream<br>
  <br>
public:<br>
  <br>
otl_connect* adb; // pointer to connect object for use in Prosto*C<br>
  <br>
// Functions which contain actual implementation of printf/scanf.<br>
  <br>
INLINE void vprintf(char* fmt,va_list argv);<br>
INLINE void vscanf(char* fmt,va_list argv);<br>
  <br>
};<br>
  <br>
// OTL error info class. Should be used in case of manual error<br>
// handling in order to get more detailed error information<br>
  <br>
class otl_err_info: public otl_exception{<br>
  <br>
public:<br>
  <br>
// Default constructor<br>
otl_err_info(){}<br>
  <br>
// Create error info object from otl_connect object<br>
otl_err_info(otl_connect&amp; connect){init(connect.lda);}<br>
  <br>
// Create error info object from otl_cursor object<br>
otl_err_info(otl_cursor&amp; cur){init(cur.cda);}<br>
  <br>
// Read error info into existing error info descriptor<br>
void get_info(otl_connect&amp; connect){init(connect.lda);}<br>
void get_info(otl_cursor&amp; cur){init(cur.cda,cur.stm_text);}<br>
  <br>
};<br>
  <br>
// ========================= Template class section
==========================<br>
  <br>
// OTL template variable class. allows to construct specialized<br>
// template variable classes (see below)<br>
  <br>
template &lt;class T, int atype&gt;<br>
class otl_variable: public otl_generic_variable{<br>
  <br>
public:<br>
  <br>
T v; // host varibale of data type T<br>
  <br>
sb2 ind; // indicator<br>
ub2 rlen; // returned length<br>
ub2 rcode; // returned code<br>
  <br>
// Default constructor<br>
otl_variable(){init();}<br>
  <br>
// Construct variable by the name of aname, e.g. ":F1"<br>
otl_variable(const char* aname)<br>
{<br>
init();<br>
copy_name(aname);<br>
}<br>
  <br>
// Construct variable/column, with its further use in a select list in<br>
// the column_num position.<br>
otl_variable(const int column_num)<br>
{<br>
init();<br>
copy_pos(column_num);<br>
}<br>
  <br>
// Variables with either name or column_num initialized may be used in<br>
// the parse functions of OTL cursor classes, which variable lists of<br>
// parameters.<br>
  <br>
// Initialize host variable internals<br>
void init()<br>
{<br>
ind=sizeof(T)&gt;32767?0:(sb2)sizeof(T);<br>
rcode=0;<br>
ftype=atype;<br>
p_v=(ub1*)&amp;v;<br>
p_ind=&amp;ind;<br>
p_rlen=&amp;rlen;<br>
p_rcode=&amp;rcode;<br>
elem_size=sizeof(T);<br>
rlen=(ub2)elem_size;<br>
array_size=1;<br>
max_tab_len=(ub4)array_size;<br>
cur_tab_len=(ub4)array_size;<br>
}<br>
  <br>
};<br>
  <br>
// OTL template host array class. allows to construct specialized<br>
// template array classes (see below)<br>
  <br>
template &lt;class T, const int atype, const short size&gt;<br>
class otl_array: public otl_generic_variable{<br>
  <br>
public:<br>
  <br>
T v[size]; // host array<br>
  <br>
sb2 ind[size]; // indicator array<br>
ub2 rlen[size]; // returned length array<br>
ub2 rcode[size]; // returned code array<br>
  <br>
// Default constructor<br>
otl_array(){init();}<br>
  <br>
// Construct array by the name of aname, e.g. ":F1"<br>
otl_array(const char* aname)<br>
{<br>
init();<br>
copy_name(aname);<br>
}<br>
  <br>
// Construct array-column, with its further use in a select list in<br>
// the column_num position.<br>
otl_array(const int column_num)<br>
{<br>
init();<br>
copy_pos(column_num);<br>
}<br>
  <br>
// Initialize host array internals<br>
void init(void)<br>
{<br>
for(int i=0;i&lt;size;++i){<br>
ind[i]=sizeof(T);<br>
rlen[i]=sizeof(T);<br>
rcode[i]=0;<br>
}<br>
ftype=atype;<br>
p_v=(ub1*)&amp;v[0];<br>
p_ind=&amp;ind[0];<br>
p_rlen=&amp;rlen[0];<br>
p_rcode=&amp;rcode[0];<br>
elem_size=sizeof(T);<br>
array_size=size;<br>
max_tab_len=(ub4)array_size;<br>
cur_tab_len=(ub4)array_size;<br>
}<br>
  <br>
};<br>
  <br>
// OTL DATE class<br>
  <br>
typedef otl_variable&lt;otl_date_intern,(const int)extDate&gt; otl_date;<br>
  <br>
  <br>
// OTL ROWID class<br>
  <br>
typedef otl_variable&lt;otl_rowid_intern,(const int)extRowId&gt;
otl_rowid;<br>
  <br>
  <br>
// OTL VARNUM class<br>
  <br>
typedef otl_variable&lt;otl_varnum_intern,(const int)extVarNum&gt;
otl_varnum;<br>
  <br>
  <br>
// OTL NUMBER class<br>
  <br>
typedef otl_variable&lt;otl_number_intern,(const int)extNumber&gt;
otl_number;<br>
  <br>
  <br>
// OTL DATE ARRAY<br>
  <br>
template &lt;short size&gt; class otl_date_array:<br>
public otl_array&lt;otl_date_intern,(const int)extDate,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_date_array()<br>
:otl_array&lt;otl_date_intern,(const int)extDate,size&gt;(){}<br>
  <br>
otl_date_array(const char* aname)<br>
:otl_array&lt;otl_date_intern,(const int)extDate,size&gt;(aname){}<br>
  <br>
otl_date_array(const int column_num)<br>
:otl_array&lt;otl_date_intern,(const int)extDate,size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL ROWID ARRAY<br>
  <br>
template &lt;short size&gt; class otl_rowid_array:<br>
public otl_array&lt;otl_rowid_intern,(const int)extRowId,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_rowid_array()<br>
:otl_array&lt;otl_rowid_intern,(const int)extRowId,size&gt;(){}<br>
  <br>
otl_rowid_array(const char *aname)<br>
:otl_array&lt;otl_rowid_intern,(const int)extRowId,size&gt;(aname){}<br>
  <br>
otl_rowid_array(const int column_num)<br>
:otl_array&lt;otl_rowid_intern,(const
int)extRowId,size&gt;(column_num){}<br>
  <br>
}; <br>
  <br>
  <br>
// OTL VAR NUM ARRAY<br>
  <br>
template &lt;short size&gt; class otl_varnum_array:<br>
public otl_array&lt;otl_varnum_intern,(const int)extVarNum,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_varnum_array()<br>
:otl_array&lt;otl_varnum_intern,(const int)extVarNum,size&gt;(){}<br>
  <br>
otl_varnum_array(const char* aname)<br>
:otl_array&lt;otl_varnum_intern,(const int)extVarNum,size&gt;(aname){}<br>
  <br>
otl_varnum_array(const int column_num)<br>
:otl_array&lt;otl_varnum_intern,(const
int)extVarNum,size&gt;(column_num){}<br>
  <br>
  <br>
}; <br>
  <br>
  <br>
// OTL NUMBER ARRAY<br>
  <br>
template &lt;short size&gt; class otl_number_array:<br>
public otl_array&lt;otl_number_intern,(const int)extNumber,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_number_array()<br>
:otl_array&lt;otl_number_intern,(const int)extNumber,size&gt;(){}<br>
  <br>
otl_number_array(const char *aname)<br>
:otl_array&lt;otl_number_intern,(const int)extNumber,size&gt;(aname){}<br>
  <br>
otl_number_array(const int column_num)<br>
:otl_array&lt;otl_number_intern,(const
int)extNumber,size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
  <br>
// There is a little use of these data types. As recommended in the<br>
// OCI documentation, it is better to convert internal data types to<br>
// strings. These classes are defined for completeness only.<br>
  <br>
  <br>
  <br>
// ------------------- Numerical data types ------------------------- <br>
  <br>
// Numerical scalar classes<br>
  <br>
// OTL DOUBLE class<br>
  <br>
typedef otl_variable&lt;double,(const int)extFloat&gt; otl_double;<br>
  <br>
  <br>
// OTL FLOAT class<br>
  <br>
typedef otl_variable&lt;float,(const int)extFloat&gt; otl_float;<br>
  <br>
  <br>
// OTL SIGNED CHAR class<br>
  <br>
typedef otl_variable&lt;char,(const int)extInt&gt; otl_signed_char;<br>
  <br>
  <br>
// OTL SHORT INT class<br>
  <br>
typedef otl_variable&lt;short,(const int)extInt&gt; otl_short_int;<br>
  <br>
  <br>
// OTL INT class<br>
  <br>
typedef otl_variable&lt;int,(const int)extInt&gt; otl_int;<br>
  <br>
  <br>
// OTL LONG INT class<br>
  <br>
typedef otl_variable&lt;long int,(const int)extInt&gt; otl_long_int;<br>
  <br>
// OTL UNSIGNED INT class<br>
typedef otl_variable&lt;unsigned int,(const int)extInt&gt; otl_unsigned;<br>
  <br>
  <br>
// Numerical array classes<br>
  <br>
// OTL DOUBLE ARRAY<br>
  <br>
template &lt;short size&gt; class otl_double_array: <br>
public otl_array&lt;double,(const int)extFloat,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_double_array()<br>
:otl_array&lt;double,(const int)extFloat,size&gt;(){}<br>
  <br>
otl_double_array(const char* aname)<br>
:otl_array&lt;double,(const int)extFloat,size&gt;(aname){}<br>
  <br>
otl_double_array(const int column_num)<br>
:otl_array&lt;double,(const int)extFloat,size&gt;(column_num){}<br>
  <br>
}; <br>
  <br>
  <br>
// OTL FLOAT ARRAY<br>
  <br>
template &lt;short size&gt; class otl_float_array:<br>
public otl_array&lt;float,(const int)extFloat,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_float_array()<br>
:otl_array&lt;float,(const int)extFloat,size&gt;(){}<br>
  <br>
otl_float_array(const char* aname)<br>
:otl_array&lt;float,(const int)extFloat,size&gt;(aname){}<br>
  <br>
otl_float_array(const int column_num)<br>
:otl_array&lt;float,(const int)extFloat,size&gt;(column_num){}<br>
}; <br>
  <br>
// OTL SIGNED CHAR ARRAY<br>
  <br>
template &lt;short size&gt; class otl_signed_char_array:<br>
public otl_array&lt;char,(const int)extInt,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_signed_char_array()<br>
:otl_array&lt;char,(const int)extInt,size&gt;(){}<br>
  <br>
otl_signed_char_array(const char *aname)<br>
:otl_array&lt;char,(const int)extInt,size&gt;(aname){}<br>
  <br>
otl_signed_char_array(const int column_num)<br>
:otl_array&lt;char,(const int)extInt,size&gt;(column_num){}<br>
  <br>
  <br>
}; <br>
  <br>
  <br>
// OTL SHORT INT ARRAY<br>
  <br>
template &lt;short size&gt; class otl_short_int_array:<br>
public otl_array&lt;short,(const int)extInt,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_short_int_array()<br>
:otl_array&lt;short,(const int)extInt,size&gt;(){}<br>
  <br>
otl_short_int_array(const char *aname)<br>
:otl_array&lt;short,(const int)extInt,size&gt;(aname){}<br>
  <br>
otl_short_int_array(const int column_num)<br>
:otl_array&lt;short,(const int)extInt,size&gt;(column_num){}<br>
  <br>
}; <br>
  <br>
  <br>
// OTL INT ARRAY<br>
  <br>
template &lt;short size&gt; class otl_int_array:<br>
public otl_array&lt;int,(const int)extInt,size&gt;{<br>
  <br>
public:<br>
  <br>
otl_int_array()<br>
:otl_array&lt;int,(const int)extInt,size&gt;(){}<br>
  <br>
otl_int_array(const char *aname)<br>
:otl_array&lt;int,(const int)extInt,size&gt;(aname){}<br>
  <br>
otl_int_array(const int column_num)<br>
:otl_array&lt;int,(const int)extInt,size&gt;(column_num){}<br>
  <br>
}; <br>
  <br>
  <br>
// OTL LONG INT ARRAY<br>
  <br>
template &lt;short size&gt; class otl_long_int_array:<br>
public otl_array&lt;long int,(const int)extInt,size&gt;{<br>
public: otl_long_int_array() :otl_array&lt;long int,(const
int)extInt,size&gt;(){} otl_long_int_array(const char* aname)
:otl_array&lt;long int,(const int)extInt,size&gt;(aname){}
otl_long_int_array(const int column_num) :otl_array&lt;long int,(const
int)extInt,size&gt;(column_num){}
}; // OTL UNSIGNED INT ARRAY
template &lt;short size&gt; class otl_unsigned_array: public
otl_array&lt;unsigned int,(const int)extInt,size&gt;{
public: otl_unsigned_array() :otl_array&lt;unsigned int,(const
int)extInt,size&gt;(){} otl_unsigned_array(const char *aname)
:otl_array&lt;unsigned int,(const int)extInt,size&gt;(aname){}
otl_unsigned_array(const int column_num) :otl_array&lt;unsigned
int,(const int)extInt,size&gt;(column_num){}
}; // ----------------- String data types ------------------------- //
String scalar classes
// Null terminated string // (!!) most useful in C++ programs
template &lt;int str_size&gt; class otl_cstring: public
otl_variable&lt;char[str_size],(const int)extCChar&gt;{
public: otl_cstring(): otl_variable&lt;char[str_size],(const
int)extCChar&gt;(){} otl_cstring(const int column_num):
otl_variable&lt;char[str_size],(const int)extCChar&gt;(column_num){}
otl_cstring(const char* aname): otl_variable&lt;char[str_size],(const
int)extCChar&gt;(aname){}
};
// OTL VARCHAR2 class
template &lt;int str_size&gt; class otl_varchar2: public
otl_variable&lt;char[str_size],(const int)extVarChar2&gt;{
public: otl_varchar2() :otl_variable&lt;char[str_size],(const
int)extVarChar2&gt;(){} otl_varchar2(const char *aname)
:otl_variable&lt;char[str_size],(const int)extVarChar2&gt;(aname){}
otl_varchar2(const int column_num)
:otl_variable&lt;char[str_size],(const
int)extVarChar2&gt;(column_num){}
};
// OTL LONG class
template &lt;int str_size&gt; class otl_long: public
otl_variable&lt;char[str_size],(const int)extLong&gt;{
public: otl_long() :otl_variable&lt;char[str_size],(const
int)extLong&gt;(){} otl_long(const char *aname)
:otl_variable&lt;char[str_size],(const int)extLong&gt;(aname){}
otl_long(const int column_num) :otl_variable&lt;char[str_size],(const
int)extLong&gt;(column_num){}
};
// OTL VARCHAR class (see the OCI manual, chapter 3)
template &lt;int str_size&gt; class otl_varchar: public
otl_variable&lt;char[str_size],(const int)extVarChar&gt;{
public: otl_varchar() :otl_variable&lt;char[str_size],(const
int)extVarChar&gt;(){} otl_varchar(const char *aname)
:otl_variable&lt;char[str_size],(const int)extVarChar&gt;(aname){}
otl_varchar(const int column_num)
:otl_variable&lt;char[str_size],(const int)extVarChar&gt;(column_num){}
};
// OTL VARRAW class
template &lt;int str_size&gt; class otl_varraw: public
otl_variable&lt;unsigned char[str_size],(const int)extVarRaw&gt;{
public: otl_varraw() :otl_variable&lt;unsigned char[str_size],(const
int)extVarRaw&gt;(){} otl_varraw(const char *aname)
:otl_variable&lt;unsigned char[str_size],(const
int)extVarRaw&gt;(aname){} otl_varraw(const int column_num)
:otl_variable&lt;unsigned char[str_size],(const
int)extVarRaw&gt;(column_num){}
};
// OTL RAW class
template &lt;ub1 str_size&gt; class otl_raw: public
otl_variable&lt;unsigned char[str_size],(const int)extRaw&gt;{
public: otl_raw() :otl_variable&lt;unsigned char[str_size],(const
int)extRaw&gt;(){} otl_raw(const char *aname) :otl_variable&lt;unsigned
char[str_size],(const int)extRaw&gt;(aname){} otl_raw(const int
column_num) :otl_variable&lt;unsigned char[str_size],(const
int)extRaw&gt;(column_num){}
};
// OTL LONG RAW class
template &lt;int str_size&gt; class otl_long_raw: public
otl_variable&lt;unsigned char[str_size],(const int)extLongRaw&gt;{
public: otl_long_raw() :otl_variable&lt;unsigned char[str_size],(const
int)extLongRaw&gt;(){} otl_long_raw(const char *aname)
:otl_variable&lt;unsigned char[str_size],(const
int)extLongRaw&gt;(aname){} otl_long_raw(const int column_num)
:otl_variable&lt;unsigned char[str_size],(const
int)extLongRaw&gt;(column_num){}
};
// OTL CHAR class
template &lt;ub1 str_size&gt; class otl_char: public
otl_variable&lt;char[str_size],(const int)extChar&gt;{
public: otl_char() :otl_variable&lt;char[str_size],(const
int)extChar&gt;(){} otl_char(const char *aname)
:otl_variable&lt;char[str_size],(const int)extChar&gt;(aname){}<br>
  <br>
otl_char(const int column_num)<br>
:otl_variable&lt;char[str_size],(const int)extChar&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL CHARZ class<br>
  <br>
template &lt;ub1 str_size&gt; class otl_charz:<br>
public otl_variable&lt;char[str_size],(const int)extCharZ&gt;{<br>
  <br>
public:<br>
  <br>
otl_charz()<br>
:otl_variable&lt;char[str_size],(const int)extCharZ&gt;(){}<br>
  <br>
otl_charz(const char *aname)<br>
:otl_variable&lt;char[str_size],(const int)extCharZ&gt;(aname){}<br>
  <br>
otl_charz(const int column_num)<br>
:otl_variable&lt;char[str_size],(const int)extCharZ&gt;(column_num){}<br>
  <br>
  <br>
};<br>
  <br>
  <br>
// OTL LONG VARCHAR class.<br>
  <br>
// It is used for reading and writing objects of the Oracle LONG data<br>
// type. The class defines:<br>
//<br>
// - operator[] to access elements of the char buffer;<br>
// - function set_len() to set up string length on input;<br>
// - function len() to get string length on output;<br>
//<br>
template &lt;int str_size&gt; class otl_long_varchar:<br>
public otl_variable&lt;char[str_size],(const int)extLongVarChar&gt;{<br>
  <br>
public:<br>
  <br>
otl_long_varchar()<br>
: otl_variable&lt;char[str_size],(const int)extLongVarChar&gt;(),<br>
real_len(*(sb4*)&amp;v[0]),<br>
real_p_v((char*)&amp;v[0]+sizeof(sb4))<br>
{<br>
real_len=sizeof(v);<br>
}<br>
  <br>
otl_long_varchar(const char *aname)<br>
: otl_variable&lt;char[str_size],(const int)extLongVarChar&gt;(aname),<br>
real_len(*(sb4*)&amp;v[0]),<br>
real_p_v((char*)&amp;v[0]+sizeof(sb4))<br>
{<br>
real_len=sizeof(v);<br>
}<br>
  <br>
otl_long_varchar(const int column_num)<br>
: otl_variable&lt;char[str_size],(const
int)extLongVarChar&gt;(column_num),<br>
real_len(*(sb4*)&amp;v[0]),<br>
real_p_v((char*)&amp;v[0]+sizeof(sb4))<br>
{<br>
real_len=sizeof(v);<br>
}<br>
  <br>
void set_null(int ndx=0){ind=-1;}<br>
void set_len(int len, int ndx=0){real_len=len;}<br>
void set_not_null(int ndx=0){ind=0;}<br>
  <br>
void* val(int ndx=0){return real_p_v;}<br>
int len(void){return real_len;}<br>
  <br>
char&amp; operator[](int ndx){return real_p_v[ndx];}<br>
  <br>
private:<br>
  <br>
char* real_p_v;<br>
sb4&amp; real_len;<br>
  <br>
};<br>
  <br>
  <br>
// OTL LONG VARRAW class<br>
  <br>
// It is used for reading and writing objects of the Oracle LONG RAW<br>
// data type. The class defines:<br>
//<br>
// - operator[] to access elements of the char buffer;<br>
// - function set_len() to set up string length on input;<br>
// - function len() to get string length on output;<br>
//<br>
  <br>
template &lt;int str_size&gt; class otl_long_varraw:<br>
public otl_variable&lt;unsigned char[str_size],(const
int)extLongVarRaw&gt;{<br>
  <br>
public:<br>
  <br>
otl_long_varraw()<br>
: otl_variable&lt;unsigned char[str_size],(const
int)extLongVarRaw&gt;(),<br>
real_len(*(sb4*)&amp;v[0]),<br>
real_p_v((unsigned char*)&amp;v[0]+sizeof(sb4))<br>
{<br>
real_len=sizeof(v);<br>
}<br>
  <br>
otl_long_varraw(const char *aname)<br>
: otl_variable&lt;unsigned char[str_size],(const
int)extLongVarRaw&gt;(aname),<br>
real_len(*(sb4*)&amp;v[0]),<br>
real_p_v((unsigned char*)&amp;v[0]+sizeof(sb4))<br>
{<br>
real_len=sizeof(v);<br>
}<br>
  <br>
otl_long_varraw(const int column_num)<br>
: otl_variable&lt;unsigned char[str_size],(const
int)extLongVarRaw&gt;(column_num),<br>
real_len(*(sb4*)&amp;v[0]),<br>
real_p_v((unsigned char*)&amp;v[0]+sizeof(sb4))<br>
{<br>
real_len=sizeof(v);<br>
}<br>
  <br>
void set_null(int ndx=0){ind=-1;}<br>
void set_len(int len, int ndx=0){real_len=len;}<br>
void set_not_null(int ndx=0){ind=0;}<br>
  <br>
void* val(int ndx=0){return real_p_v;}<br>
int len(void){return real_len;}<br>
  <br>
unsigned char&amp; operator[](int ndx){return real_p_v[ndx];}<br>
  <br>
private:<br>
  <br>
unsigned char* real_p_v;<br>
sb4&amp; real_len;<br>
  <br>
};<br>
  <br>
  <br>
// String array classes<br>
  <br>
// Null terminated string array<br>
// (!!) most useful in C++ programs<br>
  <br>
template &lt;const short arr_size,const int str_size&gt; class
otl_cstring_array: <br>
public otl_array&lt;char[str_size],(const int)extCChar,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_cstring_array()<br>
:otl_array&lt;char[str_size],(const int)extCChar,arr_size&gt;(){}<br>
  <br>
otl_cstring_array(const char *aname)<br>
:otl_array&lt;char[str_size],(const int)extCChar,arr_size&gt;(aname){}<br>
  <br>
otl_cstring_array(const int column_num)<br>
:otl_array&lt;char[str_size],(const
int)extCChar,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
  <br>
// OTL VARCHAR2 ARRAY<br>
  <br>
template &lt;const short arr_size,const int str_size&gt; class
otl_varchar2_array: <br>
public otl_array&lt;char[str_size],(const int)extVarChar2,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_varchar2_array()<br>
:otl_array&lt;char[str_size],(const int)extVarChar2,arr_size&gt;(){}<br>
  <br>
otl_varchar2_array(const char *aname)<br>
:otl_array&lt;char[str_size],(const
int)extVarChar2,arr_size&gt;(aname){}<br>
  <br>
otl_varchar2_array(const int column_num)<br>
:otl_array&lt;char[str_size],(const
int)extVarChar2,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL LONG ARRAY<br>
  <br>
template &lt;const short arr_size,const int str_size&gt; class
otl_long_array: <br>
public otl_array&lt;char[str_size],(const int)extLong,arr_size&gt;{};<br>
  <br>
  <br>
// OTL VARCHAR ARRAY<br>
  <br>
template &lt;const short arr_size,const int str_size&gt; class
otl_varchar_array: <br>
public otl_array&lt;char[str_size],(const int)extVarChar,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_varchar_array()<br>
:otl_array&lt;char[str_size],(const int)extVarChar,arr_size&gt;(){}<br>
  <br>
otl_varchar_array(const char *aname)<br>
:otl_array&lt;char[str_size],(const int)extVarChar,arr_size&gt;(aname){}<br>
  <br>
otl_varchar_array(const int column_num)<br>
:otl_array&lt;char[str_size],(const
int)extVarChar,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL VARRAW ARRAY<br>
  <br>
template &lt;const short arr_size,const int str_size&gt; class
otl_varraw_array:<br>
public otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_varraw_array()<br>
:otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;(){}<br>
  <br>
otl_varraw_array(const char *aname)<br>
:otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;(aname){}<br>
  <br>
otl_varraw_array(const int column_num)<br>
:otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL VARRAW ARRAY<br>
  <br>
template &lt;const short arr_size,const ub1 str_size&gt; class
otl_raw_array:<br>
public otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_raw_array()<br>
:otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;(){}<br>
  <br>
otl_raw_array(const char *aname)<br>
:otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;(aname){}<br>
  <br>
otl_raw_array(const int column_num)<br>
:otl_array&lt;unsigned char[str_size],(const
int)extVarRaw,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL LONG RAW ARRAY<br>
  <br>
template &lt;const short arr_size,const int str_size&gt; class
otl_long_raw_array:<br>
public otl_array&lt;unsigned char[str_size],(const
int)extLongRaw,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_long_raw_array()<br>
:otl_array&lt;unsigned char[str_size],(const
int)extLongRaw,arr_size&gt;(){}<br>
  <br>
otl_long_raw_array(const char *aname)<br>
:otl_array&lt;unsigned char[str_size],(const
int)extLongRaw,arr_size&gt;(aname){}<br>
  <br>
otl_long_raw_array(const int column_num)<br>
:otl_array&lt;unsigned char[str_size],(const
int)extLongRaw,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL CHAR ARRAY<br>
  <br>
template &lt;const short arr_size,const ub1 str_size&gt; class
otl_char_array:<br>
public otl_array&lt;char[str_size],(const int)extChar,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_char_array()<br>
:otl_array&lt;char[str_size],(const int)extChar,arr_size&gt;(){}<br>
  <br>
otl_char_array(const char *aname)<br>
:otl_array&lt;char[str_size],(const int)extChar,arr_size&gt;(aname){}<br>
  <br>
otl_char_array(const int column_num)<br>
:otl_array&lt;char[str_size],(const
int)extChar,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
  <br>
// OTL CHARZ ARRAY<br>
  <br>
template &lt;const short arr_size,const ub1 str_size&gt; class
otl_charz_array:<br>
public otl_array&lt;char[str_size],(const int)extCharZ,arr_size&gt;{<br>
  <br>
public:<br>
  <br>
otl_charz_array()<br>
:otl_array&lt;char[str_size],(const int)extCharZ,arr_size&gt;(){}<br>
  <br>
otl_charz_array(const char *aname)<br>
:otl_array&lt;char[str_size],(const int)extCharZ,arr_size&gt;(aname){}<br>
  <br>
otl_charz_array(const int column_num)<br>
:otl_array&lt;char[str_size],(const
int)extCharZ,arr_size&gt;(column_num){}<br>
  <br>
};<br>
  <br>
// Define variable or array p with the corresponding placeholder's<br>
// name ":p", e.g:<br>
//<br>
// OTL_VAR(f1,otl_float_array&lt;100&gt;);<br>
// OTL_VAR(f,otl_int);<br>
//<br>
#define OTL_VAR(p,type) type p(":"#p); <br>
  <br>
// ================================ Prosto*C
================================<br>
  <br>
// Prosto*C is a simplified interface to SQL. It provides an<br>
// alternative method of intercepting errors. The user needs to define<br>
// an error handler function and attach it to the connect object. When<br>
// error occurs, the handler function is invoked.<br>
  <br>
// OTL Error handler function prototype:<br>
//<br>
// err_msg -- error message<br>
// err_code -- error code<br>
//<br>
typedef void (*otl_error_handler)(char*,int);<br>
  <br>
// Connect to Oracle using the "connect" string and attach the<br>
// "handler" function to the connect object. The function returns a<br>
// pointer to the corresponding connect object.<br>
INLINE otl_connect* otl_logon(char* connect,otl_error_handler
handler=0);<br>
  <br>
// "Pro*C" connect. Primary connection is done in a Pro*C module using<br>
// EXEC SQL CONNECT...; Attach the "handler" function to the connect<br>
// object. The function returns a pointer to the corresponding<br>
// connect object.<br>
INLINE otl_connect* otl_proC_logon(otl_error_handler handler=0);<br>
  <br>
// Disconnect from Oracle. "db" -- connect object. Returns 1 on<br>
// success, 0 -- on failure.<br>
INLINE int otl_logoff(otl_connect* db);<br>
  <br>
// Commit transaction. "db" -- connect object.<br>
INLINE void otl_commit(otl_connect* db);<br>
  <br>
// Roll back transaction. "db" -- connect object.<br>
INLINE void otl_rollback(otl_connect* db);<br>
  <br>
// Execute constant SQL statement:<br>
//<br>
// db -- connect object<br>
// stm -- SQL statement<br>
// ignore_error -- "ignore error" flag. If the flag is set up, then<br>
// the error handler function is not called.<br>
//<br>
// Returns 1 on success, 0 -- on failure.<br>
INLINE int otl_exec(otl_connect* db,char* stm,int ignore_error=0);<br>
  <br>
// Open OTL stream:<br>
//<br>
// db -- connect object<br>
// stm -- SQL statement <br>
// bufsize -- size of the buffer, attached to the stream<br>
//<br>
// Returns pointer to stream on success, 0 -- on failure.<br>
INLINE otl_stream* otl_stream_open(otl_connect* db, <br>
char* stm, <br>
short bufsize=1,<br>
const char* ref_cur_placeholder=0<br>
);<br>
  <br>
// Close OTL stream<br>
INLINE void otl_stream_close(otl_stream* f);<br>
  <br>
// Check out the "EOF" condition on the "f" stream<br>
INLINE int otl_eof(otl_stream* f);<br>
  <br>
// Check out if Oracle NULL has been fetched from the stream<br>
INLINE int otl_is_null(otl_stream* f);<br>
  <br>
// Set "auto-commit" flag. When the buffer is flushed, current<br>
// transaction is automatically commited, if the flag is set.<br>
INLINE void otl_set_commit(otl_stream* f,int auto_commit=1);<br>
  <br>
// Flush stream buffer. SQL statement is executed as many times as the<br>
// rows have been entered into the stream buffer.<br>
INLINE void otl_flush(otl_stream* f);<br>
  <br>
// C-like printf/scanf functions<br>
// The following format specifiers are supported:<br>
//<br>
// %d - int<br>
// %u - unsigned <br>
// %ld - long int<br>
// %f - float<br>
// %lf - double<br>
// %c - char<br>
// %s - string<br>
//<br>
// There is a specifier for writing NULL into stream:<br>
//<br>
// %N - NULL<br>
//<br>
// This couple of functions is intended for those who likes the C<br>
// style better than C++ streams.<br>
INLINE void otl_printf(otl_stream* f,const char* fmt,...);<br>
INLINE void otl_scanf(otl_stream* f,const char* fmt,...);<br>
  <br>
  <br>
// ======================= Function bodies section
===========================<br>
  <br>
  <br>
INLINE void otl_exception::init(Lda_Def&amp; lda,const char* sqlstm)<br>
// get error code and message<br>
{<br>
int len;<br>
stm_text=0;<br>
code=lda.rc;<br>
oerhms(&amp;lda,lda.rc,msg,sizeof(msg));<br>
len = strlen((const char*)msg);<br>
msg[len-1]=0;<br>
if(sqlstm){<br>
len = strlen(sqlstm)+1;<br>
stm_text = new unsigned char[len]; <br>
strcpy((char*)stm_text,sqlstm);<br>
}<br>
}<br>
  <br>
INLINE otl_object::otl_object()<br>
{<br>
connected=0; <br>
ex_enabled=otl_exception::enabled; <br>
}<br>
  <br>
INLINE otl_connect::otl_connect(int exception_enabled)<br>
:rc(lda.rc)<br>
{<br>
ex_enabled=exception_enabled;<br>
proc_connect=0;<br>
handler=0;<br>
memset(&amp;lda,0,sizeof(lda));<br>
}<br>
  <br>
INLINE otl_connect::otl_connect(<br>
const char* connect_str, <br>
int exception_enabled<br>
) : rc(lda.rc)<br>
{<br>
ex_enabled=exception_enabled;<br>
proc_connect=0;<br>
handler=0;<br>
memset(&amp;lda,0,sizeof(lda));<br>
rlogon(connect_str);<br>
}<br>
  <br>
INLINE otl_connect::~otl_connect()<br>
{<br>
logoff();<br>
}<br>
  <br>
INLINE int otl_connect::test_blocking(void)<br>
{<br>
if(!connected)return 0;<br>
int r=onbtst(&amp;lda);<br>
if(rc==otl_blocking)return otl_blocking;<br>
if(rc==0)return otl_nonblocking;<br>
if(rc!=0 &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return 0;<br>
}<br>
  <br>
INLINE int otl_connect::set_nonblocking(void)<br>
{<br>
if(!connected)return 0;<br>
int r=onbset(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return 1;<br>
}<br>
  <br>
  <br>
INLINE int otl_connect::clear_nonblocking(void)<br>
{<br>
if(!connected)return 0;<br>
int r=onbclr(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return 1;<br>
}<br>
  <br>
INLINE int otl_connect::rlogon(<br>
const char* connect_str<br>
)<br>
{// according to the OCI manual, HDA needs to be initialized<br>
memset(hda,0,sizeof(hda)); <br>
connected=!olog(&amp;lda, <br>
hda,<br>
(unsigned char*)connect_str, <br>
-1, <br>
0, <br>
-1,<br>
0,<br>
-1,<br>
0 // default, blocking connection mode<br>
);<br>
if(!connected &amp;&amp; ex_enabled) throw otl_exception(lda);// raise
exception<br>
return connected;<br>
}<br>
  <br>
INLINE int otl_connect::sqllda()<br>
{<br>
::sqllda(&amp;lda);<br>
connected=!rc;<br>
if(!connected &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
proc_connect=1;<br>
return connected;<br>
}<br>
  <br>
INLINE int otl_connect::sqlld2(const char* dbname)<br>
{sb4 clen=-1;<br>
::sqlld2(&amp;lda,(unsigned char*)dbname,&amp;clen);<br>
connected=!rc;<br>
if(!connected &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
proc_connect=1;<br>
return connected;<br>
}<br>
  <br>
INLINE int otl_connect::logon(const char* connect_str)<br>
{<br>
connected=!olon(<br>
&amp;lda, <br>
(unsigned char*)connect_str, <br>
-1, <br>
0, <br>
-1, <br>
0<br>
);<br>
if(!connected &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return connected;<br>
}<br>
  <br>
INLINE int otl_connect::logoff() <br>
{<br>
if(!connected||proc_connect)return 0;<br>
int r=ologof(&amp;lda);<br>
connected=0;<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return !rc;<br>
}<br>
  <br>
INLINE int otl_connect::commit() <br>
{<br>
if(!connected)return 0;<br>
int r=ocom(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return !rc;<br>
}<br>
  <br>
INLINE int otl_connect::rollback() <br>
{<br>
if(!connected)return 0;<br>
int r=orol(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return !rc;<br>
}<br>
  <br>
INLINE int otl_connect::obreak() <br>
{<br>
if(!connected)return 0;<br>
int r=::obreak(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return !rc;<br>
}<br>
  <br>
INLINE int otl_connect::auto_commit_on() <br>
{<br>
if(!connected)return 0;<br>
int r=ocon(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return !rc;<br>
}<br>
  <br>
INLINE int otl_connect::auto_commit_off() <br>
{<br>
if(!connected)return 0;<br>
int r=ocof(&amp;lda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(lda);<br>
return !rc;<br>
}<br>
  <br>
INLINE int otl_connect::thread_safe_init(void)<br>
{<br>
int r=opinit(1); // Set up thread safe environment.<br>
return !r;<br>
}<br>
  <br>
INLINE otl_generic_variable::otl_generic_variable()<br>
{<br>
name=0;<br>
pos=0;<br>
max_tab_len=0;<br>
cur_tab_len=0;<br>
}<br>
  <br>
INLINE otl_generic_variable::~otl_generic_variable()<br>
{<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(001)- = "&lt;&lt;(int*)name&lt;&lt;endl;<br>
#endif<br>
  <br>
delete name;<br>
}<br>
  <br>
INLINE void otl_generic_variable::copy_name(const char* aname)<br>
{<br>
pos=0;<br>
if(name==aname)return;<br>
if(name){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(002)- = "&lt;&lt;(int*)name&lt;&lt;endl;<br>
#endif<br>
delete name;<br>
}<br>
  <br>
name=new char[strlen(aname)+1];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(069)+ = "&lt;&lt;(int*)name&lt;&lt;endl;<br>
#endif<br>
  <br>
strcpy(name,aname);<br>
}<br>
  <br>
INLINE void otl_generic_variable::copy_pos(const int apos)<br>
{<br>
if(name){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(003)- = "&lt;&lt;(int*)name&lt;&lt;endl;<br>
#endif<br>
  <br>
delete name;<br>
name=0;<br>
}<br>
pos=apos;<br>
}<br>
  <br>
INLINE void otl_generic_variable::set_null(int ndx)<br>
{<br>
p_ind[ndx]=-1;<br>
}<br>
  <br>
INLINE void otl_generic_variable::set_len(int len, int ndx)<br>
{<br>
p_rlen[ndx]=(short)len;<br>
}<br>
  <br>
INLINE void otl_generic_variable::set_not_null(int ndx)<br>
{<br>
p_ind[ndx]=(short)elem_size;<br>
}<br>
  <br>
INLINE int otl_generic_variable::is_null(int ndx)<br>
{<br>
return p_ind[ndx]==-1;<br>
}<br>
  <br>
INLINE int otl_generic_variable::is_success(int ndx)<br>
{<br>
return p_ind[ndx]==0;<br>
}<br>
  <br>
INLINE int otl_generic_variable::is_truncated(int ndx)<br>
{<br>
return p_ind[ndx]==-2||p_ind[ndx]&gt;0;<br>
}<br>
  <br>
INLINE void* otl_generic_variable::val(int ndx)<br>
{<br>
return (void*)&amp;p_v[((unsigned)ndx)*elem_size];<br>
}<br>
  <br>
INLINE int otl_generic_variable::is_invalid_conversion(int ndx)<br>
{<br>
return p_rcode[ndx]==1454;<br>
}<br>
  <br>
INLINE int otl_generic_variable::is_real_overflow(int ndx)<br>
{<br>
return p_rcode[ndx]==1456;<br>
}<br>
  <br>
INLINE int otl_generic_variable::is_unsupported_datatype(int ndx)<br>
{<br>
return p_rcode[ndx]==3115;<br>
}<br>
  <br>
INLINE void otl_generic_variable::set_tab_len(int new_len)<br>
{<br>
max_tab_len=(ub4)array_size;<br>
cur_tab_len=(ub4)new_len;<br>
}<br>
  <br>
INLINE int otl_generic_variable::get_tab_len(void)<br>
{<br>
return (int)cur_tab_len;<br>
}<br>
  <br>
INLINE otl_dynamic_variable::otl_dynamic_variable(<br>
const int column_num,<br>
const Aftype,<br>
const Aelem_size,<br>
const short Aarray_size<br>
)<br>
{<br>
copy_pos(column_num);<br>
init(Aftype,Aelem_size,Aarray_size);<br>
}<br>
  <br>
INLINE otl_dynamic_variable::otl_dynamic_variable(<br>
const char *aname,<br>
const Aftype,<br>
const Aelem_size,<br>
const short Aarray_size<br>
)<br>
{<br>
copy_name(aname);<br>
init(Aftype,Aelem_size,Aarray_size);<br>
}<br>
  <br>
INLINE otl_dynamic_variable::otl_dynamic_variable()<br>
{<br>
p_v=0;<br>
p_ind=0;<br>
p_rlen=0;<br>
p_rcode=0;<br>
}<br>
  <br>
INLINE otl_dynamic_variable::~otl_dynamic_variable()<br>
{<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(070)- = "&lt;&lt;(int*)p_v&lt;&lt;endl;<br>
#endif<br>
delete p_v;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(071)- = "&lt;&lt;(int*)p_ind&lt;&lt;endl;<br>
#endif<br>
delete p_ind;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(072)- = "&lt;&lt;(int*)p_rlen&lt;&lt;endl;<br>
#endif<br>
delete p_rlen;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(073)- = "&lt;&lt;(int*)p_rcode&lt;&lt;endl;<br>
#endif<br>
delete p_rcode;<br>
}<br>
  <br>
INLINE void otl_dynamic_variable::init(<br>
const int Aftype,<br>
const int Aelem_size,<br>
const short Aarray_size<br>
)<br>
{<br>
int i;<br>
  <br>
ftype=Aftype;<br>
elem_size=Aelem_size;<br>
array_size=Aarray_size;<br>
p_v=new ub1[elem_size*(unsigned)array_size];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(074)+ = "&lt;&lt;(int*)p_v&lt;&lt;endl;<br>
#endif<br>
p_ind=new sb2[array_size];<br>
p_rlen=new ub2[array_size];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(075)+ = "&lt;&lt;(int*)p_rlen&lt;&lt;endl;<br>
#endif<br>
p_rcode=new ub2[array_size];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(076)+ = "&lt;&lt;(int*)p_rcode&lt;&lt;endl;<br>
#endif<br>
  <br>
max_tab_len=(ub4)array_size;<br>
cur_tab_len=(ub4)array_size;<br>
  <br>
memset(p_v,0,elem_size*(unsigned)array_size);<br>
for(i=0;i&lt;array_size;++i){<br>
p_ind[i]=(short)elem_size;<br>
p_rlen[i]=(short)elem_size;<br>
p_rcode[i]=0;<br>
}<br>
  <br>
}<br>
  <br>
INLINE int otl_dynamic_variable::get_ftype(void)<br>
{<br>
return ftype;<br>
}<br>
  <br>
INLINE int otl_dynamic_variable::get_elem_size(void)<br>
{<br>
return elem_size;<br>
}<br>
  <br>
  <br>
INLINE otl_cursor::otl_cursor(int exception_enabled)<br>
: rpc(cda.rpc), ft(cda.ft), rc(cda.rc), peo(cda.peo)<br>
{<br>
ex_enabled=exception_enabled;<br>
vl=0;<br>
vl_len=0;<br>
adb=0;<br>
stm_text=0;<br>
memset(&amp;cda,0,sizeof(cda));<br>
}<br>
  <br>
INLINE otl_cursor::otl_cursor(<br>
otl_connect&amp; connect,<br>
int exception_enabled<br>
) : rpc(cda.rpc), ft(cda.ft), rc(cda.rc), peo(cda.peo)<br>
{<br>
vl=0;<br>
vl_len=0;<br>
adb=&amp;connect;<br>
stm_text=0;<br>
ex_enabled=exception_enabled;<br>
open(connect);<br>
}<br>
  <br>
INLINE otl_cursor::~otl_cursor()<br>
{<br>
close();<br>
delete[] stm_text;<br>
stm_text=0;<br>
} <br>
  <br>
INLINE void otl_cursor::alloc_var(otl_p_generic_variable* vp)<br>
{<br>
otl_p_generic_variable tmp_vl[otl_var_list_size];<br>
while(*vp){<br>
++vl_len;<br>
tmp_vl[vl_len-1]=*vp;<br>
++vp;<br>
}<br>
if(vl_len&gt;0){<br>
vl=new otl_p_generic_variable[vl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(078)+ = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int i=0;i&lt;vl_len;++i)<br>
vl[i]=tmp_vl[i];<br>
}<br>
}<br>
  <br>
INLINE int otl_cursor::open(otl_connect&amp; connect)<br>
{<br>
adb=&amp;connect;<br>
if(rc!=otl_blocked)memset(&amp;cda,0,sizeof(cda));<br>
connected=!oopen(&amp;cda,&amp;connect.lda,0,-1,-1,0,-1);<br>
if(!connected &amp;&amp; ex_enabled) throw
otl_exception(connect.lda,stm_text);<br>
return connected;<br>
}<br>
  <br>
INLINE int otl_cursor::close(void)<br>
{<br>
if(!connected)return 0;<br>
if(adb){<br>
if(!adb-&gt;connected){<br>
connected=0;<br>
adb=0;<br>
return 0;<br>
}<br>
}<br>
int r=oclose(&amp;cda);<br>
connected=0;<br>
adb=0;<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::cancel(void)<br>
{<br>
if(!connected)return 0;<br>
int r=ocan(&amp;cda);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::option(int rbopt, int waitopt)<br>
{<br>
if(!connected)return 0;<br>
int r=oopt(&amp;cda,rbopt,waitopt);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::fetch_long(<br>
int column_num, // column number: 1,2,...<br>
void* buf, // pointer to buffer<br>
sb4 bufl, // buffer size<br>
int dtype, // buffer data type, see ext* "enum"<br>
ub4* retl, // returned length<br>
sb4 offset // offset<br>
)<br>
{<br>
if(!connected)return 0;<br>
int r=oflng(&amp;cda,column_num,(ub1*)buf,bufl,dtype,retl,offset);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::parse(const char* sqlstm)<br>
{<br>
if(!connected)return 0;<br>
if(stm_text){<br>
delete[] stm_text;<br>
stm_text=0;<br>
}<br>
stm_text = new char[strlen(sqlstm) + 1];<br>
strcpy(stm_text, sqlstm);<br>
return(parse());<br>
}<br>
  <br>
INLINE int otl_cursor::parse(void)<br>
{<br>
int r=oparse(&amp;cda,(unsigned char*)stm_text,-1,0,0);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::parse(const char* sqlstm, <br>
otl_generic_variable** v<br>
)<br>
{<br>
if(!connected)return 0;<br>
if(stm_text){<br>
delete[] stm_text;<br>
stm_text=0;<br>
}<br>
stm_text = new char[strlen(sqlstm) + 1];<br>
strcpy(stm_text, sqlstm);<br>
if(!parse())return 0;<br>
otl_generic_variable** vp=v;<br>
int pos=0;<br>
while(*vp){<br>
otl_generic_variable* v=*vp;<br>
if(v-&gt;name){<br>
if(!bind(*v))return 0;<br>
}else{<br>
++pos;<br>
if(!v-&gt;pos)v-&gt;pos=pos;<br>
if(!bind(*v))return 0;<br>
}<br>
++vp;<br>
}<br>
return 1;<br>
}<br>
  <br>
INLINE int otl_cursor::eparse(const char* sqlstm,...)<br>
{<br>
va_list argv;<br>
va_start(argv,sqlstm);<br>
if(!connected)return 0;<br>
if(stm_text){<br>
delete[] stm_text;<br>
stm_text=0;<br>
}<br>
stm_text = new char[strlen(sqlstm) + 1];<br>
strcpy(stm_text, sqlstm);<br>
if(!parse())return 0;<br>
int pos=0;<br>
otl_generic_variable* v;<br>
do{<br>
v=(otl_generic_variable*)va_arg(argv,otl_generic_variable*);<br>
if(v){<br>
if(v-&gt;name){<br>
if(!bind(*v))return 0;<br>
}else{<br>
++pos;<br>
if(!v-&gt;pos)v-&gt;pos=pos;<br>
if(!bind(*v))return 0;<br>
}<br>
}<br>
}while(v);<br>
return 1;<br>
}<br>
  <br>
INLINE int otl_cursor::eexec(const char* sqlstm,short iters,...)<br>
{<br>
va_list argv;<br>
va_start(argv,iters);<br>
if(!connected)return 0;<br>
if(stm_text){<br>
delete[] stm_text;<br>
stm_text=0;<br>
}<br>
stm_text = new char[strlen(sqlstm) + 1];<br>
strcpy(stm_text, sqlstm);<br>
if(!parse())return 0;<br>
int pos=0;<br>
otl_generic_variable* v;<br>
do{<br>
v=(otl_generic_variable*)va_arg(argv,otl_generic_variable*);<br>
if(v){<br>
if(v-&gt;name){<br>
if(!bind(*v))return 0;<br>
}else{<br>
++pos;<br>
if(!v-&gt;pos)v-&gt;pos=pos;<br>
if(!bind(*v))return 0;<br>
}<br>
}<br>
}while(v);<br>
return exec(iters);<br>
}<br>
  <br>
INLINE int otl_cursor::exec(short iters)<br>
{<br>
if(!connected)return 0;<br>
int r=oexn(&amp;cda,iters,0);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::fetch(short iters)<br>
{<br>
if(!connected)return 0;<br>
int r=ofen(&amp;cda,iters);<br>
if(r &amp;&amp; ex_enabled &amp;&amp; rc!=1403) throw
otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::exfet(short iters)<br>
{<br>
if(!connected)return 0;<br>
int r=oexfet(&amp;cda,iters,0,0);<br>
if(r &amp;&amp; ex_enabled &amp;&amp; rc!=1403) throw
otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::bind(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
otl_generic_variable&amp; v // reference to host variable/array<br>
)<br>
{<br>
if(!connected)return 0;<br>
if(rc!=otl_blocked)v.copy_name(name);<br>
int r=obndrv(&amp;cda,<br>
(unsigned char*) name,<br>
-1,<br>
(ub1*)v.p_v,<br>
v.elem_size,<br>
v.ftype,<br>
-1,<br>
v.p_ind,<br>
0,<br>
-1,<br>
-1<br>
);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::bind_tab(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
otl_generic_variable&amp; v // reference to host variable/array<br>
)<br>
{<br>
if(!connected)return 0;<br>
if(rc!=otl_blocked)v.copy_name(name);<br>
int r=obndra(&amp;cda,<br>
(unsigned char*)name,<br>
-1,<br>
(ub1*)v.p_v,<br>
v.elem_size,<br>
v.ftype,<br>
-1,<br>
v.p_ind,<br>
v.p_rlen,<br>
v.p_rcode,<br>
v.max_tab_len,<br>
&amp;v.cur_tab_len,<br>
0,<br>
-1,<br>
-1<br>
);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::bind(<br>
const char* name, // placeholder name: ":f1", ":f2"<br>
void* buf, // pointer to host variable/array<br>
int elem_size, //array element/ variable size in bytes<br>
int ftype, // Oracle external data type code<br>
sb2* indp // pointer to indicator variable/array <br>
)<br>
{<br>
if(!connected)return 0;<br>
int r=obndrv(&amp;cda,<br>
(unsigned char*) name,<br>
-1,<br>
(ub1*)buf,<br>
elem_size,<br>
ftype,<br>
-1,<br>
indp,<br>
0,<br>
-1,<br>
-1<br>
);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::bind(otl_generic_variable&amp; v)<br>
{<br>
if(v.name)return bind(v.name,v);<br>
if(v.pos)return bind(v.pos,v);<br>
return 0;<br>
}<br>
  <br>
INLINE int otl_cursor::bind_tab(otl_generic_variable&amp; v)<br>
{<br>
if(v.name)return bind_tab(v.name,v);<br>
return 0;<br>
}<br>
  <br>
INLINE int otl_cursor::bind(<br>
int column_num, // column number: 1,2,...<br>
otl_generic_variable&amp; v // reference to variable/array<br>
)<br>
{<br>
if(!connected)return 0;<br>
if(rc!=otl_blocked)v.copy_pos(column_num);<br>
int r=odefin(&amp;cda,<br>
column_num,<br>
(ub1*)v.p_v,<br>
v.elem_size,<br>
v.ftype,<br>
-1,<br>
v.p_ind,<br>
0,<br>
-1,<br>
-1,<br>
v.p_rlen,<br>
v.p_rcode<br>
);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::bind(<br>
int column_num, // column number: 1,2,...<br>
void* buf, // pointer to host variable/array<br>
int elem_size, // array element/variable size in bytes<br>
int ftype, // Oracle external data type code<br>
sb2* indp, // pointer to indicator array/varibale<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array variable<br>
)<br>
{<br>
if(!connected)return 0;<br>
int r=odefin(&amp;cda,<br>
column_num,<br>
(ub1*)buf,<br>
elem_size,<br>
ftype,<br>
-1,<br>
indp,<br>
0,<br>
-1,<br>
-1,<br>
rlen,<br>
rcode<br>
);<br>
if(r &amp;&amp; ex_enabled) throw otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::bind_cstring(<br>
int column_num, // column number: 1,2,...<br>
char* buf, // pointer to C-string variable/array<br>
int elem_size, // array element/variable size<br>
sb2* indp, // pointer to indicator array/variable<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array/variable<br>
)<br>
{<br>
return bind(column_num,<br>
buf,<br>
elem_size,<br>
extCChar,<br>
indp,<br>
rlen,<br>
rcode<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_int(<br>
int column_num, // column number: 1,2,...<br>
int* buf, // pointer to int variable/array<br>
sb2* indp, // pointer to indicator array/variable<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array/variable<br>
)<br>
{<br>
return bind(column_num,<br>
buf,<br>
sizeof(int),<br>
extInt,<br>
indp,<br>
rlen,<br>
rcode<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_short(<br>
int column_num,// column number: 1,2,...<br>
short* buf, // pointer to short int variable/array<br>
sb2* indp, // pointer to indicator array/variable<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array/variable<br>
)<br>
{<br>
return bind(column_num,<br>
buf,<br>
sizeof(short),<br>
extInt,<br>
indp,<br>
rlen,<br>
rcode<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_long_int(<br>
int column_num, // column number: 1,2,...<br>
long* buf, // pointer to long int variable/array<br>
sb2* indp, // pointer to indicator array/variable<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array/variable<br>
)<br>
{<br>
return bind(column_num,<br>
buf,<br>
sizeof(long),<br>
extInt,<br>
indp,<br>
rlen,<br>
rcode<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_float(<br>
int column_num,// column number: 1,2,...<br>
float* buf, // pointer to float variable/array<br>
sb2* indp, // pointer to indicator array/variable<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array/variable<br>
)<br>
{<br>
return bind(column_num,<br>
buf,<br>
sizeof(float),<br>
extFloat,<br>
indp,<br>
rlen,<br>
rcode<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_double(<br>
int column_num,// column number: 1,2,...<br>
double* buf, // pointer to double variable/array<br>
sb2* indp, // pointer to indicator array/variable<br>
ub2* rlen, // pointer to returned length array/variable<br>
ub2* rcode // pointer to returned code array/variable<br>
)<br>
{<br>
return bind(column_num,<br>
buf,<br>
sizeof(double),<br>
extFloat,<br>
indp,<br>
rlen,<br>
rcode<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_cstring(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
char* buf, // pointer to C-string variable/array<br>
int elem_size, // array element/variable size<br>
sb2* indp // pointer to indicator array/variable<br>
)<br>
{<br>
return bind(name,<br>
buf,<br>
elem_size,<br>
extCChar,<br>
indp<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_int(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
int* buf, // pointer to int variable/array<br>
sb2* indp // pointer to indicator array/variable<br>
)<br>
{<br>
return bind(name,<br>
buf,<br>
sizeof(int),<br>
extInt,<br>
indp<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_short(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
short* buf, // pointer to short int variable/array<br>
sb2* indp // pointer to indicator array/variable<br>
)<br>
{<br>
return bind(name,<br>
buf,<br>
sizeof(short),<br>
extInt,<br>
indp<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_long_int(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
long* buf, // pointer to long int variable/array<br>
sb2* indp // pointer to indicator array/variable<br>
)<br>
{<br>
return bind(name,<br>
buf,<br>
sizeof(long),<br>
extInt,<br>
indp<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::bind_float(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
float* buf, // pointer to float variable/array<br>
sb2* indp // pointer to indicator array/variable<br>
)<br>
{<br>
return bind(name,<br>
buf,<br>
sizeof(float),<br>
extFloat,<br>
indp<br>
);<br>
}<br>
  <br>
  <br>
INLINE int otl_cursor::bind_double(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
double* buf, // pointer to double variable/array<br>
sb2* indp // pointer to indicator array/variable<br>
)<br>
{<br>
return bind(name,<br>
buf,<br>
sizeof(double),<br>
extFloat,<br>
indp<br>
);<br>
}<br>
  <br>
INLINE int otl_cursor::direct_exec(<br>
otl_connect&amp; db, // connect object<br>
const char* stm, // statement<br>
int exception_enabled // exception_enabled flag<br>
)<br>
{<br>
otl_cursor cur(db,otl_exception::disabled);<br>
int r=cur.parse(stm);<br>
if(cur.rc&amp;&amp;exception_enabled)<br>
throw otl_exception(cur.cda,stm);<br>
if(cur.rc&amp;&amp;!exception_enabled)return 0;<br>
r=cur.exec();<br>
if(cur.rc&amp;&amp;exception_enabled)throw otl_exception(cur.cda,stm);<br>
return r;<br>
}<br>
  <br>
INLINE int otl_cursor::describe_column(<br>
otl_column_desc&amp; col_desc, // column descriptor structure<br>
int column_num // column number: 1,2,...<br>
)<br>
{<br>
if(!connected)return 0;<br>
col_desc.nlen=sizeof(col_desc.name);<br>
int r=odescr(&amp;cda,<br>
column_num,<br>
&amp;col_desc.dbsize,<br>
&amp;col_desc.dbtype,<br>
&amp;col_desc.name[0],<br>
&amp;col_desc.nlen,<br>
&amp;col_desc.dsize,<br>
&amp;col_desc.prec,<br>
&amp;col_desc.scale,<br>
&amp;col_desc.nullok<br>
);<br>
if(rc==0) col_desc.name[col_desc.nlen]='\0';<br>
if(r &amp;&amp; !end_of_desc() &amp;&amp; ex_enabled) throw
otl_exception(cda,stm_text);<br>
return !r;<br>
}<br>
  <br>
INLINE int otl_cursor::eof(void)<br>
{<br>
return rc==1403;<br>
}<br>
  <br>
INLINE int otl_cursor::end_of_desc(void)<br>
{<br>
return rc==1007;<br>
}<br>
  <br>
  <br>
  <br>
// ================ Internal otl_ext_hv_decl class
======================<br>
  <br>
class otl_ext_hv_decl{<br>
public:<br>
  <br>
enum var_status{<br>
in=0,<br>
out=1,<br>
io=2,<br>
def=3<br>
};<br>
  <br>
INLINE otl_ext_hv_decl(char* stm,short arr_size=1);<br>
INLINE ~otl_ext_hv_decl();<br>
  <br>
INLINE char* operator[](int ndx){return hv[ndx];}<br>
INLINE short v_status(int ndx){return inout[ndx];}<br>
INLINE int is_id(char c);<br>
INLINE int name_comp(char* n1,char* n2);<br>
INLINE void add_var(int &amp;n,char* v,short in_out);<br>
  <br>
INLINE void alloc_host_var_list(<br>
otl_p_generic_variable* &amp;vl,<br>
int&amp; vl_len,<br>
const int status=def<br>
);<br>
  <br>
INLINE otl_generic_variable* alloc_var(char* s, const int vstat, const
int status);<br>
  <br>
char* hv[otl_var_list_size];<br>
short inout[otl_var_list_size];<br>
short array_size;<br>
short vst[4];<br>
short len;<br>
};<br>
  <br>
INLINE int otl_ext_hv_decl::is_id(char c)<br>
{<br>
return isalnum(c)||c=='_';<br>
}<br>
  <br>
INLINE int otl_ext_hv_decl::name_comp(char* n1,char* n2)<br>
{<br>
while(*n1!=' '&amp;&amp;*n1!='\0'&amp;&amp;*n2!=' '&amp;&amp;*n2!='\0'){<br>
if(toupper(*n1)!=toupper(*n2))return 0;<br>
++n1;<br>
++n2;<br>
}<br>
if(*n1==' '&amp;&amp;*n2!=' '||*n2==' '&amp;&amp;*n1!=' ')<br>
return 0;<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_ext_hv_decl::add_var(int &amp;n,char* v,short in_out)<br>
{<br>
for(int i=0;i&lt;n;++i)<br>
if(name_comp(hv[i],v))<br>
return;<br>
hv[n]=new char[strlen(v)+1];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(078)+ = "&lt;&lt;(int*)hv[n]&lt;&lt;endl;<br>
#endif<br>
strcpy(hv[n],v);<br>
inout[n]=in_out;<br>
hv[++n]=0;<br>
inout[n]=def;<br>
}<br>
  <br>
INLINE otl_ext_hv_decl::otl_ext_hv_decl(char* stm, short arr_size)<br>
{<br>
array_size=arr_size;<br>
  <br>
int i=0; <br>
short in_str=0;<br>
char *c=stm;<br>
  <br>
hv[i]=0;<br>
while(*c){<br>
if(*c=='\''){<br>
if(!in_str)<br>
in_str=1;<br>
else{<br>
if(c[1]=='\'')<br>
++c;<br>
else<br>
in_str=0; <br>
}<br>
}<br>
if(*c==':'&amp;&amp;!in_str){<br>
short in_out=def;<br>
char var[64];<br>
char* v=var;<br>
*v++=*c++;<br>
while(is_id(*c))<br>
*v++=*c++;<br>
while(isspace(*c)&amp;&amp;*c)<br>
++c;<br>
if(*c=='&lt;'){<br>
*c=' ';<br>
while(*c!='&gt;'&amp;&amp;*c!=','&amp;&amp;*c){<br>
*v++=*c;<br>
*c++=' ';<br>
}<br>
if(*c==','){<br>
*c++=' ';<br>
if(toupper(*c)=='I'){<br>
if(toupper(c[2])=='O')<br>
in_out=io;<br>
else<br>
in_out=in;<br>
}else if(toupper(*c)=='O')<br>
in_out=out;<br>
while(*c!='&gt;'&amp;&amp;*c)<br>
*c++=' ';<br>
}<br>
*c=' ';<br>
*v='\0';<br>
add_var(i,var,in_out);<br>
}<br>
}<br>
++c;<br>
}<br>
  <br>
for(int j=0;j&lt;4;++j)vst[j]=0;<br>
i=0;<br>
while(hv[i]){<br>
switch(inout[i]){<br>
case in:<br>
++vst[0];<br>
break;<br>
case out:<br>
++vst[1];<br>
break;<br>
case io:<br>
++vst[2];<br>
break;<br>
case def:<br>
++vst[3];<br>
break;<br>
}<br>
++i;<br>
}<br>
len=(short)i;<br>
}<br>
  <br>
INLINE otl_ext_hv_decl::~otl_ext_hv_decl()<br>
{<br>
for(int i=0;hv[i]!=0;++i){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(008)- = "&lt;&lt;(int*)hv[i]&lt;&lt;endl;<br>
#endif<br>
  <br>
delete hv[i];<br>
}<br>
}<br>
  <br>
INLINE void otl_ext_hv_decl::alloc_host_var_list(<br>
otl_p_generic_variable* &amp;vl,<br>
int&amp; vl_len,<br>
const int status<br>
)<br>
{<br>
vl_len=0;<br>
if(!hv[0]){<br>
vl=0;<br>
return;<br>
}<br>
otl_p_generic_variable tmp_vl[otl_var_list_size];<br>
int i=0;<br>
while(hv[i]){<br>
otl_p_generic_variable vp=alloc_var(hv[i],inout[i],status);<br>
if(vp){<br>
++vl_len;<br>
tmp_vl[vl_len-1]=vp;<br>
}<br>
++i;<br>
}<br>
if(vl_len&gt;0){<br>
vl=new otl_p_generic_variable[vl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(079)+ = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int j=0;j&lt;vl_len;++j)<br>
vl[j]=tmp_vl[j];<br>
}<br>
}<br>
  <br>
extern "C" int atoi(const char*);<br>
  <br>
INLINE otl_generic_variable* otl_ext_hv_decl::alloc_var(<br>
char* s, <br>
const int vstat,<br>
const int status<br>
)<br>
{<br>
char name[64];<br>
char type;<br>
sword size=0;<br>
  <br>
char *c=name,*c1=s;<br>
while(*c1!=' '&amp;&amp;*c1)<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' '&amp;&amp;*c1)<br>
++c1;<br>
type=(char)toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='['&amp;&amp;*c1)<br>
++c1;<br>
++c1;<br>
while(*c1!=']'&amp;&amp;*c1)<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
if(status==in &amp;&amp; (vstat==in||vstat==io))<br>
;<br>
else if(status==out &amp;&amp; (vstat==out||vstat==io||vstat==def))<br>
;<br>
else if(status==def)<br>
;<br>
else<br>
return 0;<br>
  <br>
otl_dynamic_variable* v=new otl_dynamic_variable;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(080)+ = "&lt;&lt;(int*)v&lt;&lt;endl;<br>
#endif<br>
  <br>
v-&gt;copy_name(name);<br>
switch(type){<br>
case 'C':<br>
v-&gt;init(extCChar,size,array_size);<br>
break;<br>
case 'D':<br>
v-&gt;init(extFloat,sizeof(double),array_size);<br>
break;<br>
case 'F':<br>
v-&gt;init(extFloat,sizeof(float),array_size);<br>
break;<br>
case 'I':<br>
v-&gt;init(extInt,sizeof(int),array_size);<br>
break;<br>
case 'U':<br>
v-&gt;init(extInt,sizeof(unsigned),array_size);<br>
break;<br>
case 'S':<br>
v-&gt;init(extInt,sizeof(short),array_size);<br>
break;<br>
case 'L':<br>
v-&gt;init(extInt,sizeof(long),array_size);<br>
break;<br>
default:<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(010)- = "&lt;&lt;(int*)v&lt;&lt;endl;<br>
#endif<br>
delete v;<br>
v=0;<br>
break;<br>
}<br>
return v;<br>
}<br>
  <br>
//
========================================================================<br>
  <br>
INLINE otl_select_cursor::otl_select_cursor(<br>
otl_connect&amp; db, // connect object<br>
short arr_size, // attached host array size<br>
int exception_enabled // exception enabled flag<br>
):otl_cursor(db,exception_enabled)<br>
{<br>
cur_row=-1;<br>
row_count=0;<br>
cur_size=0;<br>
array_size=arr_size;<br>
}<br>
  <br>
INLINE otl_select_cursor::otl_select_cursor(int exception_enabled)<br>
: otl_cursor(exception_enabled)<br>
{<br>
}<br>
  <br>
INLINE int otl_select_cursor::open(<br>
otl_connect&amp; db, // connect object<br>
short arr_size, // attached host array size<br>
int exception_enabled // exception enabled flag<br>
)<br>
{<br>
cur_row=-1;<br>
row_count=0;<br>
cur_size=0;<br>
array_size=arr_size;<br>
ex_enabled=exception_enabled;<br>
return otl_cursor::open(db);<br>
}<br>
  <br>
// Close cursor<br>
INLINE int otl_select_cursor::close(void)<br>
{<br>
return otl_cursor::close();<br>
}<br>
  <br>
  <br>
INLINE int otl_select_cursor::first(void)<br>
{<br>
cur_row=-1;<br>
exec();<br>
fetch((short)array_size);<br>
row_count=rpc;<br>
cur_size=row_count;<br>
if(cur_size!=0)cur_row=0;<br>
return cur_size!=0;<br>
}<br>
  <br>
INLINE int otl_select_cursor::next(void)<br>
{<br>
if(cur_row==-1)return first();<br>
if(cur_row&lt;cur_size-1)<br>
++cur_row;<br>
else{<br>
if(eof()){<br>
cur_row=-1;<br>
return 0;<br>
}<br>
fetch((short)array_size);<br>
cur_size=rpc-row_count;<br>
row_count=rpc;<br>
if(cur_size!=0)cur_row=0;<br>
}<br>
return cur_size!=0;<br>
}<br>
  <br>
INLINE otl_ref_cursor::otl_ref_cursor(<br>
int exception_enabled // exception enabled flag<br>
): otl_cursor(exception_enabled),sel_cur(exception_enabled)<br>
{<br>
  <br>
}<br>
  <br>
INLINE otl_ref_cursor::otl_ref_cursor(<br>
otl_connect&amp; db, // connect object<br>
const char* cur_placeholder_name, // cursor reference placeholder name<br>
short arr_size, // attached host array size<br>
int exception_enabled // exception enabled flag<br>
):otl_cursor(db,exception_enabled),sel_cur(exception_enabled)<br>
{<br>
cur_row=-1;<br>
row_count=0;<br>
cur_size=0;<br>
array_size=arr_size;<br>
rvl_len=otl_var_list_size;<br>
vl_cur_len=0;<br>
rvl=new otl_p_generic_variable[rvl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(081)+ = "&lt;&lt;(int*)rvl&lt;&lt;endl;<br>
#endif<br>
for(int i=0;i&lt;rvl_len;++i)rvl[i]=0;<br>
strcpy(cur_placeholder,cur_placeholder_name);<br>
}<br>
  <br>
INLINE otl_ref_cursor::~otl_ref_cursor()<br>
{<br>
delete[] rvl;<br>
rvl=0;<br>
}<br>
  <br>
INLINE int otl_ref_cursor::open(<br>
otl_connect&amp; db, // connect object<br>
const char* cur_placeholder_name,<br>
// cursor reference placeholder name<br>
short arr_size, // attached host array size<br>
int exception_enabled<br>
// exception enabled flag<br>
)<br>
{<br>
cur_row=-1;<br>
row_count=0;<br>
cur_size=0;<br>
array_size=arr_size;<br>
rvl_len=otl_var_list_size;<br>
vl_cur_len=0;<br>
rvl=new otl_p_generic_variable[rvl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(181)+ = "&lt;&lt;(int*)rvl&lt;&lt;endl;<br>
#endif<br>
for(int i=0;i&lt;rvl_len;++i)rvl[i]=0;<br>
strcpy(cur_placeholder,cur_placeholder_name);<br>
return otl_cursor::open(db);<br>
}<br>
  <br>
INLINE int otl_ref_cursor::close(void)<br>
{<br>
delete[] rvl;<br>
rvl=0;<br>
sel_cur.close();<br>
return otl_cursor::close();<br>
}<br>
  <br>
  <br>
INLINE int otl_ref_cursor::first(void)<br>
{<br>
otl_cursor::bind(cur_placeholder,<br>
&amp;sel_cur.cda,<br>
sizeof(sel_cur.cda),<br>
102 // Special "OCI External datatype" code --<br>
// cursor reference<br>
);<br>
if(cur_row==-2)<br>
; // Special case -- calling describe_select() between parse() and
first()<br>
else{<br>
exec(); // Executing the PLSQL master block<br>
sel_cur.connected=1;<br>
}<br>
cur_row=-1;<br>
for(int i=0;i&lt;vl_cur_len;++i)<br>
sel_cur.bind(i+1,*rvl[i]);<br>
sel_cur.fetch((short)array_size);<br>
row_count=sel_cur.rpc;<br>
cur_size=row_count;<br>
if(cur_size!=0)cur_row=0;<br>
return cur_size!=0;<br>
}<br>
  <br>
INLINE int otl_ref_cursor::next(void)<br>
{<br>
if(cur_row&lt;0)return first();<br>
if(cur_row&lt;cur_size-1)<br>
++cur_row;<br>
else{<br>
if(sel_cur.eof()){<br>
cur_row=-1;<br>
return 0;<br>
}<br>
sel_cur.fetch((short)array_size);<br>
cur_size=sel_cur.rpc-row_count;<br>
row_count=sel_cur.rpc;<br>
if(cur_size!=0)cur_row=0;<br>
}<br>
return cur_size!=0;<br>
}<br>
  <br>
INLINE int otl_ref_cursor::bind(<br>
int column_num, // column number: 1,2,...<br>
otl_generic_variable&amp; v // reference to variable/array<br>
)<br>
{<br>
if(!connected)return 0;<br>
++vl_cur_len;<br>
rvl[vl_cur_len-1]=&amp;v;<br>
v.pos=column_num;<br>
return 1;<br>
}<br>
  <br>
INLINE int otl_ref_cursor::bind(otl_generic_variable&amp; v)<br>
{<br>
if(v.pos)<br>
return bind(v.pos,v);<br>
else if(v.name)<br>
return otl_cursor::bind(v);<br>
return 0;<br>
}<br>
  <br>
INLINE int otl_ref_cursor::bind(<br>
const char* name, // placeholder name: ":F1", ":F2"<br>
otl_generic_variable&amp; v // reference to host variable/array<br>
)<br>
{<br>
return otl_cursor::bind(name,v);<br>
}<br>
  <br>
INLINE int otl_ref_cursor::describe_select(<br>
otl_column_desc* desc, // pointer to array of column<br>
// descriptors<br>
int&amp; desc_len // actual number of columns<br>
)<br>
{<br>
otl_cursor::bind(cur_placeholder,<br>
&amp;sel_cur.cda,<br>
sizeof(sel_cur.cda),<br>
102 // Special "OCI External datatype" code --<br>
// cursor reference<br>
);<br>
exec(); // Executing the PLSQL master block<br>
sel_cur.connected=1;<br>
cur_row=-2; // Special case -- describe_select() before first() or
next()<br>
desc_len=0;<br>
for(int i=1;sel_cur.describe_column(desc[i-1],i);++i)<br>
++desc_len;<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_select_stream::init(int should_delete)<br>
{<br>
sl=0;<br>
sl_len=0;<br>
null_fetched=0;<br>
ret_code=0;<br>
sl_desc=0;<br>
should_delete_flag=should_delete;<br>
executed=0;<br>
cur_in=0;<br>
stm_text=0;<br>
}<br>
  <br>
INLINE otl_select_stream::otl_select_stream(<br>
otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SELECT statement <br>
const short arr_size, // output host arrays size<br>
... // NULL terminated list of pointers to input host<br>
// variables. <br>
):otl_select_cursor(db,arr_size)<br>
{<br>
init(0);<br>
  <br>
otl_p_generic_variable tmp_vl[otl_var_list_size];<br>
va_list argv;<br>
va_start(argv,arr_size);<br>
otl_generic_variable* v;<br>
  <br>
do{<br>
v=(otl_generic_variable*)va_arg(argv,otl_generic_variable*);<br>
if(v){<br>
++vl_len;<br>
tmp_vl[vl_len-1]=v;<br>
}<br>
}while(v);<br>
  <br>
if(vl_len&gt;0){<br>
vl=new otl_p_generic_variable[vl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(082)+ = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int i=0;i&lt;vl_len;++i)<br>
vl[i]=tmp_vl[i];<br>
}<br>
parse(sqlstm);<br>
get_select_list();<br>
bind_all();<br>
if(vl_len==0){<br>
rewind();<br>
null_fetched=0;<br>
}<br>
}<br>
  <br>
INLINE otl_select_stream::otl_select_stream(<br>
otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SELECT statement <br>
otl_p_generic_variable* avp,<br>
// Pointer to NULL terminated list of<br>
// pointers to input hots<br>
// variables<br>
const short arr_size // output host arrays size<br>
):otl_select_cursor(db,arr_size)<br>
{<br>
init(0);<br>
alloc_var(avp);<br>
parse(sqlstm);<br>
get_select_list();<br>
bind_all();<br>
if(vl_len==0){<br>
rewind();<br>
null_fetched=0;<br>
}<br>
}<br>
  <br>
INLINE otl_select_stream::otl_select_stream(<br>
const short arr_size, // output host arrays size<br>
const char* sqlstm, // SELECT statement <br>
otl_connect&amp; db // connect object<br>
):otl_select_cursor(db,arr_size)<br>
{<br>
init(1);<br>
  <br>
{<br>
int len=strlen(sqlstm)+1;<br>
stm_text=new char[len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(083)+ = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
strcpy(stm_text,sqlstm);<br>
otl_ext_hv_decl hvd(stm_text,1);<br>
hvd.alloc_host_var_list(vl,vl_len);<br>
}<br>
  <br>
parse();<br>
get_select_list();<br>
bind_all();<br>
if(vl_len==0){<br>
rewind();<br>
null_fetched=0;<br>
}<br>
  <br>
}<br>
  <br>
INLINE otl_select_stream::otl_select_stream(<br>
const char* sqlstm, // SELECT statement <br>
otl_connect&amp; db, // connect object<br>
const char* dummy_par<br>
):otl_select_cursor(db,1)<br>
{<br>
init(0);<br>
parse(sqlstm);<br>
get_select_list();<br>
if(dummy_par); // dummy use of the dummy parameter<br>
}<br>
  <br>
INLINE otl_select_stream::~otl_select_stream()<br>
{<br>
delete[] sl;<br>
if(should_delete_flag)<br>
for(int i=0;i&lt;vl_len;++i){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(011)- = "&lt;&lt;(int*)vl[i]&lt;&lt;endl;<br>
#endif<br>
delete vl[i];<br>
}<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(012)- = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
delete[] vl;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(013)- = "&lt;&lt;(int*)sl_desc&lt;&lt;endl;<br>
#endif<br>
delete[] sl_desc;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(014)- = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
}<br>
  <br>
INLINE void otl_select_stream::rewind(void)<br>
{<br>
ret_code=first();<br>
null_fetched=0;<br>
cur_col=-1;<br>
cur_in=0;<br>
executed=1;<br>
}<br>
  <br>
INLINE int otl_select_stream::is_null(void)<br>
{<br>
return null_fetched;<br>
}<br>
  <br>
INLINE int otl_select_stream::eof(void)<br>
{<br>
return !ret_code;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(char&amp; c)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
c=*(char*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(unsigned char&amp; c)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
c=*(unsigned char*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&gt;&gt;(char*
s)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
strcpy((char*)s,(char*)sl[cur_col].val(cur_row));<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(unsigned char* s)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
strcpy((char*)s,(char*)sl[cur_col].val(cur_row));<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(int&amp; n)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
n=(int)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(unsigned&amp; u)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
u=(unsigned)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(short&amp; sh)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
sh=(short)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&gt;&gt;(long
int&amp; l)<br>
{ <br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
l=(long)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(float&amp; f)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
f=(float)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp;
otl_select_stream::operator&gt;&gt;(double&amp; d)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
d=*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_select_stream::get_next(void)<br>
{<br>
if(cur_col&lt;sl_len-1){<br>
++cur_col;<br>
null_fetched=sl[cur_col].is_null(cur_row);<br>
}else{<br>
ret_code=next();<br>
cur_col=0;<br>
}<br>
}<br>
  <br>
INLINE int otl_select_stream::check_type(int type_code)<br>
{<br>
if(sl[cur_col].get_ftype()!=type_code){<br>
throw otl_exception(otl_error_msg_0,<br>
otl_error_code_0,<br>
stm_text);<br>
return 0;<br>
}else<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_select_stream::look_ahead(void)<br>
{<br>
if(cur_col==sl_len-1){<br>
ret_code=next();<br>
cur_col=-1;<br>
}<br>
}<br>
  <br>
INLINE void otl_select_stream::bind_all(void)<br>
{<br>
int i;<br>
for(i=0;i&lt;vl_len;++i)bind(*vl[i]);<br>
for(i=0;i&lt;sl_len;++i)bind(sl[i]);<br>
}<br>
  <br>
static INLINE int otl_int2ext(int int_type)<br>
{<br>
switch(int_type){<br>
case inVarChar2: return extCChar;<br>
case inNumber: return extFloat;<br>
case inLong: return extCChar; <br>
case inRowId: return extCChar; <br>
case inDate: return extCChar; <br>
case inRaw: return extCChar; <br>
case inLongRaw: return extCChar; <br>
case inChar: return extCChar;<br>
default:<br>
return -1;<br>
}<br>
}<br>
  <br>
static INLINE int otl_datatype_size(int ftype,int maxsz,int int_type)<br>
{<br>
switch(ftype){<br>
case extCChar:<br>
switch(int_type){<br>
case inRowId:<br>
return sizeof(otl_cchar_rowid);<br>
case inDate:<br>
return 10; // e.g. 19-JAN-64 + '\0'<br>
case inLong:<br>
case inLongRaw:<br>
return otl_max_long_size;<br>
case inRaw:<br>
return maxsz*2+1;<br>
default:<br>
return maxsz+1;<br>
}<br>
case extFloat: <br>
return sizeof(double);<br>
case extDate: <br>
return sizeof(otl_date_intern);<br>
default:<br>
return 0;<br>
}<br>
}<br>
  <br>
static INLINE void otl_map_ftype(const otl_column_desc&amp; desc, <br>
int&amp; ftype, <br>
int&amp; elem_size<br>
)<br>
{<br>
ftype=otl_int2ext(desc.dbtype);<br>
elem_size=otl_datatype_size(ftype,desc.dbsize,desc.dbtype);<br>
}<br>
  <br>
INLINE void otl_select_stream::get_select_list(void)<br>
{<br>
otl_column_desc sl_desc_tmp[otl_var_list_size];<br>
int sld_tmp_len=0;<br>
int ftype,elem_size,i;<br>
  <br>
for(i=1; describe_column(sl_desc_tmp[i-1],i); ++i)<br>
++sld_tmp_len;<br>
sl_len=sld_tmp_len;<br>
if(sl){<br>
delete[] sl;<br>
sl=0;<br>
}<br>
sl=new otl_dynamic_variable[sl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(084)+ = "&lt;&lt;(int*)sl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int j=0;j&lt;sl_len;++j){<br>
otl_map_ftype(sl_desc_tmp[j],ftype,elem_size);<br>
sl[j].copy_pos(j+1);<br>
sl[j].init(ftype,<br>
(short)elem_size,<br>
(short)array_size<br>
);<br>
}<br>
if(sl_desc){<br>
delete[] sl_desc;<br>
sl_desc=0;<br>
}<br>
sl_desc=new otl_column_desc[sl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(085)+ = "&lt;&lt;(int*)sl_desc&lt;&lt;endl;<br>
#endif<br>
  <br>
memcpy(sl_desc,sl_desc_tmp,sizeof(otl_column_desc)*sl_len);<br>
}<br>
  <br>
INLINE int otl_select_stream::select_list_len(void)<br>
{<br>
return sl_len;<br>
}<br>
  <br>
INLINE int otl_select_stream::column_ftype(int ndx)<br>
{<br>
return sl[ndx].get_ftype();<br>
}<br>
  <br>
INLINE int otl_select_stream::column_size(int ndx)<br>
{<br>
return sl[ndx].get_elem_size();<br>
}<br>
  <br>
INLINE void otl_select_stream::set_delete_var(const int should_delete)<br>
{<br>
should_delete_flag=should_delete;<br>
}<br>
  <br>
  <br>
INLINE void otl_select_stream::get_in_next(void)<br>
{<br>
if(cur_in==vl_len-1)<br>
rewind();<br>
else{<br>
++cur_in;<br>
executed=0;<br>
}<br>
}<br>
  <br>
INLINE int otl_select_stream::check_in_type(int type_code,int tsize)<br>
{<br>
if(vl[cur_in]-&gt;ftype==extCChar&amp;&amp;type_code==extCChar)<br>
return 1;<br>
if(vl[cur_in]-&gt;ftype!=type_code||vl[cur_in]-&gt;elem_size!=tsize){<br>
throw otl_exception(otl_error_msg_0,<br>
otl_error_code_0,<br>
stm_text);<br>
return 1;<br>
}else<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_select_stream::check_in_var(void)<br>
{<br>
if(vl_len==0)<br>
throw otl_exception(otl_error_msg_1,<br>
otl_error_code_1,<br>
stm_text);<br>
}<br>
  <br>
INLINE void otl_select_stream::check_if_executed(void)<br>
{<br>
if(!executed)<br>
throw otl_exception(otl_error_msg_2,<br>
otl_error_code_2,<br>
stm_text);<br>
}<br>
  <br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
char c)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
char* tmp=(char*)vl[cur_in]-&gt;val();<br>
tmp[0]=c;<br>
tmp[1]=0;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
unsigned char c)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
unsigned char* tmp=(unsigned char*)vl[cur_in]-&gt;val();<br>
tmp[0]=c;<br>
tmp[1]=0;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
char* s)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
strcpy((char*)vl[cur_in]-&gt;val(),(char*)s);<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
unsigned char* s)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
strcpy((char*)vl[cur_in]-&gt;val(),(char*)s);<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
int n)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(int))){<br>
*(int*)vl[cur_in]-&gt;val()=n;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
unsigned u)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(unsigned))){<br>
*(unsigned*)vl[cur_in]-&gt;val()=u;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
short sh)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(short))){<br>
*(short*)vl[cur_in]-&gt;val()=sh;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
long int l)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(long))){<br>
*(long*)vl[cur_in]-&gt;val()=l;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
float f)<br>
{<br>
check_in_var();<br>
if(check_in_type(extFloat,sizeof(float))){<br>
*(float*)vl[cur_in]-&gt;val()=f;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_select_stream&amp; otl_select_stream::operator&lt;&lt;(const
double f)<br>
{<br>
check_in_var();<br>
if(check_in_type(extFloat,sizeof(double))){<br>
*(double*)vl[cur_in]-&gt;val()=f;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::init(int should_delete)<br>
{<br>
sl=0;<br>
sl_len=0;<br>
null_fetched=0;<br>
ret_code=0;<br>
sl_desc=0;<br>
should_delete_flag=should_delete;<br>
executed=0;<br>
cur_in=0;<br>
stm_text=0;<br>
}<br>
  <br>
INLINE otl_ref_select_stream::otl_ref_select_stream(<br>
otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SELECT statement <br>
const char* cur_placeholder,<br>
// reference cursor placeholder<br>
const short arr_size, // output host arrays size<br>
... // NULL terminated list of pointers to input host<br>
// variables. <br>
):otl_ref_cursor(db,cur_placeholder,arr_size)<br>
{<br>
init(0);<br>
  <br>
otl_p_generic_variable tmp_vl[otl_var_list_size];<br>
va_list argv;<br>
va_start(argv,arr_size);<br>
otl_generic_variable* v;<br>
  <br>
do{<br>
v=(otl_generic_variable*)va_arg(argv,otl_generic_variable*);<br>
if(v){<br>
++vl_len;<br>
tmp_vl[vl_len-1]=v;<br>
}<br>
}while(v);<br>
  <br>
if(vl_len&gt;0){<br>
vl=new otl_p_generic_variable[vl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(086)+ = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int i=0;i&lt;vl_len;++i)<br>
vl[i]=tmp_vl[i];<br>
}<br>
parse(sqlstm);<br>
if(vl_len==0){<br>
rewind();<br>
null_fetched=0;<br>
}<br>
}<br>
  <br>
INLINE otl_ref_select_stream::otl_ref_select_stream(<br>
otl_connect&amp; db, // connect object<br>
const char* sqlstm, // SELECT statement <br>
const char* cur_placeholder,<br>
// reference cursor placeholder<br>
otl_p_generic_variable* avp,<br>
// Pointer to NULL terminated list of<br>
// pointers to input hots<br>
// variables<br>
const short arr_size // output host arrays size<br>
):otl_ref_cursor(db,cur_placeholder,arr_size)<br>
{<br>
init(0);<br>
alloc_var(avp);<br>
parse(sqlstm);<br>
if(vl_len==0){<br>
rewind();<br>
null_fetched=0;<br>
}<br>
}<br>
  <br>
INLINE otl_ref_select_stream::otl_ref_select_stream(<br>
const short arr_size, // output host arrays size<br>
const char* sqlstm, // SELECT statement <br>
const char* cur_placeholder,<br>
// reference cursor placeholder<br>
otl_connect&amp; db // connect object<br>
):otl_ref_cursor(db,cur_placeholder,arr_size)<br>
{<br>
init(1);<br>
  <br>
{<br>
int len=strlen(sqlstm)+1;<br>
stm_text=new char[len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(087)+ = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
  <br>
strcpy(stm_text,sqlstm);<br>
otl_ext_hv_decl hvd(stm_text,1);<br>
hvd.alloc_host_var_list(vl,vl_len);<br>
}<br>
  <br>
parse();<br>
if(vl_len==0){<br>
rewind();<br>
null_fetched=0;<br>
}<br>
  <br>
}<br>
  <br>
  <br>
INLINE otl_ref_select_stream::~otl_ref_select_stream()<br>
{<br>
delete[] sl;<br>
if(should_delete_flag)<br>
for(int i=0;i&lt;vl_len;++i){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(016)- = "&lt;&lt;(int*)vl[i]&lt;&lt;endl;<br>
#endif<br>
delete vl[i];<br>
}<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(017)- = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
delete[] vl;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(018)- = "&lt;&lt;(int*)sl_desc&lt;&lt;endl;<br>
#endif<br>
delete[] sl_desc;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(019)- = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::rewind(void)<br>
{<br>
get_select_list();<br>
ret_code=first();<br>
null_fetched=0;<br>
cur_col=-1;<br>
cur_in=0;<br>
executed=1;<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::is_null(void)<br>
{<br>
return null_fetched;<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::eof(void)<br>
{<br>
return !ret_code;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(char&amp; c)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
c=*(char*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(unsigned char&amp; c)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
c=*(unsigned char*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(char* s)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
strcpy((char*)s,(char*)sl[cur_col].val(cur_row));<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(unsigned char* s)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extCChar)&amp;&amp;!eof()){<br>
strcpy((char*)s,(char*)sl[cur_col].val(cur_row));<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(int&amp; n)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
n=(int)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(unsigned&amp; u)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
u=(unsigned)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(short&amp; sh)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
sh=(short)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(long int&amp; l)<br>
{ <br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
l=(long)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(float&amp; f)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
f=(float)*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&gt;&gt;(double&amp; d)<br>
{<br>
check_if_executed();<br>
if(eof())return *this;<br>
get_next();<br>
if(check_type(extFloat)&amp;&amp;!eof()){<br>
d=*(double*)sl[cur_col].val(cur_row);<br>
look_ahead();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::get_next(void)<br>
{<br>
if(cur_col&lt;sl_len-1){<br>
++cur_col;<br>
null_fetched=sl[cur_col].is_null(cur_row);<br>
}else{<br>
ret_code=next();<br>
cur_col=0;<br>
}<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::check_type(int type_code)<br>
{<br>
if(sl[cur_col].get_ftype()!=type_code){<br>
throw otl_exception(otl_error_msg_0,<br>
otl_error_code_0,<br>
stm_text);<br>
return 0;<br>
}else<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::look_ahead(void)<br>
{<br>
if(cur_col==sl_len-1){<br>
ret_code=next();<br>
cur_col=-1;<br>
}<br>
}<br>
  <br>
  <br>
INLINE void otl_ref_select_stream::get_select_list(void)<br>
{int i;<br>
otl_column_desc sl_desc_tmp[otl_var_list_size];<br>
int sld_tmp_len=0;<br>
int ftype,elem_size;<br>
  <br>
  <br>
otl_cursor::bind(cur_placeholder,<br>
&amp;sel_cur.cda,<br>
sizeof(sel_cur.cda),<br>
102 // Special "OCI External datatype" code --<br>
// cursor reference<br>
);<br>
for(i=0;i&lt;vl_len;++i)otl_cursor::bind(*vl[i]);<br>
otl_cursor::exec(); // Executing the PLSQL master block<br>
sel_cur.connected=1;<br>
cur_row=-2; <br>
sld_tmp_len=0;<br>
for(i=1;sel_cur.describe_column(sl_desc_tmp[i-1],i);++i)<br>
++sld_tmp_len;<br>
sl_len=sld_tmp_len;<br>
if(sl){<br>
delete[] sl;<br>
sl=0;<br>
}<br>
sl=new otl_dynamic_variable[sl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(088)+ = "&lt;&lt;(int*)sl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int j=0;j&lt;sl_len;++j){<br>
otl_map_ftype(sl_desc_tmp[j],ftype,elem_size);<br>
sl[j].copy_pos(j+1);<br>
sl[j].init(ftype,<br>
(short)elem_size,<br>
(short)array_size<br>
);<br>
}<br>
if(sl_desc){<br>
delete[] sl_desc;<br>
sl_desc=0;<br>
}<br>
sl_desc=new otl_column_desc[sl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(089)+ = "&lt;&lt;(int*)sl_desc&lt;&lt;endl;<br>
#endif<br>
  <br>
memcpy(sl_desc,sl_desc_tmp,sizeof(otl_column_desc)*sl_len);<br>
for(i=0;i&lt;sl_len;++i)sel_cur.bind(sl[i]);<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::select_list_len(void)<br>
{<br>
return sl_len;<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::column_ftype(int ndx)<br>
{<br>
return sl[ndx].get_ftype();<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::column_size(int ndx)<br>
{<br>
return sl[ndx].get_elem_size();<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::set_delete_var(const int
should_delete)<br>
{<br>
should_delete_flag=should_delete;<br>
}<br>
  <br>
  <br>
INLINE void otl_ref_select_stream::get_in_next(void)<br>
{<br>
if(cur_in==vl_len-1)<br>
rewind();<br>
else{<br>
++cur_in;<br>
executed=0;<br>
}<br>
}<br>
  <br>
INLINE int otl_ref_select_stream::check_in_type(int type_code,int tsize)<br>
{<br>
if(vl[cur_in]-&gt;ftype==extCChar&amp;&amp;type_code==extCChar)<br>
return 1;<br>
if(vl[cur_in]-&gt;ftype!=type_code||vl[cur_in]-&gt;elem_size!=tsize){<br>
throw otl_exception(otl_error_msg_0,<br>
otl_error_code_0,<br>
stm_text);<br>
return 1;<br>
}else<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::check_in_var(void)<br>
{<br>
if(vl_len==0)<br>
throw otl_exception(otl_error_msg_1,<br>
otl_error_code_1,<br>
stm_text);<br>
}<br>
  <br>
INLINE void otl_ref_select_stream::check_if_executed(void)<br>
{<br>
if(!executed)<br>
throw otl_exception(otl_error_msg_2,<br>
otl_error_code_2,<br>
stm_text);<br>
}<br>
  <br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const char c)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
char* tmp=(char*)vl[cur_in]-&gt;val();<br>
tmp[0]=c;<br>
tmp[1]=0;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const unsigned char c)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
unsigned char* tmp=(unsigned char*)vl[cur_in]-&gt;val();<br>
tmp[0]=c;<br>
tmp[1]=0;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const char* s)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
strcpy((char*)vl[cur_in]-&gt;val(),(char*)s);<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const unsigned char* s)<br>
{<br>
check_in_var();<br>
if(check_in_type(extCChar,1)){<br>
strcpy((char*)vl[cur_in]-&gt;val(),(char*)s);<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const int n)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(int))){<br>
*(int*)vl[cur_in]-&gt;val()=n;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const unsigned u)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(unsigned))){<br>
*(unsigned*)vl[cur_in]-&gt;val()=u;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const short sh)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(short))){<br>
*(short*)vl[cur_in]-&gt;val()=sh;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const long int l)<br>
{<br>
check_in_var();<br>
if(check_in_type(extInt,sizeof(long))){<br>
*(long*)vl[cur_in]-&gt;val()=l;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const float f)<br>
{<br>
check_in_var();<br>
if(check_in_type(extFloat,sizeof(float))){<br>
*(float*)vl[cur_in]-&gt;val()=f;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_ref_select_stream&amp;
otl_ref_select_stream::operator&lt;&lt;(const double f)<br>
{<br>
check_in_var();<br>
if(check_in_type(extFloat,sizeof(double))){<br>
*(double*)vl[cur_in]-&gt;val()=f;<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_out_stream::init(otl_connect&amp; db,int should_delete)<br>
{<br>
dirty=0;<br>
auto_commit_flag=1;<br>
should_delete_flag=should_delete;<br>
cur_x=-1;<br>
cur_y=0;<br>
connect=&amp;db;<br>
in_exception_flag=0;<br>
in_destruct_flag=0;<br>
stm_text=0;<br>
}<br>
  <br>
INLINE otl_out_stream::otl_out_stream(otl_connect&amp; db)<br>
:otl_cursor(db)<br>
{<br>
in_exception_flag=0;<br>
in_destruct_flag=0;<br>
dirty=0;<br>
auto_commit_flag=1;<br>
should_delete_flag=0;<br>
cur_x=-1;<br>
cur_y=0;<br>
connect=0;<br>
stm_text=0;<br>
}<br>
  <br>
INLINE otl_out_stream::otl_out_stream(<br>
otl_connect&amp; db,<br>
const char* sqlstm,<br>
...<br>
):otl_cursor(db)<br>
{<br>
init(db);<br>
  <br>
otl_p_generic_variable tmp_vl[otl_var_list_size];<br>
va_list argv;<br>
va_start(argv,sqlstm);<br>
otl_generic_variable* v;<br>
  <br>
do{<br>
v=(otl_generic_variable*)va_arg(argv,otl_generic_variable*);<br>
if(v){<br>
++vl_len;<br>
tmp_vl[vl_len-1]=v;<br>
}<br>
}while(v);<br>
  <br>
if(vl_len&gt;0){<br>
vl=new otl_p_generic_variable[vl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(090)+ = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
  <br>
for(int i=0;i&lt;vl_len;++i)<br>
vl[i]=tmp_vl[i];<br>
}<br>
  <br>
array_size=(short)vl[0]-&gt;array_size;<br>
parse(sqlstm);<br>
for(int i=0;i&lt;vl_len;++i)<br>
bind(*vl[i]);<br>
}<br>
  <br>
INLINE otl_out_stream::otl_out_stream(<br>
otl_connect&amp; db,<br>
const char* sqlstm,<br>
otl_p_generic_variable* avp<br>
):otl_cursor(db)<br>
{<br>
init(db);<br>
alloc_var(avp);<br>
array_size=(short)vl[0]-&gt;array_size;<br>
parse(sqlstm);<br>
for(int i=0;i&lt;vl_len;++i)<br>
bind(*vl[i]);<br>
}<br>
  <br>
INLINE otl_out_stream::otl_out_stream(<br>
short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db // connect object<br>
):otl_cursor(db)<br>
{<br>
init(db,1);<br>
array_size=arr_size;<br>
  <br>
{<br>
int len=strlen(sqlstm)+1;<br>
stm_text=new char[len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(091)+ = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
  <br>
strcpy(stm_text,sqlstm);<br>
otl_ext_hv_decl hvd(stm_text,arr_size);<br>
hvd.alloc_host_var_list(vl,vl_len);<br>
}<br>
  <br>
parse();<br>
for(int i=0;i&lt;vl_len;++i)<br>
bind(*vl[i]);<br>
}<br>
  <br>
INLINE otl_out_stream::~otl_out_stream()<br>
{<br>
in_destruct_flag=1;<br>
if(dirty&amp;&amp;!in_exception_flag)flush();<br>
if(should_delete_flag)<br>
for(int i=0;i&lt;vl_len;++i){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(020)- = "&lt;&lt;(int*)vl[i]&lt;&lt;endl;<br>
#endif<br>
delete vl[i];<br>
}<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(021)- = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
delete vl;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(022)- = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
in_destruct_flag=0;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const char
c)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extCChar,1)){<br>
char* tmp=(char*)vl[cur_x]-&gt;val(cur_y);<br>
tmp[0]=c;<br>
tmp[1]=0;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const
unsigned char c)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extCChar,1)){<br>
unsigned char* tmp=(unsigned char*)vl[cur_x]-&gt;val(cur_y);<br>
tmp[0]=c;<br>
tmp[1]=0;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const char*
s)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extCChar,1)){<br>
strcpy((char*)vl[cur_x]-&gt;val(cur_y),(char*)s);<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const
unsigned char* s)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extCChar,1)){<br>
strcpy((char*)vl[cur_x]-&gt;val(cur_y),(char*)s);<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const int n)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extInt,sizeof(int))){<br>
*(int*)vl[cur_x]-&gt;val(cur_y)=n;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const
unsigned u)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extInt,sizeof(unsigned))){<br>
*(unsigned *)vl[cur_x]-&gt;val(cur_y)=u;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const short
sh)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extInt,sizeof(short))){<br>
*(short*)vl[cur_x]-&gt;val(cur_y)=sh;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const long
int l)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extInt,sizeof(int))){<br>
*(long*)vl[cur_x]-&gt;val(cur_y)=l;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const float
f)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extFloat,sizeof(float))){<br>
*(float*)vl[cur_x]-&gt;val(cur_y)=f;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const
double d)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
if(check_type(extFloat,sizeof(double))){<br>
*(double*)vl[cur_x]-&gt;val(cur_y)=d;<br>
}<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE otl_out_stream&amp; otl_out_stream::operator&lt;&lt;(const
otl_null n)<br>
{<br>
if(vl_len&gt;0){<br>
get_next();<br>
vl[cur_x]-&gt;set_null(cur_y);<br>
check_buf();<br>
}<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_out_stream::flush(void)<br>
{<br>
if(!dirty)return;<br>
if(rc||adb-&gt;rc){<br>
clean();<br>
return; // buffer is not flushed in case of error<br>
}<br>
if(cur_x!=vl_len-1){<br>
in_exception_flag=1;<br>
throw otl_exception(otl_error_msg_3,<br>
otl_error_code_3,<br>
stm_text);<br>
}<br>
if(in_destruct_flag){<br>
int save=ex_enabled;<br>
ex_enabled=0;<br>
exec((short)(cur_y+1));<br>
ex_enabled=save;<br>
if(rc){<br>
clean();<br>
in_exception_flag=1;<br>
throw otl_exception(cda,stm_text);<br>
return;<br>
}<br>
if(auto_commit_flag){<br>
int save=connect-&gt;ex_enabled;<br>
connect-&gt;ex_enabled=0;<br>
connect-&gt;commit();<br>
connect-&gt;ex_enabled=save;<br>
if(connect-&gt;rc){<br>
clean();<br>
in_exception_flag=1;<br>
throw otl_exception(connect-&gt;lda,stm_text);<br>
return;<br>
}<br>
}<br>
}else{<br>
exec((short)(cur_y+1));<br>
if(auto_commit_flag)<br>
connect-&gt;commit();<br>
clean();<br>
}<br>
}<br>
  <br>
INLINE void otl_out_stream::clean(void)<br>
{<br>
if(!dirty)return;<br>
for(int i=0;i&lt;array_size;++i)<br>
for(int j=0;j&lt;vl_len;++j)<br>
vl[j]-&gt;set_not_null(i);<br>
cur_x=-1;<br>
cur_y=0;<br>
dirty=0;<br>
}<br>
  <br>
INLINE void otl_out_stream::set_commit(int auto_commit)<br>
{<br>
auto_commit_flag=auto_commit;<br>
}<br>
  <br>
INLINE void otl_out_stream::set_delete_var(const int should_delete)<br>
{<br>
should_delete_flag=should_delete;<br>
}<br>
  <br>
INLINE void otl_out_stream::get_next(void)<br>
{<br>
if(cur_x&lt;vl_len-1)<br>
++cur_x;<br>
else{<br>
if(cur_y&lt;array_size-1){<br>
++cur_y;<br>
cur_x=0;<br>
}else{<br>
flush();<br>
cur_x=0;<br>
}<br>
}<br>
dirty=1;<br>
}<br>
  <br>
INLINE int otl_out_stream::check_type(int type_code, int tsize)<br>
{<br>
if(vl[cur_x]-&gt;ftype==extCChar&amp;&amp;type_code==extCChar)<br>
return 1;<br>
if(vl[cur_x]-&gt;ftype!=type_code||vl[cur_x]-&gt;elem_size!=tsize){<br>
in_exception_flag=1;<br>
throw otl_exception(otl_error_msg_0,<br>
otl_error_code_0,<br>
stm_text);<br>
return 1;<br>
}else<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_out_stream::check_buf(void)<br>
{<br>
if(cur_x==vl_len-1 &amp;&amp; cur_y==array_size-1)<br>
flush();<br>
}<br>
  <br>
INLINE otl_inout_stream::otl_inout_stream(<br>
short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db // connect object<br>
):otl_out_stream(db)<br>
{<br>
dirty=0;<br>
auto_commit_flag=1;<br>
should_delete_flag=0;<br>
connect=&amp;db;<br>
in_exception_flag=0;<br>
stm_text=0;<br>
array_size=arr_size;<br>
  <br>
in_vl=0;<br>
iv_len=0;<br>
avl_len=0;<br>
avl=0;<br>
  <br>
{<br>
int len=strlen(sqlstm)+1;<br>
stm_text=new char[len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(092)+ = "&lt;&lt;(int*)stm_text&lt;&lt;endl;<br>
#endif<br>
  <br>
strcpy(stm_text,sqlstm);<br>
otl_ext_hv_decl hvd(stm_text,arr_size);<br>
if(hvd.vst[otl_ext_hv_decl::def]==hvd.len){<br>
should_delete_flag=1;<br>
hvd.alloc_host_var_list(vl,vl_len);<br>
}else{<br>
for(int i=0;i&lt;hvd.len;++i){<br>
if(hvd.inout[i]==otl_ext_hv_decl::in)<br>
++vl_len;<br>
else if(hvd.inout[i]==otl_ext_hv_decl::out)<br>
++iv_len;<br>
else if(hvd.inout[i]==otl_ext_hv_decl::io){<br>
++vl_len;<br>
++iv_len;<br>
}<br>
}<br>
if(vl_len&gt;0){<br>
vl=new otl_p_generic_variable[vl_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(093)+ = "&lt;&lt;(int*)vl&lt;&lt;endl;<br>
#endif<br>
  <br>
}<br>
if(iv_len&gt;0){<br>
in_vl=new otl_p_generic_variable[iv_len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(094)+ = "&lt;&lt;(int*)in_vl&lt;&lt;endl;<br>
#endif<br>
}<br>
if(hvd.len&gt;0){<br>
avl=new otl_p_generic_variable[hvd.len];<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(095)+ = "&lt;&lt;(int*)avl&lt;&lt;endl;<br>
#endif<br>
}<br>
iv_len=0; vl_len=0; avl_len=hvd.len;<br>
for(int j=0;j&lt;avl_len;++j){<br>
otl_p_generic_variable
v=hvd.alloc_var(hvd[j],hvd.inout[j],otl_ext_hv_decl::def);<br>
avl[j]=v;<br>
if(hvd.inout[j]==otl_ext_hv_decl::in){<br>
++vl_len;<br>
vl[vl_len-1]=v;<br>
}else if(hvd.inout[j]==otl_ext_hv_decl::out){<br>
++iv_len;<br>
in_vl[iv_len-1]=v;<br>
}else if(hvd.inout[j]==otl_ext_hv_decl::io){<br>
++vl_len;<br>
++iv_len;<br>
vl[vl_len-1]=v;<br>
in_vl[iv_len-1]=v;<br>
}<br>
}<br>
}<br>
}<br>
  <br>
parse();<br>
for(int i=0;i&lt;vl_len;++i)bind(*vl[i]);<br>
for(int j=0;j&lt;iv_len;++j)bind(*in_vl[j]);<br>
  <br>
rewind();<br>
}<br>
  <br>
INLINE otl_inout_stream::~otl_inout_stream()<br>
{<br>
if(!in_exception_flag)<br>
flush();<br>
for(int i=0;i&lt;avl_len;++i){<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(023)- = "&lt;&lt;(int*)avl[i]&lt;&lt;endl;<br>
#endif<br>
delete avl[i];<br>
}<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(024)- = "&lt;&lt;(int*)avl&lt;&lt;endl;<br>
#endif<br>
delete[] avl;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(025)- = "&lt;&lt;(int*)in_vl&lt;&lt;endl;<br>
#endif<br>
delete[] in_vl;<br>
}<br>
  <br>
INLINE void otl_inout_stream::rewind(void)<br>
{<br>
flush();<br>
cur_in_x=0;<br>
cur_in_y=0;<br>
cur_x=-1;<br>
cur_y=0;<br>
in_y_len=0;<br>
null_fetched=0;<br>
if(vl_len==0){<br>
exec(array_size);<br>
in_y_len=array_size;<br>
cur_in_y=0;<br>
cur_in_x=0;<br>
}<br>
}<br>
  <br>
INLINE int otl_inout_stream::eof(void)<br>
{<br>
if(iv_len==0)return 1;<br>
if(in_y_len==0)return 1;<br>
if(cur_in_y&lt;=in_y_len-1)return 0;<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_inout_stream::flush(void)<br>
{<br>
if(vl_len==0)return;<br>
in_y_len=cur_y+1;<br>
cur_in_y=0;<br>
cur_in_x=0;<br>
if(!in_exception_flag)<br>
otl_out_stream::flush();<br>
}<br>
  <br>
INLINE void otl_inout_stream::clean(void)<br>
{<br>
if(vl_len==0)return;<br>
in_y_len=cur_y+1;<br>
cur_in_y=0;<br>
cur_in_x=0;<br>
otl_out_stream::clean();<br>
}<br>
  <br>
INLINE int otl_inout_stream::is_null(void)<br>
{<br>
return null_fetched;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(char&amp; c)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extCChar,1)){<br>
c=*(char*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(unsigned char&amp; c)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extCChar,1)){<br>
c=*(unsigned char*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp; otl_inout_stream::operator&gt;&gt;(char* s)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extCChar,1)){<br>
strcpy((char*)s,(char*)in_vl[cur_in_x]-&gt;val(cur_in_y));<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(unsigned char* s)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extCChar,1)){<br>
strcpy((char*)s,(char*)in_vl[cur_in_x]-&gt;val(cur_in_y));<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(int&amp; n)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extInt,sizeof(int))){<br>
n=*(int*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(unsigned&amp; u)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extInt,sizeof(unsigned))){<br>
u=*(unsigned*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(short&amp; sh)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extInt,sizeof(short))){<br>
sh=*(short*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp; otl_inout_stream::operator&gt;&gt;(long
int&amp; l)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extInt,sizeof(long))){<br>
l=*(long*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(float&amp; f)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extFloat,sizeof(float))){<br>
f=*(float*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE otl_inout_stream&amp;
otl_inout_stream::operator&gt;&gt;(double&amp; d)<br>
{<br>
if(eof())return *this;<br>
if(check_in_type(extFloat,sizeof(double))){<br>
d=*(double*)in_vl[cur_in_x]-&gt;val(cur_in_y);<br>
null_fetched=is_null_intern();<br>
}<br>
get_in_next();<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_inout_stream::get_in_next(void)<br>
{<br>
if(iv_len==0)return;<br>
if(in_y_len==0)return;<br>
if(cur_in_x&lt;iv_len-1)<br>
++cur_in_x;<br>
else{<br>
if(cur_in_y&lt;in_y_len-1){<br>
++cur_in_y;<br>
cur_in_x=0;<br>
}else{<br>
cur_in_y=0;<br>
cur_in_x=0;<br>
in_y_len=0;<br>
}<br>
}<br>
}<br>
  <br>
INLINE int otl_inout_stream::check_in_type(int type_code,int tsize)<br>
{<br>
if(in_vl[cur_in_x]-&gt;ftype==extCChar&amp;&amp;type_code==extCChar)<br>
return 1;<br>
if(in_vl[cur_in_x]-&gt;ftype!=type_code||in_vl[cur_in_x]-&gt;elem_size!=tsize){<br>
in_exception_flag=1;<br>
throw otl_exception(otl_error_msg_0,<br>
otl_error_code_0,<br>
stm_text);<br>
return 1;<br>
}else<br>
return 1;<br>
  <br>
}<br>
  <br>
INLINE int otl_inout_stream::is_null_intern(void)<br>
{<br>
if(iv_len==0)return 0;<br>
if(in_y_len==0)return 0;<br>
if(in_y_len&gt;0)<br>
return in_vl[cur_in_x]-&gt;is_null(cur_in_y);<br>
return 0;<br>
}<br>
  <br>
INLINE otl_stream::otl_stream(<br>
short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db, // connect object<br>
const char* ref_cur_placeholder // reference cursor placeholder, e.g.
":cur"<br>
)<br>
{<br>
io=0; ss=0; ref_ss=0;<br>
adb=&amp;db;<br>
open(arr_size,sqlstm,db,ref_cur_placeholder);<br>
}<br>
  <br>
  <br>
INLINE otl_stream::otl_stream()<br>
{<br>
ref_ss=0;<br>
io=0; <br>
ss=0;<br>
adb=0;<br>
}<br>
  <br>
INLINE void otl_stream::open(<br>
short arr_size, // host array size<br>
const char* sqlstm, // SQL statement <br>
otl_connect&amp; db, // connect object<br>
const char* ref_cur_placeholder // reference cursor placeholder, e.g.
":cur"<br>
)<br>
{<br>
char tmp[7];<br>
char* c=(char*)sqlstm;<br>
  <br>
while(isspace(*c))++c;<br>
strncpy(tmp,c,6);<br>
tmp[6]=0;<br>
c=tmp;<br>
while(*c){<br>
*c=(char)toupper(*c);<br>
++c;<br>
}<br>
adb=&amp;db;<br>
if(strncmp(tmp,"SELECT",6)==0){<br>
ss=new otl_select_stream(arr_size,sqlstm,db);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(096)+ = "&lt;&lt;(int*)ss&lt;&lt;endl;<br>
#endif<br>
  <br>
}<br>
else if(ref_cur_placeholder!=0){<br>
ref_ss=new
otl_ref_select_stream(arr_size,sqlstm,ref_cur_placeholder,db);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(097)+ = "&lt;&lt;(int*)ref_ss&lt;&lt;endl;<br>
#endif<br>
}else {<br>
io=new otl_inout_stream(arr_size,sqlstm,db);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(098)+ = "&lt;&lt;(int*)io&lt;&lt;endl;<br>
#endif<br>
  <br>
}<br>
}<br>
  <br>
INLINE int otl_stream::good(void)<br>
{<br>
if(io||ss||ref_ss)<br>
return 1;<br>
else<br>
return 0;<br>
}<br>
  <br>
INLINE void otl_stream::close(void)<br>
{<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(026)- = "&lt;&lt;(int*)ss&lt;&lt;endl;<br>
#endif<br>
delete ss;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(027)- = "&lt;&lt;(int*)io&lt;&lt;endl;<br>
#endif<br>
delete io;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(026)- = "&lt;&lt;(int*)ref_ss&lt;&lt;endl;<br>
#endif<br>
delete ref_ss;<br>
ss=0; io=0; ref_ss=0;<br>
adb=0;<br>
}<br>
  <br>
INLINE otl_stream::~otl_stream()<br>
{<br>
close();<br>
}<br>
  <br>
INLINE int otl_stream::eof(void)<br>
{<br>
if(io)<br>
return io-&gt;eof();<br>
else if(ss)<br>
return ss-&gt;eof();<br>
else if(ref_ss)<br>
return ref_ss-&gt;eof();<br>
else<br>
return 1;<br>
}<br>
  <br>
INLINE void otl_stream::flush(void)<br>
{<br>
if(io)io-&gt;flush();<br>
}<br>
  <br>
INLINE void otl_stream::clean(void)<br>
{<br>
if(io)io-&gt;clean();<br>
}<br>
  <br>
INLINE void otl_stream::rewind(void)<br>
{<br>
if(io)<br>
io-&gt;rewind();<br>
else if(ss)<br>
ss-&gt;rewind();<br>
else if(ref_ss)<br>
ref_ss-&gt;rewind();<br>
}<br>
  <br>
INLINE int otl_stream::is_null(void)<br>
{<br>
if(io)<br>
return io-&gt;is_null();<br>
else if(ss)<br>
return ss-&gt;is_null();<br>
else if(ref_ss)<br>
return ref_ss-&gt;is_null();<br>
else<br>
return 0;<br>
}<br>
  <br>
INLINE void otl_stream::set_commit(int auto_commit)<br>
{<br>
if(io)io-&gt;set_commit(auto_commit);<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(char&amp; c)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(c);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(c);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(c);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(unsigned char&amp;
c)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(c);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(c);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(c);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(char* s)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(s);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(s);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(s);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(unsigned char* s)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(s);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(s);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(s);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(int&amp; n)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(n);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(n);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(n);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(unsigned&amp; u)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(u);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(u);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(u);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(short&amp; sh)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(sh);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(sh);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(sh);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(long int&amp; l)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(l);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(l);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(l);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(float&amp; f)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(f);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(f);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(f);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&gt;&gt;(double&amp; d)<br>
{<br>
if(io)<br>
io-&gt;operator&gt;&gt;(d);<br>
else if(ss)<br>
ss-&gt;operator&gt;&gt;(d);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&gt;&gt;(d);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const char c)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(c);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(c);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(c);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const unsigned char
c)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(c);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(c);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(c);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const char* s)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(s);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(s);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(s);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const unsigned
char* s)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(s);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(s);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(s);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const int n)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(n);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(n);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(n);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const unsigned u)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(u);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(u);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(u);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const short sh)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(sh);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(sh);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(sh);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const long int l)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(l);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(l);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(l);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const float f)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(f);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(f);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(f);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const double d)<br>
{<br>
if(io)<br>
io-&gt;operator&lt;&lt;(d);<br>
else if(ss)<br>
ss-&gt;operator&lt;&lt;(d);<br>
else if(ref_ss)<br>
ref_ss-&gt;operator&lt;&lt;(d);<br>
return *this;<br>
}<br>
  <br>
INLINE otl_stream&amp; otl_stream::operator&lt;&lt;(const otl_null n)<br>
{<br>
if(io)io-&gt;operator&lt;&lt;(otl_null());<br>
return *this;<br>
}<br>
  <br>
INLINE void otl_stream::vprintf(char* fmt,va_list argv)<br>
{<br>
char *c=fmt;<br>
  <br>
while(*c){<br>
if(*c=='%'){<br>
++c;<br>
switch(*c){<br>
case 'N':<br>
(*this)&lt;&lt;otl_null();<br>
break;<br>
case 'f':<br>
(*this)&lt;&lt;(float)va_arg(argv,double);<br>
break;<br>
case 'd':<br>
(*this)&lt;&lt;(int)va_arg(argv,int);<br>
break;<br>
case 'u':<br>
(*this)&lt;&lt;(unsigned)va_arg(argv,unsigned);<br>
break;<br>
case 'l':<br>
++c;<br>
switch(*c){<br>
case 'd':<br>
(*this)&lt;&lt;(long)va_arg(argv,long);<br>
break;<br>
case 'f':<br>
(*this)&lt;&lt;(double)va_arg(argv,double);<br>
break;<br>
}<br>
break; <br>
case 'c':<br>
(*this)&lt;&lt;(char)va_arg(argv,int);<br>
break;<br>
case 's':<br>
(*this)&lt;&lt;(char*)va_arg(argv,char*);<br>
break;<br>
}<br>
}<br>
++c;<br>
}<br>
}<br>
  <br>
INLINE void otl_stream::vscanf(char* fmt,va_list argv)<br>
{char *c=fmt;<br>
  <br>
while(*c){<br>
if(*c=='%'){<br>
++c;<br>
switch(*c){<br>
case 'f':<br>
(*this)&gt;&gt;*(float*)va_arg(argv,float*);<br>
break;<br>
case 'd':<br>
(*this)&gt;&gt;*(int*)va_arg(argv,int*);<br>
break;<br>
case 'u':<br>
(*this)&gt;&gt;*(unsigned*)va_arg(argv,unsigned*);<br>
break;<br>
case 'l':<br>
++c;<br>
switch(*c){<br>
case 'd':<br>
(*this)&gt;&gt;*(long*)va_arg(argv,long*);<br>
break;<br>
case 'f':<br>
(*this)&gt;&gt;*(double*)va_arg(argv,double*);<br>
break;<br>
}<br>
break; <br>
case 'c':<br>
(*this)&gt;&gt;*(char*)va_arg(argv,char*);<br>
break;<br>
case 's':<br>
(*this)&gt;&gt;(char*)va_arg(argv,char*);<br>
break;<br>
}<br>
}<br>
++c;<br>
}<br>
}<br>
  <br>
INLINE void otl_stream::printf(const char* fmt,...)<br>
{<br>
va_list argv;<br>
va_start(argv,fmt);<br>
vprintf((char*)fmt,argv);<br>
va_end(argv);<br>
}<br>
  <br>
INLINE void otl_stream::scanf(const char* fmt,...)<br>
{<br>
va_list argv;<br>
va_start(argv,fmt);<br>
vscanf((char*)fmt,argv);<br>
}<br>
  <br>
// =========================== Prosto*C functions
===============================<br>
  <br>
INLINE otl_connect* otl_logon(char* connect,otl_error_handler handler)<br>
{<br>
otl_connect* db=new otl_connect;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(099)+ = "&lt;&lt;(int*)db&lt;&lt;endl;<br>
#endif<br>
  <br>
db-&gt;handler=handler;<br>
try{<br>
db-&gt;rlogon(connect);<br>
}catch(otl_exception&amp; p){<br>
if(handler)(*handler)((char*)p.msg,p.code);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(028)- = "&lt;&lt;(int*)db&lt;&lt;endl;<br>
#endif<br>
delete db;<br>
return 0;<br>
}<br>
return db;<br>
}<br>
  <br>
INLINE otl_connect* otl_proC_logon(otl_error_handler handler)<br>
{<br>
otl_connect* db=new otl_connect;<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(100)+ = "&lt;&lt;(int*)db&lt;&lt;endl;<br>
#endif<br>
  <br>
db-&gt;handler=handler;<br>
try{<br>
db-&gt;sqllda();<br>
}catch(otl_exception&amp; p){<br>
if(handler)(*handler)((char*)p.msg,p.code);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(029)- = "&lt;&lt;(int*)db&lt;&lt;endl;<br>
#endif<br>
delete db;<br>
return 0;<br>
}<br>
return db;<br>
}<br>
  <br>
INLINE int otl_logoff(otl_connect* db)<br>
{<br>
if(!db)return 0;<br>
try{<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(030)- = "&lt;&lt;(int*)db&lt;&lt;endl;<br>
#endif<br>
delete db;<br>
return 1;<br>
}<br>
catch(otl_exception&amp; p){<br>
if(db-&gt;handler)<br>
(*(otl_error_handler)db-&gt;handler)((char*)p.msg,p.code);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(031)- = "&lt;&lt;(int*)db&lt;&lt;endl;<br>
#endif<br>
delete db;<br>
return 0;<br>
}<br>
// return 1;<br>
}<br>
  <br>
INLINE void otl_commit(otl_connect* db)<br>
{<br>
try{<br>
db-&gt;commit();<br>
}<br>
catch(otl_exception&amp; p){<br>
if(db-&gt;handler)<br>
(*(otl_error_handler)db-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
INLINE void otl_rollback(otl_connect* db)<br>
{<br>
try{<br>
db-&gt;rollback();<br>
}<br>
catch(otl_exception&amp; p){<br>
if(db-&gt;handler)<br>
(*(otl_error_handler)db-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
INLINE int otl_exec(otl_connect* db,char* stm,int ignore_error)<br>
{<br>
if(ignore_error){<br>
return otl_cursor::direct_exec(*db,stm,otl_exception::disabled);<br>
}else{<br>
try{<br>
otl_cursor::direct_exec(*db,stm);<br>
return 1;<br>
}<br>
catch(otl_exception&amp; p){<br>
if(db-&gt;handler)<br>
(*(otl_error_handler)db-&gt;handler)((char*)p.msg,p.code);<br>
return 0;<br>
}<br>
// return 1;<br>
}<br>
}<br>
  <br>
INLINE otl_stream* otl_stream_open(otl_connect* db, <br>
char* stm, <br>
short bufsize,<br>
const char* ref_cur_placeholder<br>
)<br>
{otl_stream* s=0;<br>
try{<br>
s=new otl_stream(bufsize,stm,*db,ref_cur_placeholder);<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(101)+ = "&lt;&lt;(int*)s&lt;&lt;endl;<br>
#endif<br>
  <br>
return s;<br>
}<br>
catch(otl_exception&amp; p){<br>
if(db-&gt;handler)<br>
(*(otl_error_handler)db-&gt;handler)((char*)p.msg,p.code);<br>
return 0;<br>
}<br>
// return 0;<br>
}<br>
  <br>
INLINE void otl_stream_close(otl_stream* f)<br>
{otl_connect* db=f-&gt;adb;<br>
try{<br>
#ifdef OTL_DEBUG<br>
cout&lt;&lt;"(032)- = "&lt;&lt;(int*)f&lt;&lt;endl;<br>
#endif<br>
delete f;<br>
}<br>
catch(otl_exception&amp; p){<br>
if(db-&gt;handler)<br>
(*(otl_error_handler)db-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
INLINE int otl_eof(otl_stream* f)<br>
{<br>
try{<br>
return f-&gt;eof();<br>
}<br>
catch(otl_exception&amp; p){<br>
if(f-&gt;adb-&gt;handler)<br>
(*(otl_error_handler)f-&gt;adb-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
return 1;<br>
}<br>
  <br>
INLINE int otl_is_null(otl_stream* f)<br>
{<br>
try{<br>
return f-&gt;is_null();<br>
}<br>
catch(otl_exception&amp; p){<br>
if(f-&gt;adb-&gt;handler)<br>
(*(otl_error_handler)f-&gt;adb-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
return 0;<br>
}<br>
  <br>
INLINE void otl_set_commit(otl_stream* f,int auto_commit)<br>
{<br>
try{<br>
f-&gt;set_commit(auto_commit);<br>
}<br>
catch(otl_exception&amp; p){<br>
if(f-&gt;adb-&gt;handler)<br>
(*(otl_error_handler)f-&gt;adb-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
INLINE void otl_flush(otl_stream* f)<br>
{<br>
try{<br>
f-&gt;flush();<br>
}<br>
catch(otl_exception&amp; p){<br>
if(f-&gt;adb-&gt;handler)<br>
(*(otl_error_handler)f-&gt;adb-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
INLINE void otl_printf(otl_stream* f,const char* fmt,...)<br>
{<br>
try{<br>
va_list argv;<br>
va_start(argv,fmt);<br>
f-&gt;vprintf((char*)fmt,argv);<br>
va_end(argv);<br>
}<br>
catch(otl_exception&amp; p){<br>
if(f-&gt;adb-&gt;handler)<br>
(*(otl_error_handler)f-&gt;adb-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
INLINE void otl_scanf(otl_stream* f,const char* fmt,...)<br>
{<br>
try{<br>
va_list argv;<br>
va_start(argv,fmt);<br>
f-&gt;vscanf((char*)fmt,argv);<br>
va_end(argv);<br>
}<br>
catch(otl_exception&amp; p){<br>
if(f-&gt;adb-&gt;handler)<br>
(*(otl_error_handler)f-&gt;adb-&gt;handler)((char*)p.msg,p.code);<br>
}<br>
}<br>
  <br>
#endif <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  </a></xmp>
  <h2><a name="secD">Appendix D. Pro*OTL / Pre-Pro*C preprecessor's
source code (ppc.C or ppc.cpp)</a></h2>
  <xmp><a name="secD">
//
// The OCI Template Library 1.0.6,
// Pro*OTL / Pre-Pro*C preprocessor 1.0.0,
// Copyright (C) Sergei Kuchin, 1996
// Author: Sergei Kuchin
// This is free software. Permission to use, copy, modify and
// redistribute it for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all copies.
// #define text ora_text
#include &lt;otl.h&gt;
#undef text
#include &lt;iostream.h&gt;
#include &lt;fstream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
otl_connect db;
fstream inf,outf,hf,hf1,cm;
int hf1flag=0;
int cmflag=0;
char buf[1024];
int line=0;
const int dir_size=6;
const char* directive[dir_size]={ "#sql-init-main", // 0
"#sql-init-module", // 1 "#sql-select", // 2 "#sql-out-stm", // 3
"#sql-plsql", // 4 "#sql-str-type" // 5
};
int select_count=0;
int stflag=0;
char sttype[128]="";
void HelpMessage(void)
{ cout&lt;&lt;endl; cout&lt;&lt;"Usage: ppc &lt;connect_string&gt;
&lt;input_file&gt; &lt;proc-file&gt; &lt;h-file&gt; &lt;#define&gt;
[&lt;macro-def&gt; [&lt;OTL-module&gt;]]"&lt;&lt;endl;
cout&lt;&lt;"Example: ppc scott/tiger sample.ppc sample.pc sample.h
__SAMPLE_H"&lt;&lt;endl; cout&lt;&lt;endl;
} /* HelpMessage */
void GetLine(void)
{ inf.getline(buf,sizeof(buf)); ++line;
} /* GetLine */
void Error(char* err)
{ cerr&lt;&lt;"Line ("&lt;&lt;line&lt;&lt;"):"&lt;&lt;buf&lt;&lt;endl;
cerr&lt;&lt;err&lt;&lt;endl; db.logoff(); exit(1);
} /* Error */
void SqlInitMain(void)
{ outf&lt;&lt;"#include &lt;stdio.h&gt;"&lt;&lt;endl;
outf&lt;&lt;"#include &lt;string.h&gt;"&lt;&lt;endl; outf&lt;&lt;"EXEC
SQL INCLUDE SQLCA;"&lt;&lt;endl; outf&lt;&lt;""&lt;&lt;endl;
outf&lt;&lt;"#define sql_code sqlca.sqlcode"&lt;&lt;endl;
outf&lt;&lt;"#define sql_rpc sqlca.sqlerrd[2]"&lt;&lt;endl;
outf&lt;&lt;""&lt;&lt;endl; outf&lt;&lt;"typedef char
CSTR_UserId[256];"&lt;&lt;endl; outf&lt;&lt;""&lt;&lt;endl;
outf&lt;&lt;"EXEC SQL BEGIN DECLARE SECTION;"&lt;&lt;endl;
outf&lt;&lt;" EXEC SQL TYPE CSTR_UserId IS STRING(256);"&lt;&lt;endl;
outf&lt;&lt;" CSTR_UserId UserId;"&lt;&lt;endl; outf&lt;&lt;"EXEC SQL
END DECLARE SECTION;"&lt;&lt;endl; outf&lt;&lt;""&lt;&lt;endl;
outf&lt;&lt;"static void sqlerror(void)"&lt;&lt;endl;
outf&lt;&lt;"{"&lt;&lt;endl; outf&lt;&lt;" EXEC SQL WHENEVER SQLERROR
CONTINUE;"&lt;&lt;endl; outf&lt;&lt;"
fprintf(stderr,\"\\n%s\\n\",sqlca.sqlerrm.sqlerrmc);"&lt;&lt;endl;
outf&lt;&lt;" EXEC SQL ROLLBACK RELEASE;"&lt;&lt;endl; outf&lt;&lt;"
exit(1);"&lt;&lt;endl; outf&lt;&lt;"}"&lt;&lt;endl; outf&lt;&lt;endl;
outf&lt;&lt;"EXEC SQL WHENEVER SQLERROR DO sqlerror();"&lt;&lt;endl;
if(cmflag){ cm&lt;&lt;"#include &lt;otl.h&gt;"&lt;&lt;endl;
cm&lt;&lt;"static otl_connect* db;"&lt;&lt;endl; cm&lt;&lt;"static
otl_cursor hotcur;"&lt;&lt;endl&lt;&lt;endl; cm&lt;&lt;"extern
\"C\"{"&lt;&lt;endl&lt;&lt;endl; }
} /* SqlInitMain */
void SqlInitModule(void)
{ outf&lt;&lt;"#include &lt;stdio.h&gt;"&lt;&lt;endl;
outf&lt;&lt;"#include &lt;string.h&gt;"&lt;&lt;endl; outf&lt;&lt;"EXEC
SQL INCLUDE SQLCA;"&lt;&lt;endl; outf&lt;&lt;""&lt;&lt;endl;
outf&lt;&lt;"#define sql_code sqlca.sqlcode"&lt;&lt;endl;
outf&lt;&lt;"#define sql_rpc sqlca.sqlerrd[2]"&lt;&lt;endl;
outf&lt;&lt;""&lt;&lt;endl; outf&lt;&lt;"typedef char
CSTR[128];"&lt;&lt;endl; outf&lt;&lt;""&lt;&lt;endl; outf&lt;&lt;"EXEC
SQL BEGIN DECLARE SECTION;"&lt;&lt;endl; outf&lt;&lt;" EXEC SQL TYPE
CSTR IS STRING(128);"&lt;&lt;endl; outf&lt;&lt;"EXEC SQL END DECLARE
SECTION;"&lt;&lt;endl; outf&lt;&lt;""&lt;&lt;endl; outf&lt;&lt;"static
void sqlerror(void)"&lt;&lt;endl; outf&lt;&lt;"{"&lt;&lt;endl;
outf&lt;&lt;" EXEC SQL WHENEVER SQLERROR CONTINUE;"&lt;&lt;endl;
outf&lt;&lt;"
fprintf(stderr,\"\\n%s\\n\",sqlca.sqlerrm.sqlerrmc);"&lt;&lt;endl;
outf&lt;&lt;" EXEC SQL ROLLBACK RELEASE;"&lt;&lt;endl; outf&lt;&lt;"
exit(1);"&lt;&lt;endl; outf&lt;&lt;"}"&lt;&lt;endl;
outf&lt;&lt;""&lt;&lt;endl; outf&lt;&lt;endl; outf&lt;&lt;"EXEC SQL
WHENEVER SQLERROR DO sqlerror();"&lt;&lt;endl; if(cmflag){
cm&lt;&lt;"#include &lt;otl.h&gt;"&lt;&lt;endl; cm&lt;&lt;"static
otl_connect* db;"&lt;&lt;endl; cm&lt;&lt;"static otl_cursor
hotcur;"&lt;&lt;endl&lt;&lt;endl; cm&lt;&lt;"extern
\"C\"{"&lt;&lt;endl&lt;&lt;endl; }
} /* SqlInitModule */
const int stmsize=16000;
char stm[stmsize];
char stm1[stmsize];
char stmName[256];
int stmArrSize;
const int MAX_VAR_ARRAY_SIZE=512;
class HVDArray{
public: enum VarStatus{ in=0, out=1, io=2, def=3 }; HVDArray(char*
stm); ~HVDArray(); char* operator[](int ndx){return hv[ndx];}; short
v_status(int ndx){return inout[ndx];}; char* hv[MAX_VAR_ARRAY_SIZE];
short inout[MAX_VAR_ARRAY_SIZE]; void AddVar(int &amp;n,char* v,short
in_out);
};
static int isId(char c)
{ return isalnum(c)||c=='_';
}
static int name_comp(char* n1,char* n2)
{while(*n1!=' '&amp;&amp;*n1!='\0'&amp;&amp;*n2!=' '&amp;&amp;*n2!='\0'){<br>
if(toupper(*n1)!=toupper(*n2))return 0;<br>
++n1;<br>
++n2;<br>
}<br>
if(*n1==' '&amp;&amp;*n2!=' '||*n2==' '&amp;&amp;*n1!=' ')<br>
return 0;<br>
return 1;<br>
} /* name_comp */<br>
  <br>
void HVDArray::AddVar(int &amp;n,char* v,short in_out)<br>
{for(int i=0;i&lt;n;++i)<br>
if(name_comp(hv[i],v))<br>
return;<br>
hv[n]=new char[strlen(v)+1];<br>
strcpy(hv[n],v);<br>
inout[n]=in_out;<br>
hv[++n]=0;<br>
inout[n]=def;<br>
}<br>
  <br>
HVDArray::HVDArray(char* stm)<br>
{int i=0; <br>
short InStr=0;<br>
char *c=stm;<br>
  <br>
hv[i]=0;<br>
while(*c){<br>
if(*c=='\''){<br>
if(!InStr)<br>
InStr=1;<br>
else{<br>
if(c[1]=='\'')<br>
++c;<br>
else<br>
InStr=0; <br>
}<br>
}<br>
if(*c==':'&amp;&amp;!InStr){<br>
short in_out=in;<br>
char var[64];<br>
char* v=var;<br>
*v++=*c++;<br>
while(isId(*c))<br>
*v++=*c++;<br>
while(isspace(*c))<br>
++c;<br>
if(*c=='&lt;'){<br>
*c=' ';<br>
while(*c!='&gt;'&amp;&amp;*c!=','&amp;&amp;*c){<br>
*v++=*c;<br>
*c++=' ';<br>
}<br>
if(*c==','){<br>
*c++=' ';<br>
if(toupper(*c)=='I'){<br>
if(toupper(c[2])=='O')<br>
in_out=io;<br>
else<br>
in_out=in;<br>
}else if(toupper(*c)=='O')<br>
in_out=out;<br>
while(*c!='&gt;'&amp;&amp;*c)<br>
*c++=' ';<br>
}<br>
*c=' ';<br>
*v='\0';<br>
AddVar(i,var,in_out);<br>
}<br>
}<br>
++c;<br>
}<br>
}<br>
  <br>
HVDArray::~HVDArray()<br>
{<br>
for(int i=0;hv[i]!=0;++i)<br>
delete hv[i];<br>
}<br>
  <br>
int cstr_arr[MAX_VAR_ARRAY_SIZE];<br>
int ca_len=0;<br>
  <br>
void AddToCStrArr(int size)<br>
{<br>
for(int i=0;i&lt;ca_len;++i)<br>
if(cstr_arr[i]==size)<br>
return;<br>
++ca_len;<br>
cstr_arr[ca_len-1]=size;<br>
}<br>
  <br>
char* ST(int size,char* Prefix,int type_prefix_on=0)<br>
{static char C[128];<br>
if(stflag)<br>
sprintf(C,"%s",sttype);<br>
else{<br>
if(type_prefix_on)<br>
sprintf(C,"tCSTR_%d_%s",size,Prefix);<br>
else<br>
sprintf(C,"CSTR_%d_%s",size,Prefix);<br>
}<br>
return C;<br>
}<br>
  <br>
void GetCharDecl(char* s,char* name,int&amp; size,char&amp; type)<br>
{<br>
char *c=name,*c1=s;<br>
  <br>
while(*c1!=' '&amp;&amp;*c1)<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' '&amp;&amp;*c1)<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='['&amp;&amp;*c1)<br>
++c1;<br>
++c1;<br>
while(*c1!=']'&amp;&amp;*c1)<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
}<br>
  <br>
int DeclareHostVar(char* s,short VectSize, char* Prefix,int write)<br>
{char name[64];<br>
char type;<br>
sword size=0;<br>
  <br>
GetCharDecl(s,name,size,type);<br>
switch(type){<br>
case 'C':<br>
if(write){<br>
outf&lt;&lt;" "&lt;&lt;ST(size,Prefix)&lt;&lt;"
"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
case 'D':<br>
if(write){<br>
outf&lt;&lt;" double
"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
case 'F':<br>
if(write){<br>
outf&lt;&lt;" float
"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
case 'I':<br>
if(write){<br>
outf&lt;&lt;" int "&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
case 'U':<br>
if(write){<br>
outf&lt;&lt;" unsigned
"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
case 'S':<br>
if(write){<br>
outf&lt;&lt;" short
"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
case 'L':<br>
if(write){<br>
outf&lt;&lt;" long
"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix;<br>
if(VectSize==1)<br>
outf&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"["&lt;&lt;VectSize&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,s);<br>
Error(errmsg);<br>
}<br>
}<br>
return size;<br>
}<br>
  <br>
int DeclareTempHostVar(char* s,short VectSize, char* Prefix)<br>
{char name[64];<br>
char type;<br>
sword size=0;<br>
  <br>
GetCharDecl(s,name,size,type);<br>
switch(type){<br>
case 'C':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_cstring&lt;"&lt;&lt;size&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static
otl_cstring_array&lt;"&lt;&lt;VectSize&lt;&lt;","&lt;&lt;size&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
case 'D':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_double
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static otl_double_array&lt;"&lt;&lt;VectSize&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
case 'F':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_float
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static otl_float_array&lt;"&lt;&lt;VectSize&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
case 'I':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_int
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static otl_int_array&lt;"&lt;&lt;VectSize&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
case 'U':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_unsigned
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static otl_unsigned_array&lt;"&lt;&lt;VectSize&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
case 'S':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_short_int
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static otl_short_int_array&lt;"&lt;&lt;VectSize&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
case 'L':<br>
if(VectSize==1)<br>
cm&lt;&lt;"static otl_long_int
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"static otl_long_int_array&lt;"&lt;&lt;VectSize&lt;&lt;"&gt;
*"&lt;&lt;(char*)&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,s);<br>
Error(errmsg);<br>
}<br>
}<br>
return size;<br>
}<br>
  <br>
  <br>
  <br>
void WriteTempInputVar(char* s, char* Prefix)<br>
{char name[64];<br>
char type;<br>
sword size=0;<br>
  <br>
GetCharDecl(s,name,size,type);<br>
  <br>
cm&lt;&lt;"
(*cur_"&lt;&lt;Prefix&lt;&lt;")&lt;&lt;"&lt;&lt;(char*)&amp;name[1]&lt;&lt;";"&lt;&lt;endl;<br>
}<br>
  <br>
  <br>
void ReplaceVarName(char* stm, char* outstm, char* Prefix)<br>
{short InStr=0;<br>
char *c=stm;<br>
char *c1=outstm;<br>
  <br>
while(*c){<br>
if(*c=='\''){<br>
if(!InStr)<br>
InStr=1;<br>
else{<br>
if(c[1]=='\''){<br>
*c1=*c;<br>
++c; ++c1;<br>
}else<br>
InStr=0; <br>
}<br>
}<br>
if(*c==':'&amp;&amp;!InStr&amp;&amp;isId(c[1])){<br>
*c1=*c;<br>
++c; ++c1;<br>
while(isId(*c)){<br>
*c1=*c;<br>
++c; ++c1;<br>
}<br>
*c1='_';<br>
++c1;<br>
char *c2=Prefix;<br>
while(*c2){<br>
*c1=*c2;<br>
++c1; ++c2;<br>
}<br>
}<br>
*c1=*c;<br>
++c; ++c1;<br>
}<br>
*c1=0;<br>
}<br>
  <br>
void CompressBlank(char* instm, char* outstm)<br>
{ <br>
char* c=instm;<br>
char* c1=outstm;<br>
while(*c){<br>
*c1++=*c;<br>
if(*c==' '){<br>
while(*c==' '&amp;&amp;*c!=0)<br>
++c;<br>
}else<br>
++c;<br>
}<br>
*c1=0;<br>
}<br>
  <br>
void OpenFuncPrototype(HVDArray&amp; hvd,char* Prefix, fstream&amp;
f,char* fname)<br>
{<br>
  <br>
f&lt;&lt;"void "&lt;&lt;Prefix&lt;&lt;fname&lt;&lt;"(";<br>
if(!hvd[0]){<br>
f&lt;&lt;"void)";<br>
return;<br>
}else<br>
f&lt;&lt;endl;<br>
  <br>
int i=0;<br>
while(hvd[i]){<br>
  <br>
char name[64];<br>
char type;<br>
sword size=0;<br>
char *c=name,*c1=hvd[i];<br>
  <br>
while(*c1!=' ')<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' ')<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='[')<br>
++c1;<br>
++c1;<br>
while(*c1!=']')<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
switch(type){<br>
case 'C':<br>
f&lt;&lt;" char* "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'D':<br>
f&lt;&lt;" double "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'F':<br>
f&lt;&lt;" float "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'I':<br>
f&lt;&lt;" int "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'U':<br>
f&lt;&lt;" unsigned "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'S':<br>
f&lt;&lt;" short "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'L':<br>
f&lt;&lt;" long "&lt;&lt;&amp;name[1];<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,hvd[i]);<br>
Error(errmsg);<br>
}<br>
}<br>
if(hvd[i+1])f&lt;&lt;",";<br>
f&lt;&lt;endl;<br>
  <br>
++i;<br>
}<br>
f&lt;&lt;")";<br>
}<br>
  <br>
void AssignInputVar(HVDArray&amp; hvd,char* Prefix,int ArrSize,int
plsql=0)<br>
{<br>
if(!hvd[0])return;<br>
  <br>
int i=0;<br>
while(hvd[i]){<br>
  <br>
char name[64];<br>
char type;<br>
sword size=0;<br>
char *c=name,*c1=hvd[i];<br>
  <br>
while(*c1!=' ')<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' ')<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='[')<br>
++c1;<br>
++c1;<br>
while(*c1!=']')<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
if(plsql){<br>
if(hvd.inout[i]==HVDArray::in||hvd.inout[i]==HVDArray::io){<br>
switch(type){<br>
case 'C':<br>
outf&lt;&lt;"
strcpy("&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;","&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'D':<br>
case 'F':<br>
case 'I':<br>
case 'U':<br>
case 'S':<br>
case 'L':<br>
if(hvd.inout[i]==HVDArray::in)<br>
outf&lt;&lt;"
"&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;"="&lt;&lt;&amp;name[1]&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"
"&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;"=*"&lt;&lt;&amp;name[1]&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,hvd[i]);<br>
Error(errmsg);<br>
}<br>
}<br>
}<br>
  <br>
}else{<br>
  <br>
switch(type){<br>
case 'C':<br>
if(ArrSize==1)<br>
outf&lt;&lt;"
strcpy("&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;","&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"
strcpy((char*)&amp;"&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[n_"&lt;&lt;Prefix&lt;&lt;"-1],"&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'D':<br>
case 'F':<br>
case 'I':<br>
case 'U':<br>
case 'S':<br>
case 'L':<br>
if(ArrSize==1)<br>
outf&lt;&lt;"
"&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;"="&lt;&lt;&amp;name[1]&lt;&lt;";"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;"
"&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;"[n_"&lt;&lt;Prefix&lt;&lt;"-1]"<br>
&lt;&lt;"="&lt;&lt;&amp;name[1]&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,hvd[i]);<br>
Error(errmsg);<br>
}<br>
}<br>
  <br>
}<br>
  <br>
++i;<br>
}<br>
outf&lt;&lt;endl;<br>
}<br>
  <br>
void AssignStackInputVar(HVDArray&amp; hvd,char* Prefix)<br>
{<br>
if(!hvd[0])return;<br>
  <br>
int i=0;<br>
while(hvd[i]){<br>
  <br>
char name[64];<br>
char type;<br>
sword size=0;<br>
char *c=name,*c1=hvd[i];<br>
  <br>
while(*c1!=' ')<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' ')<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='[')<br>
++c1;<br>
++c1;<br>
while(*c1!=']')<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
cm&lt;&lt;"
(*str_"&lt;&lt;Prefix&lt;&lt;")&lt;&lt;"&lt;&lt;&amp;name[1]&lt;&lt;";"&lt;&lt;endl;<br>
  <br>
++i;<br>
}<br>
cm&lt;&lt;endl;<br>
}<br>
  <br>
  <br>
void AssignOutputVar(HVDArray&amp; hvd,char* Prefix)<br>
{<br>
if(!hvd[0])return;<br>
  <br>
outf&lt;&lt;endl;<br>
int i=0;<br>
while(hvd[i]){<br>
  <br>
char name[64];<br>
char type;<br>
sword size=0;<br>
char *c=name,*c1=hvd[i];<br>
  <br>
while(*c1!=' ')<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' ')<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='[')<br>
++c1;<br>
++c1;<br>
while(*c1!=']')<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
if(hvd.inout[i]!=HVDArray::in){<br>
switch(type){<br>
case 'C':<br>
outf&lt;&lt;"
strcpy("&lt;&lt;&amp;name[1]&lt;&lt;","&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'D':<br>
case 'F':<br>
case 'I':<br>
case 'U':<br>
case 'S':<br>
case 'L':<br>
outf&lt;&lt;"
*"&lt;&lt;&amp;name[1]&lt;&lt;"="&lt;&lt;&amp;name[1]&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,hvd[i]);<br>
Error(errmsg);<br>
}<br>
}<br>
}<br>
  <br>
++i;<br>
}<br>
outf&lt;&lt;endl;<br>
}<br>
  <br>
void ReplaceEoln(char* stm,char* outstm)<br>
{<br>
char* c=stm;<br>
char* c1=outstm;<br>
  <br>
while(*c){<br>
if(*c=='\n'){<br>
if(c[1]==0||c[1]==' ')<br>
++c;<br>
else{<br>
*c1=' ';<br>
++c; ++c1;<br>
}<br>
}else{<br>
*c1=*c;<br>
++c; ++c1;<br>
}<br>
}<br>
*c1=0;<br>
} /* ReplaceEoln */<br>
  <br>
int int2ext(int int_type)<br>
{<br>
switch(int_type){<br>
case inVarChar2: return extCChar;<br>
case inNumber: return extFloat;<br>
case inLong: return extCChar; <br>
case inRowId: return extCChar; <br>
case inDate: return extCChar; <br>
case inRaw: return extCChar; <br>
case inLongRaw: return extCChar; <br>
case inChar: return extCChar;<br>
default:<br>
return -1;<br>
}<br>
}<br>
  <br>
int datatype_size(int ftype,int maxsz,int int_type)<br>
{<br>
switch(ftype){<br>
case extCChar:<br>
switch(int_type){<br>
case inRowId:<br>
return sizeof(otl_cchar_rowid);<br>
case inDate:<br>
return 10; // e.g. 19-JAN-64 + '\0'<br>
case inLong:<br>
case inLongRaw:<br>
return otl_max_long_size;<br>
case inRaw:<br>
return maxsz*2+1;<br>
default:<br>
return maxsz+1;<br>
}<br>
case extFloat: <br>
return sizeof(double);<br>
case extDate: <br>
return sizeof(otl_date_intern);<br>
default:<br>
return 0;<br>
}<br>
}<br>
  <br>
void map_ftype(const otl_column_desc&amp; desc, <br>
int&amp; ftype, <br>
int&amp; elem_size)<br>
{<br>
ftype=int2ext(desc.dbtype);<br>
elem_size=datatype_size(ftype,desc.dbsize,desc.dbtype);<br>
}<br>
  <br>
int isId(char* s)<br>
{<br>
while(*s){<br>
if(!isId(*s))<br>
return 0;<br>
++s;<br>
}<br>
return 1;<br>
} /* isId */<br>
  <br>
void generate_select_list_struct(otl_select_stream&amp; selstr,char*
Prefix)<br>
{<br>
int ftype,elem_size;<br>
  <br>
hf&lt;&lt;endl;<br>
hf&lt;&lt;"struct
struct_"&lt;&lt;Prefix&lt;&lt;"{"&lt;&lt;endl&lt;&lt;endl;<br>
for(int j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
switch(ftype){<br>
case extCChar:<br>
if(id_flag){<br>
hf&lt;&lt;" char
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"["&lt;&lt;elem_size&lt;&lt;"];"&lt;&lt;endl;<br>
hf&lt;&lt;" short
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}else{<br>
hf&lt;&lt;" char F"&lt;&lt;j+1&lt;&lt;"["&lt;&lt;elem_size&lt;&lt;"];/*
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;" */"&lt;&lt;endl;<br>
hf&lt;&lt;" short F"&lt;&lt;j+1&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
break;<br>
case extFloat:<br>
if(id_flag){<br>
hf&lt;&lt;" double
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;";"&lt;&lt;endl;<br>
hf&lt;&lt;" short
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}else{<br>
hf&lt;&lt;" double F"&lt;&lt;j+1&lt;&lt;";/*
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;" */"&lt;&lt;endl;<br>
hf&lt;&lt;" short F"&lt;&lt;j+1&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
break;<br>
}<br>
}<br>
hf&lt;&lt;"};"&lt;&lt;endl;<br>
hf&lt;&lt;"typedef struct struct_"&lt;&lt;Prefix&lt;&lt;"
"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
void GetFuncBody1(otl_select_stream&amp; selstr,char* Prefix)<br>
{<br>
int ftype,elem_size,sz,j;<br>
  <br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;"int "&lt;&lt;Prefix&lt;&lt;"_get("&lt;&lt;Prefix&lt;&lt;"*
out)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
  <br>
ca_len=0;<br>
  <br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
if(ftype==extCChar){<br>
sz=elem_size;<br>
AddToCStrArr(sz);<br>
}<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
for(j=0;j&lt;ca_len;++j){<br>
if(!stflag)<br>
outf&lt;&lt;" typedef char tCSTR_"&lt;&lt;cstr_arr[j]&lt;&lt;"_"<br>
&lt;&lt;Prefix&lt;&lt;"["&lt;&lt;cstr_arr[j]&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;" EXEC SQL BEGIN DECLARE SECTION;"&lt;&lt;endl;<br>
  <br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
for(j=0;j&lt;ca_len;++j){<br>
if(!stflag)<br>
outf&lt;&lt;" EXEC SQL TYPE tCSTR_"&lt;&lt;cstr_arr[j]&lt;&lt;"_"<br>
&lt;&lt;stmName&lt;&lt;" IS
STRING("&lt;&lt;cstr_arr[j]&lt;&lt;");"&lt;&lt;endl;<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
  <br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
switch(ftype){<br>
case extCChar:<br>
if(id_flag){<br>
outf&lt;&lt;" "&lt;&lt;ST(elem_size,Prefix,1)&lt;&lt;"
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" short
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;" "&lt;&lt;ST(elem_size,Prefix,1)&lt;&lt;"
F"&lt;&lt;j+1&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" short
F"&lt;&lt;j+1&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
break;<br>
case extFloat:<br>
if(id_flag){<br>
outf&lt;&lt;" double
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" short
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;" double F"&lt;&lt;j+1&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" short
F"&lt;&lt;j+1&lt;&lt;"_IND;"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
break;<br>
}<br>
}<br>
outf&lt;&lt;endl&lt;&lt;" EXEC SQL END DECLARE
SECTION;"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;" do{"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL FETCH "&lt;&lt;Prefix&lt;&lt;"_cur
INTO"&lt;&lt;endl;<br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
if(id_flag)<br>
outf&lt;&lt;"
:"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;":"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND";<br>
else<br>
outf&lt;&lt;" :F"&lt;&lt;j+1&lt;&lt;":F"&lt;&lt;j+1&lt;&lt;"_IND";<br>
if(j&lt;selstr.select_list_len()-1)<br>
outf&lt;&lt;",";<br>
else<br>
outf&lt;&lt;";";<br>
outf&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;endl;<br>
  <br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
switch(ftype){<br>
case extCChar:<br>
if(id_flag){<br>
outf&lt;&lt;" strcpy(out-&gt;"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;","<br>
&lt;&lt;selstr.sl_desc[j].name&lt;&lt;");"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;" strcpy(out-&gt;F"&lt;&lt;j+1&lt;&lt;","<br>
&lt;&lt;"F"&lt;&lt;j+1&lt;&lt;");"&lt;&lt;endl;<br>
}<br>
break;<br>
case extFloat:<br>
if(id_flag){<br>
outf&lt;&lt;" out-&gt;"&lt;&lt;selstr.sl_desc[j].name<br>
&lt;&lt;"="&lt;&lt;selstr.sl_desc[j].name&lt;&lt;";"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;"
out-&gt;F"&lt;&lt;j+1&lt;&lt;"=F"&lt;&lt;j+1&lt;&lt;";"&lt;&lt;endl;<br>
}<br>
break;<br>
}<br>
if(id_flag){<br>
outf&lt;&lt;" out-&gt;"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND"<br>
&lt;&lt;"="&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND;"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;"
out-&gt;F"&lt;&lt;j+1&lt;&lt;"_IND=F"&lt;&lt;j+1&lt;&lt;"_IND;"&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;" }while(0);"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;" return sqlca.sqlcode;"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
  <br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
void GetTempFuncBody(otl_select_stream&amp; selstr,char* Prefix)<br>
{<br>
int ftype,elem_size,sz,j;<br>
  <br>
cm&lt;&lt;endl;<br>
cm&lt;&lt;"int "&lt;&lt;Prefix&lt;&lt;"_get("&lt;&lt;Prefix&lt;&lt;"*
out)"&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" if(str_"&lt;&lt;Prefix&lt;&lt;"-&gt;eof())return
1;"&lt;&lt;endl;<br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
if(id_flag){<br>
cm&lt;&lt;"
(*str_"&lt;&lt;Prefix&lt;&lt;")&gt;&gt;out-&gt;"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;";"&lt;&lt;endl;<br>
}else{<br>
cm&lt;&lt;" (*str_"&lt;&lt;Prefix&lt;&lt;")&gt;&gt;out-&gt;F"&lt;&lt;j+1&lt;&lt;";"&lt;&lt;endl;<br>
}<br>
}<br>
cm&lt;&lt;endl;<br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
if(id_flag){<br>
cm&lt;&lt;" out-&gt;"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND=str_"<br>
&lt;&lt;Prefix&lt;&lt;"-&gt;is_null()?-1:0;"&lt;&lt;endl;<br>
}else{<br>
cm&lt;&lt;" out-&gt;F"&lt;&lt;j+1&lt;&lt;"_IND=str_"<br>
&lt;&lt;Prefix&lt;&lt;"-&gt;is_null()?-1:0;"&lt;&lt;endl;<br>
}<br>
}<br>
cm&lt;&lt;endl;<br>
cm&lt;&lt;" return 0;"&lt;&lt;endl;<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
void GetFuncN(otl_select_stream&amp; selstr,char* Prefix,short ArrSize)<br>
{<br>
int ftype,elem_size,sz,j;<br>
  <br>
outf&lt;&lt;endl;<br>
  <br>
ca_len=0;<br>
  <br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
if(ftype==extCChar){<br>
sz=elem_size;<br>
AddToCStrArr(sz);<br>
}<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
for(j=0;j&lt;ca_len;++j){<br>
if(!stflag)<br>
outf&lt;&lt;"typedef char tCSTR_"&lt;&lt;cstr_arr[j]&lt;&lt;"_"<br>
&lt;&lt;Prefix&lt;&lt;"["&lt;&lt;cstr_arr[j]&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;"EXEC SQL BEGIN DECLARE SECTION;"&lt;&lt;endl;<br>
  <br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
for(j=0;j&lt;ca_len;++j){<br>
if(!stflag)<br>
outf&lt;&lt;" EXEC SQL TYPE tCSTR_"&lt;&lt;cstr_arr[j]&lt;&lt;"_"<br>
&lt;&lt;stmName&lt;&lt;" IS
STRING("&lt;&lt;cstr_arr[j]&lt;&lt;");"&lt;&lt;endl;<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;" int
row_fetch_count_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" int cur_row_pos_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" long rpc_save_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" int end_of_data_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;endl;<br>
  <br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
switch(ftype){<br>
case extCChar:<br>
if(id_flag)<br>
outf&lt;&lt;" "&lt;&lt;ST(elem_size,Prefix,1)&lt;&lt;"
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"["&lt;&lt;ArrSize&lt;&lt;"];"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;" "&lt;&lt;ST(elem_size,Prefix,1)&lt;&lt;"
F"&lt;&lt;j+1&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"["&lt;&lt;ArrSize&lt;&lt;"];"&lt;&lt;endl;<br>
break;<br>
case extFloat:<br>
if(id_flag)<br>
outf&lt;&lt;" double
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"["&lt;&lt;ArrSize&lt;&lt;"];"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;" double
F"&lt;&lt;j+1&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;"["&lt;&lt;ArrSize&lt;&lt;"];"&lt;&lt;endl;<br>
break;<br>
}<br>
if(id_flag)<br>
outf&lt;&lt;" short
"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND_"&lt;&lt;Prefix<br>
&lt;&lt;"["&lt;&lt;ArrSize&lt;&lt;"];"&lt;&lt;endl;<br>
else<br>
outf&lt;&lt;" short
F"&lt;&lt;j+1&lt;&lt;"_IND_"&lt;&lt;Prefix&lt;&lt;"["&lt;&lt;ArrSize&lt;&lt;"];"&lt;&lt;endl;<br>
outf&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;endl&lt;&lt;"EXEC SQL END DECLARE
SECTION;"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
  <br>
outf&lt;&lt;"int "&lt;&lt;Prefix&lt;&lt;"_get("&lt;&lt;Prefix&lt;&lt;"*
out)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" if(count_"&lt;&lt;Prefix&lt;&lt;"==0){"&lt;&lt;endl;<br>
outf&lt;&lt;" ++count_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" row_fetch_count_"&lt;&lt;Prefix&lt;&lt;"=0;"&lt;&lt;endl;<br>
outf&lt;&lt;" cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"=0;"&lt;&lt;endl;<br>
outf&lt;&lt;" end_of_data_"&lt;&lt;Prefix&lt;&lt;"=0;"&lt;&lt;endl;<br>
outf&lt;&lt;" }"&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;" do{"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;"
if(row_fetch_count_"&lt;&lt;Prefix&lt;&lt;"==0){"&lt;&lt;endl;<br>
outf&lt;&lt;" if(end_of_data_"&lt;&lt;Prefix&lt;&lt;")return
1;"&lt;&lt;endl;<br>
outf&lt;&lt;"
rpc_save_"&lt;&lt;Prefix&lt;&lt;"=sqlca.sqlerrd[2];"&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL WHENEVER NOT FOUND goto
"&lt;&lt;Prefix&lt;&lt;"_breakloop;"&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL FETCH "&lt;&lt;Prefix&lt;&lt;"_cur
INTO"&lt;&lt;endl;<br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
if(id_flag)<br>
outf&lt;&lt;" :"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;":"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND_"&lt;&lt;Prefix;<br>
else<br>
outf&lt;&lt;"
:F"&lt;&lt;j+1&lt;&lt;"_"&lt;&lt;Prefix&lt;&lt;":F"&lt;&lt;j+1&lt;&lt;"_IND_"&lt;&lt;Prefix;<br>
if(j&lt;selstr.select_list_len()-1)<br>
outf&lt;&lt;",";<br>
else<br>
outf&lt;&lt;";";<br>
outf&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;" goto
"&lt;&lt;Prefix&lt;&lt;"_skip;"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;"
"&lt;&lt;Prefix&lt;&lt;"_breakloop:"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;"
if(sqlca.sqlerrd[2]-rpc_save_"&lt;&lt;Prefix&lt;&lt;"==0)return
1;"&lt;&lt;endl;<br>
outf&lt;&lt;" end_of_data_"&lt;&lt;Prefix&lt;&lt;"=1;"&lt;&lt;endl;<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;" "&lt;&lt;Prefix&lt;&lt;"_skip:"&lt;&lt;endl;<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;"
row_fetch_count_"&lt;&lt;Prefix&lt;&lt;"=sqlca.sqlerrd[2]-rpc_save_"&lt;&lt;Prefix&lt;&lt;";"<br>
&lt;&lt;endl;<br>
outf&lt;&lt;" cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"=0;"&lt;&lt;endl;<br>
outf&lt;&lt;" }"&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;endl;<br>
  <br>
for(j=0;j&lt;selstr.select_list_len();++j){<br>
map_ftype(selstr.sl_desc[j],ftype,elem_size);<br>
int id_flag=isId((char*)selstr.sl_desc[j].name);<br>
switch(ftype){<br>
case extCChar:<br>
if(id_flag){<br>
outf&lt;&lt;"
strcpy(out-&gt;"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;",(char*)&amp;"<br>
&lt;&lt;selstr.sl_desc[j].name<br>
&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"]);"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;" strcpy(out-&gt;F"&lt;&lt;j+1&lt;&lt;",(char*)&amp;"<br>
&lt;&lt;"F"&lt;&lt;j+1<br>
&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"]);"&lt;&lt;endl;<br>
}<br>
break;<br>
case extFloat:<br>
if(id_flag){<br>
outf&lt;&lt;" out-&gt;"&lt;&lt;selstr.sl_desc[j].name<br>
&lt;&lt;"="&lt;&lt;selstr.sl_desc[j].name<br>
&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"];"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;" out-&gt;F"&lt;&lt;j+1&lt;&lt;"=F"&lt;&lt;j+1<br>
&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
break;<br>
}<br>
if(id_flag){<br>
outf&lt;&lt;" out-&gt;"&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND"<br>
&lt;&lt;"="&lt;&lt;selstr.sl_desc[j].name&lt;&lt;"_IND"<br>
&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"];"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;"
out-&gt;F"&lt;&lt;j+1&lt;&lt;"_IND=F"&lt;&lt;j+1&lt;&lt;"_IND"<br>
&lt;&lt;"_"&lt;&lt;Prefix<br>
&lt;&lt;"[cur_row_pos_"&lt;&lt;Prefix&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;" ++cur_row_pos_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;" --row_fetch_count_"&lt;&lt;Prefix&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;" }while(0);"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;" return 0;"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
void PrintfStmOffs(char* stm,char* offs)<br>
{<br>
char* c=stm;<br>
while(*c){<br>
if(*c=='\n'&amp;&amp;c[1]!=0){<br>
outf&lt;&lt;endl&lt;&lt;offs;<br>
}else<br>
outf&lt;&lt;*c;<br>
++c;<br>
}<br>
}<br>
  <br>
void PrintStm(char* stm,int no_new_line=0)<br>
{<br>
char* c=stm;<br>
if(!no_new_line)<br>
cm&lt;&lt;endl;<br>
cm&lt;&lt;" \"";<br>
while(*c){<br>
if(*c=='\n'&amp;&amp;c[1]!=0){<br>
cm&lt;&lt;" \""&lt;&lt;endl&lt;&lt;" \"";<br>
}else if(*c=='\n'&amp;&amp;c[1]==0){<br>
if(!no_new_line)<br>
cm&lt;&lt;"\","&lt;&lt;endl;<br>
else<br>
cm&lt;&lt;"\""&lt;&lt;endl;<br>
}else<br>
cm&lt;&lt;*c;<br>
++c;<br>
}<br>
if(!no_new_line)<br>
cm&lt;&lt;endl;<br>
}<br>
  <br>
void ExecFuncPrototype(HVDArray&amp; hvd,char* Prefix, fstream&amp; f)<br>
{<br>
  <br>
f&lt;&lt;"void "&lt;&lt;Prefix&lt;&lt;"_exec(";<br>
if(!hvd[0]){<br>
f&lt;&lt;"void)";<br>
return;<br>
}else<br>
f&lt;&lt;endl;<br>
  <br>
int i=0;<br>
while(hvd[i]){<br>
  <br>
char name[64];<br>
char type;<br>
sword size=0;<br>
char *c=name,*c1=hvd[i];<br>
  <br>
while(*c1!=' ')<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' ')<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='[')<br>
++c1;<br>
++c1;<br>
while(*c1!=']')<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
switch(type){<br>
case 'C':<br>
f&lt;&lt;" char* "&lt;&lt;&amp;name[1];<br>
break;<br>
case 'D':<br>
f&lt;&lt;" double"&lt;&lt;(hvd.inout[i]!=HVDArray::in?"* ":"
")&lt;&lt;&amp;name[1];<br>
break;<br>
case 'F':<br>
f&lt;&lt;" float"&lt;&lt;(hvd.inout[i]!=HVDArray::in?"* ":"
")&lt;&lt;&amp;name[1];<br>
break;<br>
case 'I':<br>
f&lt;&lt;" int"&lt;&lt;(hvd.inout[i]!=HVDArray::in?"* ":"
")&lt;&lt;&amp;name[1];<br>
break;<br>
case 'U':<br>
f&lt;&lt;" unsigned"&lt;&lt;(hvd.inout[i]!=HVDArray::in?"* ":"
")&lt;&lt;&amp;name[1];<br>
break;<br>
case 'S':<br>
f&lt;&lt;" short"&lt;&lt;(hvd.inout[i]!=HVDArray::in?"* ":"
")&lt;&lt;&amp;name[1];<br>
break;<br>
case 'L':<br>
f&lt;&lt;" long"&lt;&lt;(hvd.inout[i]!=HVDArray::in?"* ":"
")&lt;&lt;&amp;name[1];<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,hvd[i]);<br>
Error(errmsg);<br>
}<br>
}<br>
if(hvd[i+1])f&lt;&lt;",";<br>
f&lt;&lt;endl;<br>
  <br>
++i;<br>
}<br>
f&lt;&lt;")";<br>
}<br>
  <br>
void BindHostVarList(HVDArray&amp; hvd, fstream&amp; f)<br>
{<br>
  <br>
int i=0;<br>
while(hvd[i]){<br>
  <br>
char name[64];<br>
char type;<br>
sword size=0;<br>
char *c=name,*c1=hvd[i];<br>
  <br>
while(*c1!=' ')<br>
*c++=*c1++;<br>
*c='\0';<br>
while(*c1==' ')<br>
++c1;<br>
type=toupper(*c1);<br>
if(type=='C'){<br>
char tmp[32];<br>
char *t=tmp;<br>
while(*c1!='[')<br>
++c1;<br>
++c1;<br>
while(*c1!=']')<br>
*t++=*c1++;<br>
*t='\0';<br>
size=atoi(tmp);<br>
}<br>
  <br>
switch(type){<br>
case 'C':<br>
f&lt;&lt;"
hotcur.bind_cstring(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;&amp;name[1]&lt;&lt;","&lt;&lt;size&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'D':<br>
f&lt;&lt;"
hotcur.bind_double(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;(hvd.inout[i]==HVDArray::in?"&amp;":"")<br>
&lt;&lt;&amp;name[1]&lt;&lt;","&lt;&lt;size&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'F':<br>
f&lt;&lt;"
hotcur.bind_float(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;(hvd.inout[i]==HVDArray::in?"&amp;":"")<br>
&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'I':<br>
f&lt;&lt;"
hotcur.bind_int(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;(hvd.inout[i]==HVDArray::in?"&amp;":"")<br>
&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'U':<br>
f&lt;&lt;"
hotcur.bind_unsigned(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;(hvd.inout[i]==HVDArray::in?"&amp;":"")<br>
&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'S':<br>
f&lt;&lt;"
hotcur.bind_short(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;(hvd.inout[i]==HVDArray::in?"&amp;":"")<br>
&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
case 'L':<br>
f&lt;&lt;"
hotcur.bind_long_int(\""&lt;&lt;name&lt;&lt;"\","&lt;&lt;(hvd.inout[i]==HVDArray::in?"&amp;":"")<br>
&lt;&lt;&amp;name[1]&lt;&lt;");"&lt;&lt;endl;<br>
break;<br>
default:<br>
{<br>
char errmsg[128];<br>
strcpy(errmsg,"PPC: Invalid variable ==&gt; ");<br>
strcat(errmsg,hvd[i]);<br>
Error(errmsg);<br>
}<br>
}<br>
++i;<br>
}<br>
}<br>
  <br>
void CreateDefines(char* Name,int ArrSize,char* Stm)<br>
{<br>
char* c=Stm;<br>
hf1&lt;&lt;"#define "&lt;&lt;Name&lt;&lt;"_stm \" \\"&lt;&lt;endl;<br>
while(*c){<br>
if(*c=='\n'&amp;&amp;c[1]!=0)<br>
hf1&lt;&lt;" \\"&lt;&lt;endl;<br>
else if(*c!='\n')<br>
hf1&lt;&lt;*c;<br>
++c;<br>
}<br>
hf1&lt;&lt;"\""&lt;&lt;endl;<br>
hf1&lt;&lt;"#define "&lt;&lt;Name&lt;&lt;"_size
"&lt;&lt;ArrSize&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
static char stm2[16000];<br>
  <br>
void GetStm(int select_stm_flag,int plsql_flag=0,int StrTypeDir=0)<br>
{<br>
char* c=buf;<br>
char* n=stmName;<br>
char tmp[64];<br>
char* c1=tmp;<br>
  <br>
while(*c!='&lt;'&amp;&amp;*c!=0)<br>
++c;<br>
if(*c==0)Error("PPC: &lt; is missing");<br>
++c;<br>
*n=0;<br>
while(*c!=','&amp;&amp;*c!=0)<br>
*n++=*c++;<br>
if(*c==0)Error("PPC: , is missing");<br>
++c;<br>
*n=0;<br>
while(*c!='&gt;'&amp;&amp;*c!=0)<br>
*c1++=*c++;<br>
if(*c==0)Error("PPC: &gt; is missing");<br>
*c1=0;<br>
stmArrSize=atoi(tmp);<br>
stm[0]=0;<br>
if(StrTypeDir){<br>
if(stmArrSize==1){<br>
strcpy(sttype,stmName);<br>
stflag=1;<br>
}else{<br>
strcpy(sttype,"");<br>
stflag=0;<br>
}<br>
return;<br>
}<br>
while(!inf.eof()&amp;&amp;strncmp("##",buf,2)!=0){<br>
GetLine();<br>
if(strncmp("##",buf,2)!=0){<br>
strcat(stm,buf);<br>
strcat(stm,"\n");<br>
}<br>
}<br>
if(inf.eof())Error("PPC: ## is missing, EOF encountered");<br>
  <br>
if(hf1flag)<br>
CreateDefines(stmName,stmArrSize,stm);<br>
strcpy(stm2,stm);<br>
  <br>
//
outf&lt;&lt;"&lt;"&lt;&lt;stmName&lt;&lt;","&lt;&lt;stmArrSize&lt;&lt;"&gt;"&lt;&lt;endl;<br>
outf&lt;&lt;"/* ===================== "&lt;&lt;stmName&lt;&lt;"
======================= */"&lt;&lt;endl;<br>
if(cmflag)<br>
cm&lt;&lt;"/* ===================== "&lt;&lt;stmName&lt;&lt;"
======================= */"&lt;&lt;endl;<br>
char stm_text[16000];<br>
int va_len=0;<br>
strcpy(stm_text,stm);<br>
HVDArray hvd(stm_text);<br>
while(hvd[va_len])++va_len;<br>
  <br>
ca_len=0;<br>
for(int i=0;i&lt;va_len;++i){<br>
// outf&lt;&lt;"Var["&lt;&lt;i&lt;&lt;"]="&lt;&lt;hvd[i];<br>
int sz=DeclareHostVar(hvd[i],stmArrSize,stmName,0);<br>
// outf&lt;&lt;", Sz="&lt;&lt;sz&lt;&lt;endl;<br>
if(sz&gt;0)AddToCStrArr(sz);<br>
}<br>
if(va_len&gt;0){<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
for(int j=0;j&lt;ca_len;++j){<br>
if(!stflag)<br>
outf&lt;&lt;"typedef char CSTR_"&lt;&lt;cstr_arr[j]&lt;&lt;"_"<br>
&lt;&lt;stmName&lt;&lt;"["&lt;&lt;cstr_arr[j]&lt;&lt;"];"&lt;&lt;endl;<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
outf&lt;&lt;"EXEC SQL BEGIN DECLARE SECTION;"&lt;&lt;endl&lt;&lt;endl;<br>
for(int l=0;l&lt;ca_len;++l){<br>
if(!stflag)<br>
outf&lt;&lt;" EXEC SQL TYPE CSTR_"&lt;&lt;cstr_arr[l]&lt;&lt;"_"<br>
&lt;&lt;stmName&lt;&lt;" IS
STRING("&lt;&lt;cstr_arr[l]&lt;&lt;");"&lt;&lt;endl;<br>
}<br>
if(ca_len&gt;0)outf&lt;&lt;endl;<br>
for(int k=0;k&lt;va_len;++k){<br>
DeclareHostVar(hvd[k],select_stm_flag?1:stmArrSize,stmName,1);<br>
// if(cmflag&amp;&amp;!plsql_flag&amp;&amp;!select_stm_flag)<br>
// DeclareTempHostVar(hvd[k],select_stm_flag?1:stmArrSize,stmName);<br>
}<br>
outf&lt;&lt;" int n_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;endl&lt;&lt;"EXEC SQL END DECLARE
SECTION;"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
CompressBlank(stm_text,stm);<br>
strcpy(stm1,stm);<br>
ReplaceVarName(stm,stm_text,stmName);<br>
strcpy(stm,stm_text);<br>
  <br>
if(select_stm_flag){<br>
  <br>
outf&lt;&lt;"EXEC SQL DECLARE "&lt;&lt;stmName&lt;&lt;"_cur CURSOR
FOR"&lt;&lt;endl;<br>
outf&lt;&lt;stm&lt;&lt;endl;<br>
outf&lt;&lt;" ;"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;"long gl_rpc_save_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;"long
count_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl&lt;&lt;endl;<br>
OpenFuncPrototype(hvd,stmName,outf,"_open");<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" count_"&lt;&lt;stmName&lt;&lt;"=0;"&lt;&lt;endl;<br>
AssignInputVar(hvd,stmName,1);<br>
outf&lt;&lt;"
gl_rpc_save_"&lt;&lt;stmName&lt;&lt;"=sqlca.sqlerrd[2];"&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL OPEN "&lt;&lt;stmName&lt;&lt;"_cur;"&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
outf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL CLOSE
"&lt;&lt;stmName&lt;&lt;"_cur;"&lt;&lt;endl;<br>
outf&lt;&lt;"
sqlca.sqlerrd[2]=gl_rpc_save_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
ReplaceEoln(stm,stm_text);<br>
strcpy(stm,stm_text);<br>
  <br>
// outf&lt;&lt;"Stm='"&lt;&lt;stm&lt;&lt;"'"&lt;&lt;endl;<br>
  <br>
otl_select_stream selstr(stm,db,"");<br>
generate_select_list_struct(selstr,stmName);<br>
  <br>
if(cmflag){<br>
cm&lt;&lt;"static otl_stream*
str_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl&lt;&lt;endl;<br>
OpenFuncPrototype(hvd,stmName,cm,"_open");<br>
cm&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" str_"&lt;&lt;stmName&lt;&lt;"=new otl_stream("&lt;&lt;endl;<br>
cm&lt;&lt;" "&lt;&lt;stmArrSize&lt;&lt;","&lt;&lt;endl;<br>
PrintStm(stm2);<br>
cm&lt;&lt;" *db"&lt;&lt;endl;<br>
cm&lt;&lt;" );"&lt;&lt;endl;<br>
AssignStackInputVar(hvd,stmName);<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
cm&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void)"&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" delete str_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl;<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
GetTempFuncBody(selstr,stmName);<br>
  <br>
}<br>
  <br>
OpenFuncPrototype(hvd,stmName,hf,"_open");<br>
hf&lt;&lt;";"&lt;&lt;endl;<br>
hf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void);"&lt;&lt;endl;<br>
hf&lt;&lt;"int "&lt;&lt;stmName&lt;&lt;"_get("&lt;&lt;stmName&lt;&lt;"*
out);"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
if(stmArrSize==1)<br>
GetFuncBody1(selstr,stmName);<br>
else<br>
GetFuncN(selstr,stmName,stmArrSize);<br>
outf&lt;&lt;"EXEC SQL WHENEVER NOT FOUND
CONTINUE;"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
}else if(plsql_flag){<br>
  <br>
ReplaceEoln(stm,stm_text);<br>
otl_cursor cur(db);<br>
cur.parse(stm_text);<br>
  <br>
hf&lt;&lt;endl;<br>
ExecFuncPrototype(hvd,stmName,hf);<br>
hf&lt;&lt;";"&lt;&lt;endl&lt;&lt;endl;<br>
ExecFuncPrototype(hvd,stmName,outf);<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
AssignInputVar(hvd,stmName,1,1);<br>
outf&lt;&lt;" EXEC SQL EXECUTE\n ";<br>
PrintfStmOffs(stm," ");<br>
outf&lt;&lt;" END-EXEC;"&lt;&lt;endl;<br>
AssignOutputVar(hvd,stmName);<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
if(cmflag){<br>
ExecFuncPrototype(hvd,stmName,cm);<br>
cm&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" if(!hotcur.connected)hotcur.open(*db);"&lt;&lt;endl;<br>
cm&lt;&lt;" hotcur.parse("&lt;&lt;endl;<br>
PrintStm(stm1,1);<br>
cm&lt;&lt;" );"&lt;&lt;endl;<br>
BindHostVarList(hvd,cm);<br>
cm&lt;&lt;" hotcur.exec();"&lt;&lt;endl;<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
}<br>
  <br>
}else{<br>
  <br>
ReplaceEoln(stm,stm_text);<br>
otl_cursor cur(db);<br>
cur.parse(stm_text);<br>
  <br>
hf&lt;&lt;endl;<br>
hf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_open(int
auto_commit);"&lt;&lt;endl;<br>
outf&lt;&lt;"int
auto_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_open(int
auto_commit)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" auto_"&lt;&lt;stmName&lt;&lt;"=auto_commit;"&lt;&lt;endl;<br>
outf&lt;&lt;" n_"&lt;&lt;stmName&lt;&lt;"=0;"&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
if(cmflag){<br>
cm&lt;&lt;"static otl_stream*
cur_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl&lt;&lt;endl;<br>
cm&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_open(int
auto_commit)"&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" cur_"&lt;&lt;stmName&lt;&lt;"=new otl_stream("&lt;&lt;endl;<br>
cm&lt;&lt;" "&lt;&lt;stmArrSize&lt;&lt;","&lt;&lt;endl;<br>
PrintStm(stm2);<br>
cm&lt;&lt;" *db"&lt;&lt;endl;<br>
cm&lt;&lt;" );"&lt;&lt;endl;<br>
cm&lt;&lt;"
cur_"&lt;&lt;stmName&lt;&lt;"-&gt;set_commit(auto_commit);"&lt;&lt;endl;<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
OpenFuncPrototype(hvd,stmName,hf,"_put");<br>
hf&lt;&lt;";"&lt;&lt;endl;<br>
OpenFuncPrototype(hvd,stmName,outf,"_put");<br>
outf&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
if(stmArrSize&gt;1)<br>
outf&lt;&lt;" ++n_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl;<br>
AssignInputVar(hvd,stmName,stmArrSize);<br>
if(stmArrSize==1){<br>
outf&lt;&lt; " EXEC SQL\n ";<br>
PrintfStmOffs(stm," ");<br>
outf&lt;&lt;" ;"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;" if(auto_"&lt;&lt;stmName&lt;&lt;") EXEC SQL
COMMIT;"&lt;&lt;endl;<br>
}else{<br>
outf&lt;&lt;"
if(n_"&lt;&lt;stmName&lt;&lt;"=="&lt;&lt;stmArrSize&lt;&lt;")"&lt;&lt;endl;<br>
outf&lt;&lt;" "&lt;&lt;stmName&lt;&lt;"_flush();"&lt;&lt;endl;<br>
outf&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
if(cmflag){<br>
outf&lt;&lt;endl;<br>
OpenFuncPrototype(hvd,stmName,cm,"_put");<br>
cm&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
for( int k3=0;k3&lt;va_len;++k3)<br>
WriteTempInputVar(hvd[k3],stmName);<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
}<br>
  <br>
if(cmflag){<br>
cm&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_flush(void)"&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" cur_"&lt;&lt;stmName&lt;&lt;"-&gt;flush();"&lt;&lt;endl;<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
if(cmflag){<br>
cm&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void)"&lt;&lt;endl;<br>
cm&lt;&lt;"{"&lt;&lt;endl;<br>
cm&lt;&lt;" delete cur_"&lt;&lt;stmName&lt;&lt;";"&lt;&lt;endl;<br>
cm&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
}<br>
  <br>
if(stmArrSize==1){<br>
  <br>
hf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_flush(void);"&lt;&lt;endl;<br>
outf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_flush(void)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" if(auto_"&lt;&lt;stmName&lt;&lt;") EXEC SQL
COMMIT;"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
hf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void);"&lt;&lt;endl;<br>
outf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL COMMIT;"&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
}else{<br>
  <br>
hf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_flush(void);"&lt;&lt;endl;<br>
outf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_flush(void)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;"
if(n_"&lt;&lt;stmName&lt;&lt;"&gt;0){"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;" EXEC SQL FOR :n_"&lt;&lt;stmName&lt;&lt;"\n ";<br>
PrintfStmOffs(stm," ");<br>
outf&lt;&lt;" ;"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;" n_"&lt;&lt;stmName&lt;&lt;"=0;"&lt;&lt;endl;<br>
outf&lt;&lt;" if(auto_"&lt;&lt;stmName&lt;&lt;") EXEC SQL
COMMIT;"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;" }"&lt;&lt;endl&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
hf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void);"&lt;&lt;endl;<br>
outf&lt;&lt;"void "&lt;&lt;stmName&lt;&lt;"_close(void)"&lt;&lt;endl;<br>
outf&lt;&lt;"{"&lt;&lt;endl;<br>
outf&lt;&lt;" "&lt;&lt;stmName&lt;&lt;"_flush();"&lt;&lt;endl;<br>
outf&lt;&lt;"}"&lt;&lt;endl&lt;&lt;endl;<br>
  <br>
}<br>
  <br>
}<br>
  <br>
outf&lt;&lt;"/* =================== End of "&lt;&lt;stmName&lt;&lt;"
===================== */"&lt;&lt;endl;<br>
if(cmflag)<br>
cm&lt;&lt;"/* =================== End of "&lt;&lt;stmName&lt;&lt;"
===================== */"&lt;&lt;endl;<br>
  <br>
} /* GetStm */<br>
  <br>
void SqlSelect(void)<br>
{<br>
++select_count;<br>
GetStm(1);<br>
}<br>
  <br>
void SqlOutStm(void)<br>
{<br>
GetStm(0);<br>
}<br>
  <br>
void SqlPlSql(void)<br>
{<br>
GetStm(0,1);<br>
}<br>
  <br>
void SqlStrType(void)<br>
{<br>
GetStm(0,0,1);<br>
}<br>
  <br>
void ParseLine(void)<br>
{int flag=0;<br>
if(buf[0]!='#'){<br>
outf&lt;&lt;buf&lt;&lt;endl;<br>
if(cmflag)cm&lt;&lt;buf&lt;&lt;endl;<br>
}else{<br>
for(int i=0;i&lt;dir_size;++i){<br>
int rc=strncmp(directive[i],buf,strlen(directive[i]));<br>
if(rc==0){<br>
// cout&lt;&lt;"Buf='"&lt;&lt;buf&lt;&lt;"', RC="&lt;&lt;rc&lt;&lt;",
Dir="&lt;&lt;i&lt;&lt;endl;<br>
switch(i){<br>
case 0:<br>
SqlInitMain();<br>
break;<br>
case 1:<br>
SqlInitModule();<br>
break;<br>
case 2:<br>
SqlSelect();<br>
break;<br>
case 3:<br>
SqlOutStm();<br>
break;<br>
case 4:<br>
SqlPlSql();<br>
break;<br>
case 5:<br>
SqlStrType();<br>
break;<br>
}<br>
flag=1;<br>
break;<br>
}<br>
}<br>
if(!flag){<br>
outf&lt;&lt;buf&lt;&lt;endl;<br>
if(cmflag)<br>
cm&lt;&lt;buf&lt;&lt;endl;<br>
}<br>
} <br>
} /* ParseLine */<br>
  <br>
void Process(void)<br>
{<br>
while(!inf.eof()){<br>
GetLine();<br>
ParseLine();<br>
}<br>
if(cmflag)<br>
cm&lt;&lt;endl&lt;&lt;"}"&lt;&lt;endl;<br>
} /* Process */<br>
  <br>
void HFileProlog(char* hdefine)<br>
{<br>
hf&lt;&lt;"#ifndef "&lt;&lt;hdefine&lt;&lt;endl;<br>
hf&lt;&lt;"#define "&lt;&lt;hdefine&lt;&lt;endl;<br>
hf&lt;&lt;endl;<br>
hf&lt;&lt;"#ifdef __cplusplus"&lt;&lt;endl;<br>
hf&lt;&lt;"extern \"C\"{"&lt;&lt;endl;<br>
hf&lt;&lt;"#endif"&lt;&lt;endl;<br>
hf&lt;&lt;"\n\n";<br>
} /* HFileProlog */<br>
  <br>
void HFile1Prolog(char* hdefine)<br>
{<br>
hf1&lt;&lt;"#ifndef "&lt;&lt;hdefine&lt;&lt;"__DEFINE"&lt;&lt;endl;<br>
hf1&lt;&lt;"#define "&lt;&lt;hdefine&lt;&lt;"__DEFINE"&lt;&lt;endl;<br>
hf1&lt;&lt;endl;<br>
hf1&lt;&lt;"#ifdef __cplusplus"&lt;&lt;endl;<br>
hf1&lt;&lt;"extern \"C\"{"&lt;&lt;endl;<br>
hf1&lt;&lt;"#endif"&lt;&lt;endl;<br>
hf1&lt;&lt;"\n\n";<br>
} /* HFileProlog */<br>
  <br>
void HFileEpilog(void)<br>
{<br>
hf&lt;&lt;endl;<br>
hf&lt;&lt;"#ifdef __cplusplus"&lt;&lt;endl;<br>
hf&lt;&lt;"}"&lt;&lt;endl;<br>
hf&lt;&lt;"#endif"&lt;&lt;endl;<br>
hf&lt;&lt;endl;<br>
hf&lt;&lt;"#endif"&lt;&lt;endl;<br>
} /* HFileEpilog */<br>
  <br>
void HFile1Epilog(void)<br>
{<br>
hf1&lt;&lt;endl;<br>
hf1&lt;&lt;"#ifdef __cplusplus"&lt;&lt;endl;<br>
hf1&lt;&lt;"}"&lt;&lt;endl;<br>
hf1&lt;&lt;"#endif"&lt;&lt;endl;<br>
hf1&lt;&lt;endl;<br>
hf1&lt;&lt;"#endif"&lt;&lt;endl;<br>
} /* HFileEpilog */<br>
  <br>
int main(int argc, char* argv[])<br>
{<br>
if((argc!=6&amp;&amp;argc!=7&amp;&amp;argc!=8)||strcmp(argv[1],"-h")==0){<br>
HelpMessage();<br>
return 1;<br>
}<br>
cout&lt;&lt;"Connect String="&lt;&lt;argv[1];<br>
cout&lt;&lt;", Input File="&lt;&lt;argv[2];<br>
cout&lt;&lt;", Output File="&lt;&lt;argv[3];<br>
cout&lt;&lt;", H-File="&lt;&lt;argv[4];<br>
cout&lt;&lt;", #define="&lt;&lt;argv[5]&lt;&lt;endl;<br>
  <br>
try{<br>
db.rlogon(argv[1]);<br>
inf.open(argv[2],ios::in);<br>
if(!inf.good()){<br>
cerr&lt;&lt;"File not found: "&lt;&lt;argv[2]&lt;&lt;endl;<br>
db.logoff();<br>
return 1;<br>
}<br>
outf.open(argv[3],ios::out);<br>
if(!outf.good()){<br>
cerr&lt;&lt;"Cannot create file: "&lt;&lt;argv[3]&lt;&lt;endl;<br>
db.logoff();<br>
return 1;<br>
}<br>
hf.open(argv[4],ios::out);<br>
if(!hf.good()){<br>
cerr&lt;&lt;"Cannot create file: "&lt;&lt;argv[4]&lt;&lt;endl;<br>
db.logoff();<br>
return 1;<br>
}<br>
if(argc==7||argc==8){<br>
hf1flag=1;<br>
hf1.open(argv[6],ios::out);<br>
if(!hf1.good()){<br>
cerr&lt;&lt;"Cannot create file: "&lt;&lt;argv[6]&lt;&lt;endl;<br>
db.logoff();<br>
return 1;<br>
}<br>
}<br>
if(argc==8){<br>
cmflag=1;<br>
cm.open(argv[7],ios::out);<br>
if(!cm.good()){<br>
cerr&lt;&lt;"Cannot create file: "&lt;&lt;argv[7]&lt;&lt;endl;<br>
db.logoff();<br>
return 1;<br>
}<br>
}<br>
HFileProlog(argv[5]);<br>
if(hf1flag)HFile1Prolog(argv[5]);<br>
Process();<br>
HFileEpilog();<br>
if(hf1flag)HFile1Epilog();<br>
db.logoff();<br>
return 0;<br>
}<br>
catch(otl_exception&amp; p){<br>
cerr&lt;&lt;endl&lt;&lt;"Line
("&lt;&lt;line&lt;&lt;"):"&lt;&lt;buf&lt;&lt;endl&lt;&lt;endl<br>
&lt;&lt;" **** "&lt;&lt;p.msg&lt;&lt;endl;<br>
}<br>
db.logoff();<br>
return 1;<br>
} /* main */<br>
  <br>
  <br>
  <br>
  </a></xmp>
  <h2><a name="secE">Appendix E. How to install the OTL
library and Pro*OTL/Pre-Pro*C preprocessor</a></h2>
  <ul>
    <li><a name="secE">In order to install and use the OTL library,
copy the content of </a><a href="#secC">Appendix C</a> to the otl.h
file. Put the file to
a regular directory in which header files are located. That is all. No
need to make object files or libraries. <br>
      <br>
Besides, Oracle Call Interface standard header files are needed. In
Unix, they are located in the $ORACLE_HOME/rdbms/demo directory. In
Windows 95 or Windows NT, they could be found in one of the OCI
directories. The following header files are needed:
      <ul>
        <br>
        <li>ociapr.h
        </li>
        <li>ocidfn.h
        </li>
        <li>oratypes.h
        </li>
      </ul>
      <br>
    </li>
    <li>In order to install Pro*OTL / Pre-Pro*C preprocessor (PPC),
copy the content of <a href="#secD">Appendix D</a> to the ppc.C
or ppc.cpp file, depending on the C++ file suffix in your
platform. Compile PPC and make an executable. Put the executable
somewhere on $PATH. <br>
      <br>
A few modifications in the OCI standard
header files are necessary, to make PPC compile successfully. PPC
uses C++ streams (iostream.h and fstream.h). Since the "text" symbol is
defined in the C++ streams, the "typedef unsigned char text" symbol,
defined in the oratypes.h file, needs to be redefined as
"ora_text". The ociapr.h file contains OCI function prototypes and
"text" is used in the prototypes. Replace "text" with "ora_text". </li>
  </ul>
  <h2><a name="secF">Appendix F. Modules, generated by PPC for the
example from Chapter 4.</a></h2>
  <h3><a name="secF1">Pro*C module (ppc_test.pc)</a></h3>
  <xmp><a name="secF1">
#include &lt;ppc_test.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
EXEC SQL INCLUDE SQLCA;
#define sql_code sqlca.sqlcode
#define sql_rpc sqlca.sqlerrd[2]
typedef char CSTR[128];
EXEC SQL BEGIN DECLARE SECTION; EXEC SQL TYPE CSTR IS STRING(128);
EXEC SQL END DECLARE SECTION;
static void sqlerror(void)
{ EXEC SQL WHENEVER SQLERROR CONTINUE;
fprintf(stderr,"\n%s\n",sqlca.sqlerrm.sqlerrmc); EXEC SQL ROLLBACK
RELEASE; exit(1);
}
EXEC SQL WHENEVER SQLERROR DO sqlerror();
/* ===================== Sel ======================= */
EXEC SQL BEGIN DECLARE SECTION; int F_Sel; int n_Sel;
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE Sel_cur CURSOR FOR
SELECT *
FROM TEST_TAB
WHERE F1&gt;=:F_Sel AND F1&lt;=:F_Sel*2
ORDER BY F1 ;
long gl_rpc_save_Sel;
long count_Sel;
void Sel_open( int F
)
{ count_Sel=0; F_Sel=F; gl_rpc_save_Sel=sqlca.sqlerrd[2]; EXEC SQL OPEN
Sel_cur;
}
void Sel_close(void)
{ EXEC SQL CLOSE Sel_cur; sqlca.sqlerrd[2]=gl_rpc_save_Sel;
}
typedef char tCSTR_31_Sel[31];
EXEC SQL BEGIN DECLARE SECTION; EXEC SQL TYPE tCSTR_31_Sel IS
STRING(31); int row_fetch_count_Sel; int cur_row_pos_Sel; long
rpc_save_Sel; int end_of_data_Sel; double F1_Sel[50]; short
F1_IND_Sel[50]; tCSTR_31_Sel F2_Sel[50]; short F2_IND_Sel[50];
EXEC SQL END DECLARE SECTION;
int Sel_get(Sel* out)
{ if(count_Sel==0){ ++count_Sel; row_fetch_count_Sel=0;
cur_row_pos_Sel=0; end_of_data_Sel=0; } do{ if(row_fetch_count_Sel==0){
if(end_of_data_Sel)return 1; rpc_save_Sel=sqlca.sqlerrd[2]; EXEC SQL
WHENEVER NOT FOUND goto Sel_breakloop; EXEC SQL FETCH Sel_cur INTO
:F1_Sel:F1_IND_Sel, :F2_Sel:F2_IND_Sel; goto Sel_skip; Sel_breakloop:
if(sqlca.sqlerrd[2]-rpc_save_Sel==0)return 1; end_of_data_Sel=1;
Sel_skip: row_fetch_count_Sel=sqlca.sqlerrd[2]-rpc_save_Sel;
cur_row_pos_Sel=0; } out-&gt;F1=F1_Sel[cur_row_pos_Sel];
out-&gt;F1_IND=F1_IND_Sel[cur_row_pos_Sel];
strcpy(out-&gt;F2,(char*)&amp;F2_Sel[cur_row_pos_Sel]);
out-&gt;F2_IND=F2_IND_Sel[cur_row_pos_Sel]; ++cur_row_pos_Sel;
--row_fetch_count_Sel; }while(0); return 0;
}
EXEC SQL WHENEVER NOT FOUND CONTINUE;
/* =================== End of Sel ===================== */
/* ===================== Ins ======================= */
typedef char CSTR_31_Ins[31];
EXEC SQL BEGIN DECLARE SECTION; EXEC SQL TYPE CSTR_31_Ins IS
STRING(31); float F1_Ins[50]; CSTR_31_Ins F2_Ins[50]; int n_Ins;
EXEC SQL END DECLARE SECTION;
int auto_Ins;
void Ins_open(int auto_commit)
{ auto_Ins=auto_commit; n_Ins=0;
}
void Ins_put( float F1, char* F2
)
{ ++n_Ins; F1_Ins[n_Ins-1]=F1; strcpy((char*)&amp;F2_Ins[n_Ins-1],F2);
if(n_Ins==50) Ins_flush();
}
void Ins_flush(void)
{ if(n_Ins&gt;0){ EXEC SQL FOR :n_Ins INSERT INTO TEST_TAB ( F1, F2 )
VALUES ( :F1_Ins , :F2_Ins ) ; n_Ins=0; if(auto_Ins) EXEC SQL COMMIT; }
}
void Ins_close(void)
{ Ins_flush();
}
/* =================== End of Ins ===================== */
/* ===================== PL ======================= */
typedef char CSTR_31_PL[31];
EXEC SQL BEGIN DECLARE SECTION; EXEC SQL TYPE CSTR_31_PL IS STRING(31);
int A_PL; CSTR_31_PL B_PL; CSTR_31_PL C_PL; int n_PL;
EXEC SQL END DECLARE SECTION;
void PL_exec( int* A, char* B, char* C
)
{ PL_A=*A; strcpy(C_PL,C); EXEC SQL EXECUTE BEGIN :A_PL := :A_PL+1;
:B_PL := :C_PL ; END; END-EXEC; *A=A_PL; strcpy(B,B_PL);
}
/* =================== End of PL ===================== */
#ifdef __cplusplus
void assign_db(otl_connect* adb)
{ db=adb;
}
#endif
  </a></xmp>
  <h3><a name="secF2">C++ module (ppc_test.C)</a></h3>
  <xmp><a name="secF2"><br>
  <br>
#include &lt;ppc_test.h&gt;<br>
#include &lt;otl.h&gt;<br>
static otl_connect* db;<br>
static otl_cursor hotcur;<br>
  <br>
extern "C"{<br>
  <br>
  <br>
/* ===================== Sel ======================= */<br>
static otl_stream* str_Sel;<br>
  <br>
void Sel_open(<br>
int F<br>
)<br>
{<br>
str_Sel=new otl_stream(<br>
50,<br>
  <br>
"SELECT "<br>
" * "<br>
"FROM "<br>
" TEST_TAB "<br>
"WHERE "<br>
" F1&gt;=:F&lt;int&gt; AND F1&lt;=:F*2 "<br>
"ORDER BY "<br>
" F1",<br>
  <br>
*db<br>
);<br>
(*str_Sel)&lt;&lt;F;<br>
  <br>
}<br>
  <br>
void Sel_close(void)<br>
{<br>
delete str_Sel;<br>
}<br>
  <br>
  <br>
int Sel_get(Sel* out)<br>
{<br>
if(str_Sel-&gt;eof())return 1;<br>
(*str_Sel)&gt;&gt;out-&gt;F1;<br>
(*str_Sel)&gt;&gt;out-&gt;F2;<br>
  <br>
out-&gt;F1_IND=str_Sel-&gt;is_null()?-1:0;<br>
out-&gt;F2_IND=str_Sel-&gt;is_null()?-1:0;<br>
  <br>
return 0;<br>
}<br>
  <br>
/* =================== End of Sel ===================== */<br>
  <br>
/* ===================== Ins ======================= */<br>
static otl_stream* cur_Ins;<br>
  <br>
void Ins_open(int auto_commit)<br>
{<br>
cur_Ins=new otl_stream(<br>
50,<br>
  <br>
"INSERT INTO TEST_TAB "<br>
"( "<br>
" F1, "<br>
" F2 "<br>
") "<br>
" VALUES "<br>
"( "<br>
" :F1&lt;float&gt;, "<br>
" :F2&lt;char[31]&gt; "<br>
")",<br>
  <br>
*db<br>
);<br>
cur_Ins-&gt;set_commit(auto_commit);<br>
}<br>
  <br>
void Ins_put(<br>
float F1,<br>
char* F2<br>
)<br>
{<br>
(*cur_Ins)&lt;&lt;F1;<br>
(*cur_Ins)&lt;&lt;F2;<br>
}<br>
  <br>
void Ins_flush(void)<br>
{<br>
cur_Ins-&gt;flush();<br>
}<br>
  <br>
void Ins_close(void)<br>
{<br>
delete cur_Ins;<br>
}<br>
  <br>
/* =================== End of Ins ===================== */<br>
  <br>
/* ===================== PL ======================= */<br>
void PL_exec(<br>
int* A,<br>
char* B,<br>
char* C<br>
)<br>
{<br>
if(!hotcur.connected)hotcur.open(*db);<br>
hotcur.parse(<br>
"BEGIN "<br>
" :A := :A+1; "<br>
" :B := :C ; "<br>
"END;"<br>
);<br>
hotcur.bind_int(":A",A);<br>
hotcur.bind_cstring(":B",B,31);<br>
hotcur.bind_cstring(":C",C,31);<br>
hotcur.exec();<br>
}<br>
  <br>
/* =================== End of PL ===================== */<br>
  <br>
#ifdef __cplusplus<br>
  <br>
/* <br>
Function for C++. In the main C++ module, the user needs to call<br>
this function, in order to pass over a pointer to the actual<br>
database connect object into the C++ module, generated by PPC.<br>
  <br>
This function can be eliminated if only Pro*C is used.<br>
*/<br>
  <br>
void assign_db(otl_connect* adb)<br>
{<br>
db=adb;<br>
}<br>
  <br>
/* <br>
Function for C++. In the main C++ module, the user needs to call<br>
this function just before disconnecting from the database, in order<br>
to close the static "hot" cursor in this file.<br>
  <br>
This function can be eliminated if only Pro*C is used.<br>
*/<br>
void close_hotcur(void)<br>
{<br>
hotcur.close(); // close static hot cursor<br>
}<br>
  <br>
#endif<br>
  <br>
}<br>
  <br>
  <br>
  <br>
  </a></xmp>
  <h3><a name="secF3">Interface header file (ppc_test.h)</a></h3>
  <xmp><a name="secF3"><br>
  <br>
#ifndef __PPC_TEST_H<br>
#define __PPC_TEST_H<br>
  <br>
#ifdef __cplusplus<br>
extern "C"{<br>
#endif<br>
  <br>
  <br>
  <br>
struct struct_Sel{<br>
  <br>
double F1;<br>
short F1_IND;<br>
  <br>
char F2[31];<br>
short F2_IND;<br>
  <br>
};<br>
typedef struct struct_Sel Sel;<br>
  <br>
void Sel_open(<br>
int F<br>
);<br>
void Sel_close(void);<br>
int Sel_get(Sel* out);<br>
  <br>
  <br>
void Ins_open(int auto_commit);<br>
void Ins_put(<br>
float F1,<br>
char* F2<br>
);<br>
void Ins_flush(void);<br>
void Ins_close(void);<br>
  <br>
void PL_exec(<br>
int* A,<br>
char* B,<br>
char* C<br>
);<br>
  <br>
  <br>
#ifdef __cplusplus<br>
}<br>
#endif<br>
  <br>
#endif<br>
  <br>
  <br>
  <br>
  </a></xmp>
  <h3><a name="secF4">Command line for the example from Chapter 4.</a></h3>
  <xmp><a name="secF4"><br>
  <br>
ppc scott/tiger ppc_test.ppc ppc_test.pc ppc_test.h __PPC_TEST_H
dummy.h ppc_test.C<br>
  <br>
  </a></xmp>
  <ul>
    <li><a name="secF4">scott/tiger -- argv[1], connect string
      </a></li>
    <li><a name="secF4">ppc_test.ppc -- argv[2], input directive file
      </a></li>
    <li><a name="secF4">ppc_test.pc -- argv[3], output Pro*C module
      </a></li>
    <li><a name="secF4">ppc_test.h -- argv[4], output interface header
file
      </a></li>
    <li><a name="secF4">__PPC_TEST_H -- argv[5]. #define for the
interface header file
      </a></li>
    <li><a name="secF4">dummy.h -- argv[6], dummy file (contains macro
definitions to be used with
the OTL streams)
      </a></li>
    <li><a name="secF4">ppc_test.C -- argv[7], output C++ module
      </a></li>
  </ul>
  <a name="secF4"><br>
  <br>
  <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
pageTracker._trackPageview();
  </script></a></li>
</body>
</html>
