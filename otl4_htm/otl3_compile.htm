<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Sergei Kuchin">
  <meta name="GENERATOR"
 content="Mozilla/4.77 [en] (Win95; U) [Netscape]">
  <meta name="KeyWords"
 content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">
  <title>OTL 4.0, How to compile OTL</title>
</head>
<body>
<br>
<br>
<center>
<h1>OTL 4.0, How to compile OTL</h1>
</center>
<h1>
<a name="otl_compile"></a>How to compile OTL</h1>
OTL 4.0 is an integrated library which contains a template
stream framework and OTL-adapters for the OCI7, OCI8, OCI8i, OCI9i,
OCI10g,
ODBC 2.5, ODBC 3.x, DB2 CLI, and Informix CLI. The following macro
definitions (#define's) need to
be used in order to
compile OTL for each type of the underlying database API from the list
above:<br>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">#define
Name</span></td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Explanation<br>
      </span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTL_DB2_CLI"></a><b>OTL_DB2_CLI</b></td>
      <td style="vertical-align: top;"> for <a
 href="http://www-4.ibm.com/software/data/db2/">DB2</a>
Call Level Interface (CLI)</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_ENTERPRISEDB"></a>OTL_ODBC_<br>
ENTERPRISEDB</span><br>
      </td>
      <td style="vertical-align: top;">for <a
 href="http://www.enterprisedb.com">Enterprise DB</a> ODBC provider.
Enterprise DB is a variant of PostreSQL that was made compatible with
Oracle (up to some extent) and commecially available.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_INFORMIX_CLI"></a>OTL_INFORMIX_CLI</span><br>
      </td>
      <td style="vertical-align: top;">for Informix Call Level
Interface for Unix (when&nbsp; <a href="#OTL_ODBC_UNIX">OTL_ODBC_UNIX</a>
is enabled).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTL_IODBC_BSD"></a><b>OTL_IODBC_BSD</b></td>
      <td style="vertical-align: top;">for ODBC on BSD Unix, when iODBC
package is used<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><a name="OTL_ODBC"></a>OTL_ODBC</b></td>
      <td style="vertical-align: top;">for ODBC</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_MSSQL_2005"></a>OTL_ODBC_MSSQL_2005</span><br>
      </td>
      <td style="vertical-align: top;">Microsoft SQL Server 2005
requires special treatment when VARCHAR(MAX), VARBINARY(MAX), and
NVARCHAR(MAX) are used. MS SQL 2005's Native SQL Client (SNAC) handles
the new XXX(MAX) data types in a different way, compared with TEXT,
NTEXT, and IMAGE data types. If the XXX(MAX) types are not used,
#define OTL_ODBC can be used. Otherwise, this new #define
OTL_ODBC_MSSQL_2005 should be used.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTL_ODBC_MSSQL_2008"></a><span
 style="font-weight: bold;">OTL_ODBC_<br>
MSSQL_2008</span><br>
      </td>
      <td style="vertical-align: top;">MS SQL Server 2008 has new
features like datetime2, date, time, filestream based VARBINARY(MAX),
etc. This #define enables OTL support for most of the new features.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTL_ODBC_MULTI_MODE"></a><span
 style="font-weight: bold;">OTL_ODBC_<br>
MULTI_MODE</span><br>
      </td>
      <td style="vertical-align: top;">This #define should be used when
there is a need to connect via ODBC to more than one database type from
the same time. For more detail see otl_connect::<a
 href="otl3_connect_class.htm#set_connection_mode">set_connection_mode</a>(),
and OTL example <a href="otl4_ex675.htm">675</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><small><small><a
 name="OTL_ODBC_MYSQL"></a></small></small><b>OTL_ODBC_MYSQL</b></td>
      <td style="vertical-align: top;">for <i><a
 href="http://www.mysql.com/downloads/api-myodbc.html">MyODBC</a>/<a
 href="http://www.mysql.com/">MySQL</a></i>.
The difference between OTL_ODBC_MYSQL and OTL_ODBC is that
transactional
ODBC function calls are turned off for OTL_ODBC_MYSQL, since MySQL does
not have transactions. This #define should only used with the MyODBC
2.5, which is very old at this point in time. See MySQL based OTL code
examples for more detail.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_POSTGRESQL"></a>OTL_ODBC_<br>
POSTGRESQL</span><br>
      </td>
      <td style="vertical-align: top;">PostgreSQL ODBC can be used with
the standard #define <a href="#OTL_ODBC">OTL_ODBC</a>. However,
PostgreSQL has at least two ODBC drivers,&nbsp; and some of them should
be used with #define OTL_ODBC_POSTGRESQL. The following list specifies
the differences between #define OTL_ODBC and #define
OTL_ODBC_POSTGRESQL in more detail:<br>
      <ul>
        <li>Linux<br>
        </li>
        <ul>
          <li>psqlodbc.so,&nbsp; psqlodbcw.so should be used with
#define OTL_ODBC_POSTGRESQL</li>
          <li>libodbcpsql.so should be used with #define OTL_ODBC<br>
          </li>
        </ul>
        <li>Solaris<br>
        </li>
        <ul>
          <li>libodbcpsql.so should be used with #define
OTL_ODBC_POSTGRESQL<br>
          </li>
        </ul>
        <li>Windows</li>
        <ul>
          <li>pgsqlodbc30a.dll, pgsqlodbc35w.dll should be used with
#define OTL_ODBC_POSTGRESQL<br>
          </li>
        </ul>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTL_ODBC_TIMESTEN_UNIX"></a><span
 style="font-weight: bold;">OTL_ODBC_<br>
TIMESTEN_UNIX</span><br>
      </td>
      <td style="vertical-align: top;">for TimesTen in Unix/Linux.
TimesTen supports ODBC. Unlike many other database systems, where ODBC
API support may be much slower than the proprietary interface, ODBC is
the <span style="font-style: italic;">native </span>TimesTen
interface that operates directly with the database engine. TimesTen
ODBC driver has the following extensions that are available through OTL:<br>
      <ul>
        <li>the <a href="otl3_bind_variables.htm#NAMED_BV_NOTATION">named
notation</a> for bind variables / placeholders</li>
        <li>TT_PRFEFETCH_COUNT ([1..128] range)<br>
        </li>
      </ul>
      <br>
See "how to <a href="#TIMESTEN_ODBC_UNIX_COMPILE">compile</a> TimesTen
in Linux/Unix" for more detail. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_TIMESTEN_WIN"></a>OTL_ODBC_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">TIMESTEN_WIN</span><br>
      </td>
      <td style="vertical-align: top;">for TimesTen in Windows.
TimesTen supports ODBC. Unlike many other database systems, where ODBC
API support may be much slower than the proprietary interface, ODBC is
the <span style="font-style: italic;">native </span>TimesTen
interface that operates directly with the database engine. ODBC driver
has the following extensions that are available through OTL:<br>
      <ul>
        <li>the <a href="otl3_bind_variables.htm#NAMED_BV_NOTATION">named
notation</a> for bind variables / placeholders</li>
        <li>TT_PRFEFETCH_COUNT ([1..128] range)<br>
        </li>
      </ul>
See how to <a href="#TIMESTEN_ODBC_WIN_COMPILE">compile</a> TimesTen
in Windows for more detail. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><small><a name="OTL_ODBC_UNIX"></a></small><b>OTL_ODBC_UNIX</b></td>
      <td style="vertical-align: top;">for ODBC
bridges
in Unix</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><a name="OTL_ODBC_zOS"></a>OTL_ODBC_zOS</b></td>
      <td style="vertical-align: top;">for ODBC on IBM zOS.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><small><a name="INTERBASE"></a></small><b>OTL_ODBC_XTG_IBASE6</b><small><b>
      </b></small></td>
      <td style="vertical-align: top;">for <a
 href="http://www.borland.com/devsupport/interbase/opensource/">Interbase</a>
6.x via <a href="http://www.xtgsystems.com/">XTG Systems'</a>&nbsp; <a
 href="http://www.xtgsystems.com/ib6odbc.php3">ODBC
driver</a>. The reason for introducing this #define is that the ODBC
driver
is the only Open Source ODBC driver for Interbase. Other drivers, like
Easysoft's ODBC for Interbase, are commercial products, and it beats
the
purpose of using Interbase, as an Open Source.database server.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><a name="OTL_ORA7"></a>OTL_ORA7</b></td>
      <td style="vertical-align: top;">for OCI7</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><a name="OTL_ORA8"></a>OTL_ORA8</b></td>
      <td style="vertical-align: top;">for OCI8</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b><a name="OTL_ORA8I"></a>OTL_ORA8I</b></td>
      <td style="vertical-align: top;">for OCI8i</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTLORA9I"></a><b>OTL_ORA9I<a
 name="OTL_ORA9I"></a></b></td>
      <td style="vertical-align: top;">for OCI9i. All
code
that
compiles and works under #define OTL_ORA7, OTL_ORA8, and OTL_ORA8I,
should
work when OTL_ORA9I is used</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA10G"></a>OTL_ORA10G</span><br>
      </td>
      <td style="vertical-align: top;">for
OCI10g. All code that compiles and works&nbsp; under #define OTL_ORA7,
OTL_ORA8, OTL_ORA8I, OTL_ORA9I, should work with OTL_ORA10G.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA10G_R2"></a>OTL_ORA10G_R2</span></td>
      <td style="vertical-align: top;">for
OCI10g, Release 2 (Oracle 10.2). All code that compiles and works&nbsp;
under #define OTL_ORA7,
OTL_ORA8, OTL_ORA8I, OTL_ORA9I, and OTL_ORA10G should work with
OTL_ORA10G_R2 .<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA11G"></a>OTL_ORA11G</span><br>
      </td>
      <td style="vertical-align: top;">for OCI11g Release 1 (Oracle
11.1). All code that compiles and works under #define OTL_ORA7,
OTL_ORA8, OTL_ORA8I, OTL_ORA9I, OTL_ORA10G, and OTL_ORA10G_R2 should
work with
OTL_ORA11G..</td>
    </tr>
  </tbody>
</table>
<br>
<br>
There are several extra macro definitions which control compilation of
the OTL header file:<br>
<br>
<table style="text-align: left; width: 992px; height: 3222px;"
 border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">#define</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Explanation</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a name="OTL_ACE"></a><b>OTL_ACE</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(the same as
#define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>,
only for use with Adaptive Communication Environment (<a
 href="http://www.cs.wustl.edu/%7Eschmidt/ACE.html">ACE</a>)).
This #defines makes OTL cmopile with ACE. Most features of OTL, which
require
#define OTL_STL to be on, compile with ACE, except for <a
 href="otl3_output_iterator.htm">otl_output_iterator</a>, <a
 href="otl3_input_iterator.htm">otl_input_iterator.</a>,
and the <a href="otl3_pl_tab.htm">STL
vector based PL/SQL table
container
classes</a> (otl_XXX_vec). OTL stream iterators were not implemented
for
ACE since the concept of stream iterators is not present in ACE. Same
with
with the otl_XXX_vec: vectors are not implemented in ACE. ACE has only
dynamic arrays with dynamically defined sizes.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_ADD_NULL_TERMINATOR_TO_STRING_SIZE"></a><b>OTL_ADD<br>
_NULL<br>
_TERMINATOR<br>
_TO_STRING<br>
_SIZE</b>.</font></td>
      <td style="vertical-align: top;">This
#define enables the addition of one byte / Unicode character to the
size
of a string buffer, when the buffer gets allocated on the program's
heap.
This alleviates the burden of remembering that an extra byte / Unicode
character needs to be added to the string buffer size to accomodate the
string's NULL terminator.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_ANSI_CPP"></a><b>OTL_ANSI_CPP&nbsp;</b></font></td>
      <td style="vertical-align: top;">for
turning on
ANSI C++
compliance mode: ANSI C++ typecasts (static_cast&lt;&gt;,
const_cast&lt;&gt;, reinterpret_cast&lt;&gt; instead of C-style
typecasts),<a href="#OTL_FUNC_THROW_SPEC_ON"> optional function throw</a>
clauses, <span style="font-style: italic;">typename</span> instead of <span
 style="font-style: italic;">class</span> keywords in class type
template class parameters, etc.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_BIGINT"></a><span style="font-weight: bold;">OTL_BIGINT</span>&nbsp;</font></td>
      <td style="vertical-align: top;">This #define
enables support for <a href="otl3_bind_variables.htm#bigint">bigint</a>
(64-bit signed integer) bind
variables by specifynig a 64-bit signed integer
datatype name, for example:<br>
      <pre>#define OTL_BIGINT __int64 // VC++, Borland C++</pre>
or<br>
      <pre>#define OTL_BIGINT long long // GNU C++<br><br></pre>
ODBC and DB2-CLI support 64-bit integers natively, so does OTL. No OCI
(OCI7,OCI8, OCI8i, OCI9i) supports 64-bit integers, so OTL has to
emulate this of bind variables via strings (char[XXX]). OTL allocates
and&nbsp; binds a string variable with a placeholder that is defined as
&lt;<a href="otl3_bind_variables.htm#bigint">bigint</a>&gt;.<br>
      <br>
In case if OTL_BIGINT, and one of the OTL_ORAxx #defines are defined
together, the following two defines also need to be enabled: <a
 href="#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>, <a
 href="#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><span
 style="font-weight: bold;"><a name="OTL_BIGINT_TO_STR"></a>OTL_BIGINT</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">_TO_STR</span>(n,str)<br>
      </font> </td>
      <td style="vertical-align: top;">This #define is required when <a
 href="#OTL_BIGINT">OTL_BIGINT</a> is enabled and when one of OTL_ORAxx
#defines is enabled, in order to support OTL internal bigint-to-string
conversion. This #define is supposed to provide bigint-to-string
conversion code that is most probably C++ compiler specific (because
64-bit ints are not part of the ANSI C++ standard), for example:<br>
      <pre>#if defined(_MSC_VER) // VC++<br><br>#define <a
 href="#OTL_BIGINT">OTL_BIGINT</a> __int64<br><br>#define <a
 href="#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>(str,n)                \<br>{                                               \<br>  n=_atoi64(str);                               \<br>}<br><br>#define <a
 href="#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>(n,str)                \<br>{                                               \<br>  _i64toa(n,str,10);                            \<br>}<br>#endif<br></pre>
      <pre><br></pre>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_BIND_VAR_STRICT_TYPE_CHECKING_ON"></a><b>OTL_BIND_VAR<br>
_STRICT_<br>
TYPE_<br>
CHECKING_ON</b>&nbsp;</font></td>
      <td style="vertical-align: top;">This #define
enables "bind
variable strict type checking", that is,
typos
in bind variable data type declarations get checked strictly. OTL, for
performance, checks out as few characters as possible in a bind
variable
declaration, in order to recognize a legitimate data type declaration.
Sometimes, it results in some parts of unrecognized declaration to be
left
as is, which, in its turn, causes a database runtime error, typically,
an SQL statement parse error. In most cases, it's okay, no trouble
whatsoever.
In very rare cases, depending on a concrete release of a database API,
on a specific platform, it causes a program core dump / crash.<br>
      <br>
It is recommended to use this #define as part of the "Debug mode",
in
order to sort out errors of this kind. Then, when compiling in "Release
mode", the #define could be dropped. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR"></a><b>OTL_DB2_CLI_<br>
MAP_LONG_<br>
VARCHAR_TO<br>
_VARCHAR</b>.&nbsp;</font></td>
      <td style="vertical-align: top;">This #define works
in a
combination with #define <a href="otl3_compile.htm#OTL_DB2_CLI">OTL_DB2_CLI</a>.
It should be used in the case of the DB2 CLI on the client side and the
DB2 OS/390 on the server side, because all VARCHAR table columns that
are
&gt;= 255 bytes get reported by the DB2 CLI as SQL_LONG_VARCHARs
(normally
reserved for DB2 CLOB columns). In DB2 UDB distributed (non-OS/390
flavor),
all VARCHARs get reported as DB2 CLI's SQL_VARCHARs. When #define
OTL_DB2_MAP_LONG_VARCHAR_TO_VARCHAR
is defined, all VARCHAR table colunms, which are shorter (&lt;=) than
the
value defined by the #define, get mapped to SQL_VARCHAR, even though
the
DB2 CLI reports the columns as SQL_LONG_VARCHARs. For example:<br>
      <br>
      <tt>#define OTL_DB2_CLI</tt><br>
      <tt>#define OTL_DB2_CLI_MAP_LONG_VARCHAR_TO_VARCHAR 4000</tt><br>
      <tt>#include &lt;otlv4.h&gt;<br>
      <br>
      </tt>In this example, all VARCHAR table columns, that are &lt;=
4000
bytes,
will be mapped to SQL_VARCHAR, even though the client code connects to
a DB2 OS/390 database, and the client DB2 CLI reports the columns as
SQL_LONG_VARCHARs.
This <br>
kind of datatype mapping happens only on SELECT statements, or
stored
procedures that return a result set. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_DEFAULT_CHAR_NULL_TO_VAL"></a><b>OTL_<br>
DEFAULT<br>
_CHAR_<br>
NULL_TO_VAL</b></font></td>
      <td style="vertical-align: top;"><b> </b>When
this #define is set to a char value, in the case of a NULL, returned
from
the database, OTL assigns the value to the variable that is used in
operator&gt;&gt;(char&amp;),
or in operator(unsigned char&amp;). At the same time,
otl_stream::is_null()
can be used to check for NULL. This default value is more of a
convenience
than necessity. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_DEFAULT_NUMERIC_NULL_TO_VAL"></a><b>OTL_<br>
DEFAULT<br>
_NUMERIC_<br>
NULL_TO_VAL</b></font></td>
      <td style="vertical-align: top;">When
this #define is set to a numeric value, in the case of a NULL returned
from
the database, OTL assigns the value to the variable that is used in
operator&gt;&gt;(numeric_type&amp;).&nbsp; At the same time,
otl_stream::is_null()
can be used to check for NULL. This default value is more of a
convenience
than necessity.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_DEFAULT_DATETIME_NULL_TO_VAL"></a><b>OTL_DEFAULT<br>
_DATETIME<br>
_NULL_TO_VAL&nbsp;</b></font></td>
      <td style="vertical-align: top;">When
this #define is set to a value of otl_datetime datatype, in the case of
a NULL, returned from the database, OTL assigns the value to to the
variable
that is used in operator&gt;&gt;(otl_datetime&amp;). At the same time,
otl_stream::is_null()
can be used to check for NULL. This default value is more of a
convenience
than necessity. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_DEFAULT_STRING_NULL_TO_VAL"></a><b>OTL_DEFAULT<br>
_STRING<br>
_NULL_TO_VAL</b> <br>
      </font></td>
      <td style="vertical-align: top;">When this #define
is set to a
string value, in the case of a NULL,
returned
from the database., OTL assigns the value to the variable that is used
in operator&gt;&gt;(std::string&amp;), or in
operator&gt;&gt;(ACE_TString&amp;), or
in a string class, defined by #define USER_DEFINED_STRING_CLASS:
opartor&gt;&gt;(USER_DEFINED_STRING_CLASS&amp;).
Also, OTL assigns the value to the variable that is used in
operator&gt;&gt;(char*),
or in opartor&gt;&gt;(unsigned char*). At the same time,
otl_stream::is_null()
can be used to check for NULL. This default vaue is more of a
convenience
than necessity. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="OTL_DESTRUCTORS_DO_NOT_THROW"></a><span
 style="font-weight: bold;">OTL_DESTRUCTORS_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">DO_NOT_THROW</span><br>
      </td>
      <td style="vertical-align: top;">Top C++ experts say that
"throwing destructors" are bad. OTL throws execptions from destructors
by default in order to communicate database errors via otl_exceptions.
OTL also makes the maximum effort (see #define <a
 href="#OTL_UNCAUGHT_EXCEPTION_ON">OTL_UNCAUGHT_EXCEPTION_ON</a> for
more detail) to detect the stack unwinding situation and not to throw
exceptions from destructors in that case, because that would result in
an immediate program abort. #define OTL_DESTRUCTORS_DO_NOT_THROW
enables try/catch blocks to prevent OTL destructors from throwing
exceptions. See <a
 href="http://kolpackov.net/projects/c++/eh/dtor-1.xhtml">this</a> for
more detail on the topic. It's strongly recommended, if you enable this
#define, to make sure that every single instance of otl_connect,
otl_stream, otl_lob_stream releases its underlying resources when t
goes
out of scope. In the worst case, information about a database error may
be lost.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a name="OTL_ENABLE_MSSQL_MARS"></a><span
 style="font-weight: bold;">OTL_ENABLE_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">MSSQL_MARS</span><br>
      </td>
      <td style="vertical-align: top;">MS SQL SQL 2005 and 2008 support
the Multiple Active Result Sets (MARS), which is not enabled by
default. In order for MARS to be enabled, an ODBC function call needs
to be made. This #define enables the ODBC function call.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="OTL_EXCEPTION_IS_DERIVED_FROM_STD_EXCEPTION"></a><span
 style="font-weight: bold;">OTL_EXCEPTION_<br>
IS_DERIVED_FROM_<br>
STD_EXCEPTION</span><br>
      </td>
      <td style="vertical-align: top;">This #define is a shortcut for
the following:<br>
      <br>
      <span style="font-family: monospace;">#define <a
 href="#OTL_EXCEPTION_DERIVED_FROM">OTL_EXCEPTION_DERIVED_FROM</a>
std::exception</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">#define <a
 href="#OTL_EXCEPTION_HAS_MEMBERS">OTL_EXCEPTION_HAS_MEMBERS</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; virtual
const char* what()
const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return reinterpret_cast&lt;const
char*&gt;(msg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; } <br>
      </span><br style="font-family: monospace;">
It means that <a href="otl3_exception_class.htm">otl_exception</a> is
derived from std::exception.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_EXCEPTION_DERIVED_FROM"></a><b>OTL_EXCEPTION<br>
_DERIVED_FROM</b>&nbsp;</font></td>
      <td style="vertical-align: top;">This #define
allows the <a href="otl3_exception_class.htm">otl_exception</a>
class to be included into already exsisting hierarchy of exception
classes.
The #define should specify a name of already existing class, which is
used
as part of the exception class hierarchy. The STL exception class
hiararchy
is a good example. otl_exception can be derived from one of the classes
in the hierarchy, so that a catch block, that catches exception of the
base class, will be able to catch exceptions of the otl_exception
class.
In the OTL header file, in case if this #define is defined, the class,
defined in the #define, will be specified as a base class for the
otl_exception
class. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_EXCEPTION_ENABLE_ERROR_OFFSET"></a>OTL_EXCEPTION_<br>
ENABLE_<br>
ERROR_<br>
OFFSET</span></td>
      <td style="vertical-align: top;">This #define enables the so
called SQL Statement Parse Error Offset, and it is available for
OTL/OCIx only. When an otl_exception gets thrown, and it has
otl_exception::stm_text field populated, the parse error offset will
point to the actual position of the SQL error.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_EXCEPTION_HAS_MEMBERS"></a><b>OTL_EXCEPTION<br>
_HAS_MEMBERS</b></font></td>
      <td style="vertical-align: top;">This #define
allows the user to
define new member functions or data
members
in the <a href="otl3_exception_class.htm">otl_exception</a>
class. The
OTL header file checks out whether this #define is defined, and then
the
body of the #define gets included textually into the body of the
otl_exception
class. This simple technique allows the otl_exception class to have new
members. This #define can be used in a combination with #define <a
 href="otl3_compile.htm#OTL_EXCEPTION_DERIVED_FROM">OTL_EXCEPTION_DERIVED_FROM</a>.
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_EXPLICIT_NAMESPACES"></a><b>OTL_EXPLICIT<br>
_NAMESPACES</b> <br>
      </font></td>
      <td style="vertical-align: top;">(for
turning on namespaces) </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_EXCEPTION_STM_TEXT_SIZE"></a>OTL_EXCEPTION_<br>
STM_TEXT_<br>
SIZE</span><br>
      </td>
      <td style="vertical-align: top;">This #define specifies a new
size for the <a href="otl3_exception_class.htm">otl_exception</a>::<a
 href="otl3_exception_class.htm#stm_text">stm_text</a> buffer. By
default, it's 2048 bytes, that is, the actual otl_exception will
contain only 2047 first bytes of the SQL statement, associated with the
exception. If more bytes of the SQL statement text is needed, the
#define can come handy.This #define can be used in a combination with
#define <a href="#OTL_EXCEPTION_ENABLE_ERROR_OFFSET">OTL_EXCEPTION_ENABLE_ERROR_OFFSET</a>,
for example:<br>
      <br>
      <span style="font-family: monospace;">#define
OTL_EXCEPTION_ENABLE_ERROR_OFFSET<br>
#define OTL_EXCEPTION_STM_TEXT_SIZE 32767<br>
      </span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_EXTENDED_EXCEPTION"></a><b>OTL_EXTENDED<br>
_EXCEPTION</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(for
enabling the otl_exception's <a
 href="otl3_exception_class.htm#EXTENDED">extended
fields</a> for OTL/ODBC and OTL/DB2-CLI). This is for fixing problem <a
 href="otl3_prob.htm#prob47">47.</a> </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_ALTERNATE_RPC"></a>OTL_ODBC_<br>
ALTERNATE_<br>
RPC</span><br>
      </td>
      <td style="vertical-align: top;">This #define should be used with
the PostgreSQL ODBC driver. The driver returns as many row counts via
SQLRowCount() calls as there are rows in a batch INSERT statement. The
#define enables a loop that fetches all individual row counts and sums
them up (+=). As a result, otl_stream::get_rpc() returns the total,
which is correct for PostgreSQL. Normally, commercially available ODBC
drivers return a single row count on a batch INSERT. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="OTL_ODBC_LOGOFF_FREES_HANDLES"></a><span
 style="font-weight: bold;">OTL_ODBC_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">LOGOFF_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">FREES_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">HANDLES</span><br>
      </td>
      <td style="vertical-align: top;">Some ODBC drivers can't reuse
underlying ODBC connect related resources. In order for OTL to fully
recover from a database failure, the resources need to be released and
new resources need to be allocated for otl_connect objects to work.
Some versions of the Oracle ODBC driver for Oracle show that type
behavior. This #define forces otl_connect::logoff() to the ODBC connect
resources so that the next call to otl_connect::rlogon() would allocate
the resources again.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_STRING_TO_TIMESTAMP"></a>OTL_ODBC_<br>
STRING_TO_<br>
TIMESTAMP</span><br>
      </td>
      <td style="vertical-align: top;">This #define defines conversion
from the string/varchar format to the timestamp format (<a
 href="otl3_stream_class.htm#otl_datetime">otl_datetime</a>), for
example, PostgreSQL's timestamps with time zone, or MS SQL Server
2008's datetimeoffset(7):<br>
      <br>
for PostgreSQL:<br>
      <pre>#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)            \<br>{                                                       \<br>  sscanf(str,                                           \<br>         "%04d-%02d-%02d %02d:%02d:%02d.%06ld%hd",      \<br>         &amp;tm.year,                                      \<br>         &amp;tm.month,                                     \<br>         &amp;tm.day,                                       \<br>         &amp;tm.hour,                                      \<br>         &amp;tm.minute,                                    \<br>         &amp;tm.second,                                    \<br>         &amp;tm.fraction,                                  \<br>         &amp;tm.tz_hour);                                  \<br>}<br><br></pre>
for PostgreSQL and #define OTL_UNICODE:<br>
      <br>
      <pre>#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)            \<br>{                                                       \<br>  swscanf(str,                                          \<br>         L"%04d-%02d-%02d %02d:%02d:%02d.%06ld%hd",     \<br>         &amp;tm.year,                                      \<br>         &amp;tm.month,                                     \<br>         &amp;tm.day,                                       \<br>         &amp;tm.hour,                                      \<br>         &amp;tm.minute,                                    \<br>         &amp;tm.second,                                    \<br>         &amp;tm.fraction,                                  \<br>         &amp;tm.tz_hour);                                  \<br>}<br></pre>
      <br>
      <br>
for MS SQL 2008:<br>
      <pre>#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)              \<br>{                                                         \<br>  sscanf(str,                                             \<br>           "%04d-%02d-%02d %02d:%02d:%02d.%07ld %hd:%hd", \<br>           &amp;tm.year,                                      \<br>           &amp;tm.month,                                     \<br>           &amp;tm.day,                                       \<br>           &amp;tm.hour,                                      \<br>           &amp;tm.minute,                                    \<br>           &amp;tm.second,                                    \<br>           &amp;tm.fraction,                                  \<br>           &amp;tm.tz_hour,                                   \<br>           &amp;tm.tz_minute);                                \<br>}<br><br></pre>
for MS SQL 2008 and #define OTL_UNICODE<br>
      <br>
      <pre>#define OTL_ODBC_STRING_TO_TIMESTAMP(str,tm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp; swscanf(str,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"%04d-%02d-%02d %02d:%02d:%02d.%07ld %hd:%hd",\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.fraction,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.tz_hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tm.tz_minute);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br>}</pre>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ODBC_TIMESTAMP_TO_STRING"></a>OTL_ODBC_<br>
TIMESTAMP_<br>
TO_STRING</span><br>
      </td>
      <td style="vertical-align: top;">This #define defines conversion
the timestamp format (<a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_stream_class.htm#otl_datetime">otl_datetime</a>)
to the string/varchar format, for example, PostgreSQL's timestamp with
time zone, or MS SQL Server 2008's datetimeoffset(7):<br>
      <br>
for PostgreSQL:<br>
      <pre>#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)            \<br>{                                                       \<br>  sprintf(str,                                          \<br>         "%04d-%02d-%02d %02d:%02d:%02d.%06ld %+hd",    \<br>          tm.year,                                      \<br>          tm.month,                                     \<br>          tm.day,                                       \<br>          tm.hour,                                      \<br>          tm.minute,                                    \<br>          tm.second,                                    \<br>          tm.fraction,                                  \<br>          tm.tz_hour);                                  \<br>}<br><br><br></pre>
for PostgreSQL and #define OTL_UNICODE:<br>
      <pre>#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)             \<br>{                                                        \<br>  swprintf(str,                                          \<br>           L"%04d-%02d-%02d %02d:%02d:%02d.%06ld %+hd",  \<br>           tm.year,                                      \<br>           tm.month,                                     \<br>           tm.day,                                       \<br>           tm.hour,                                      \<br>           tm.minute,                                    \<br>           tm.second,                                    \<br>           tm.fraction,                                  \<br>           tm.tz_hour);                                  \<br>}<br><br></pre>
for MS SQL 2008:<br>
      <pre>#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)                    \<br>{                                                               \<br>  sprintf(str,                                                  \<br>            "%04d-%02d-%02d %02d:%02d:%02d.%07ld %+hd:%hd",     \<br>            tm.year,                                            \<br>            tm.month,                                           \<br>            tm.day,                                             \<br>            tm.hour,                                            \<br>            tm.minute,                                          \<br>            tm.second,                                          \<br>            tm.fraction,                                        \<br>            tm.tz_hour,                                         \<br>            tm.tz_minute);                                      \<br>}<br><br><br></pre>
      <p>for MS SQL 2008 and #define OTL_UNICODE:<br>
      </p>
      <pre>#define OTL_ODBC_TIMESTAMP_TO_STRING(tm,str)                    \<br>{                                                               \<br>  swprintf(str,                                                 \<br>           L"%04d-%02d-%02d %02d:%02d:%02d.%07ld %+hd:%hd",     \<br>           tm.year,                                             \<br>           tm.month,                                            \ <br>           tm.day,                                              \<br>           tm.hour,                                             \<br>           tm.minute,                                           \<br>           tm.second,                                           \<br>           tm.fraction,                                         \<br>           tm.tz_hour,                                          \<br>           tm.tz_minute);                                       \<br>}<br></pre>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;"><a
 name="OTL_ODBC_TIME_ZONE"></a>OTL_ODBC_<br>
TIME_ZONE<br>
      </td>
      <td style="vertical-align: top;">This #define enables tz_hour,
and tz_minute fields in the <a
 href="otl3_stream_class.htm#otl_datetime">otl_datetime</a> class. ODBC
doesn't support the time zone components yet, so this #define needs to
be used with #define <a href="#OTL_ODBC_STRING_TO_TIMESTAMP">OTL_ODBC_STRING_TO_TIMESTAMP</a>
and #define <a href="#OTL_ODBC_TIMESTAMP_TO_STRING">OTL_ODBC_TIMESTAMP_TO_STRING</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_FREETDS_ODBC_WORKAROUNDS"></a>OTL_FREETDS_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">ODBC_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">WORKAROUNDS</span><br>
      </td>
      <td style="vertical-align: top;">FreeTDS/ODBC doesn't seem to
implement the database session's "auto-commit off" mode, so
otl_connect's <a href="otl3_connect_class.htm#rlogon">auto_commit</a>&nbsp;
has no effect. In order to work around this deficiency, this #define
should be used. When the #define is enabled, OTL executes "begin
transaction" statement before each transaction. otl_connect::commit()
or otl_connect::rollback() can be used to commit or roll back the
transaction. When FreeTDS/ODBC implements the database session's
"auto-commit off" mode, the #define could be safely removed, because
the otl_connect's auto-commit parameter would take effect on the
database sessions. For the time being, this #define is recommended for
use with FreeTDS/ODBC against MS SQL. otl_connect::<a
 href="otl3_connect_class.htm#auto_commit_on">auto_commit_on</a>() /
otl_connect::<a href="otl3_connect_class.htm#auto_commit_off">auto_commit_off</a>()
functions don't work for MS SQL with FreeTDS/ODBC. Until a fix becomes
available, it's not recommended to use them.<br>
      <br>
Sybase is slightly d<span style="font-weight: bold;">i</span>fferent:
otl_connect::<a href="otl3_connect_class.htm#auto_commit_on">auto_commit_on</a>()
/
otl_connect::<a href="otl3_connect_class.htm#auto_commit_off">auto_commit_off</a>()
functions seem to work even though the otl_connect::rlogon()'s
auto_commit doesn't work. After rlogon() has been called, it's
recommended to call auto_commit_off(). See <a
 href="otl4_sybsql_freetds_examples.htm">Sybase
SQL Server / FreeTDS ODBC</a> examples for more detail.<br>
      <br>
In FreeTDS/ODBC, the default for the database session's auto-commit
mode is "auto-commit ON", which can't be turned off or on again. When
#define OTL_FREETDS_ODBC_WORKAROUNDS is enabled, OTL emulates the
database session's "auto-commit off" mode by executing "begin
transaction" at the beginning of each transaction, and not executing
anything when the "auto-commit" is set to ON, which is the default in
FreeTDS/ODBC. <br>
&nbsp;<br>
Also, FreeTDS/ODBC doesn't support "transaction isolation" level, that
is, otl_connect::<a
 href="otl3_connect_class.htm#set_transaction_isolation_level">set_transaction_isolation_level</a>()
has no effect. Until the feature is implemented in FreeTDS/ODBC, it's
recommended that explicit server side settings should be used instead.
For example, MS SQL supports an explicit (NOLOCK) option on the FROM
clause in a SELECT statement. Sybase has the "set transaction isolation
level X" command to set an explicit, session-wide transaction isolation
level.<span style="font-family: monospace;"><br>
      </span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_MAP_SQL_GUID_TO_CHAR"></a>OTL_MAP_<br>
SQL_GUID_<br>
TO_CHAR</span><br>
      </td>
      <td style="vertical-align: top;">Before OTL 4.0.140, MS SQL GUIDs
(uniqueidentifier) were mapped to char[XXX]. OTL 4.0.140 and
higher&nbsp; maps the GUIDs to <a href="otl3_bind_variables.htm#raw">raw</a>[16],
This #define should be used to map GUIDs to char[XXX] by default. Of
course, the new default mapping can be overriden manually Also, see
example <a href="otl3_ex105.htm">105</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_MAP_SQL_BINARY_TO_CHAR"></a>OTL_MAP_<br>
SQL_BINARY_<br>
TO_CHAR</span><br>
      </td>
      <td style="vertical-align: top;">Before OTL 4.0.140, MS SQL
TIMESTAMPs were mapped to char[XXX], which was effectively a conversion
from the binary format to the hexadecimal string format. OTL 4.0.140
and higher maps MS SQL TIMESTAMPs to <a
 href="otl3_bind_variables.htm#raw">raw</a>[XXX]. This #define should
be used to map MS SQL TIMESTAMPs to&nbsp; the hexadecimal string format
by default. Of course, the new default mapping can be overriden
manually.&nbsp; </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_MAP_SQL_VARBINARY_TO_RAW_LONG"></a>OTL_MAP_<br>
SQL_VARBINARY_<br>
TO_RAW_LONG</span><br>
      </td>
      <td style="vertical-align: top;">Before OTL 4.0.140,, "<a
 href="otl3_bind_variables.htm#raw">binary</a>" database types were
mapped to <a href="otl3_bind_variables.htm#raw_log">raw_long</a>. OTL
4.0.140 and higher maps the "binary" types to <a
 href="otl3_bind_variables.htm#raw">raw</a>[XXX]&nbsp; This #define
should be used to map the binary types to raw_long by default. Of
course, the new default mapping can be overriden manually.&nbsp; Also,
see example <a href="otl4_ex346.htm">346</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE"></a>OTL_STREAM_<br>
LEGACY_<br>
BUFFER_<br>
SIZE_TYPE</span><br>
      </td>
      <td style="vertical-align: top;">OTL 4.0.115 introduces a larger
datatype for the OTL stream <a href="otl3_stream_class.htm#buffer_size">buffer
size</a>: <span style="font-style: italic;">int</span> instead of the
old <span style="font-style: italic;">short int</span>. The buffer
size parameter was short int for a long time to keep all OTL based code
compatible with older database APIs (like original OCI7, or
restrictions on some old ODBC drivers), and portable across platforms /
databases. Now is time to move on. "int" as a datatype for the buffer
size provides a much wider value range. "int" is the default for the
OTL stream buffer size parameter from OTL 4.0.115 and on. However,
those old, legacy applicationz based on OTL cannot be left behind. This
#define, when enabled, turns the old "short int" type for the buffer
size back on.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_FUNC_THROW_SPEC_ON"></a><b>OTL_FUNC<br>
_THROW_SPEC_ON</b>&nbsp;</font></td>
      <td style="vertical-align: top;">This
#define works in a combination with #define <a
 href="otl3_compile.htm#OTL_ANSI_CPP">OTL_ANSI_CPP</a>
(when OTL_ANSI_CPP is defined). This #define enables the <i>function
throw
specification clause </i>(introduced in OTL 4.0.50) in all OTL
functions,
to make them explicitly declare what type C++ exceptions the function
may
throw. It looks like there is no consesus in the C++ community whether
function throw specs are good or not, and I decided to make it up to
each
OTL user to whether enable or not enable this OTL feature&nbsp; by
introducing
this #define. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_LEGACY_NUMERIC_TYPES"></a>OTL_ORA_<br>
LEGACY_<br>
NUMERIC_TYPES</span><br>
      </td>
      <td style="vertical-align: top;">This #define should be used in a
combination with #define <a href="#OTL_ORA10G">OTL_ORA10G,</a> or <a
 href="#OTL_ORA10G_R2">OTL_ORA10G_R2,</a> or <a href="#OTL_ORA11G">OTL_ORA11G</a>.
It disables the use of OCI10 native SQLT_BDOUBLE / SQLT_BFLOAT
bindings, and reverts to <code>SQLT_FLT</code> bindings, which are
compatible with older versions of the OCI. This define can be enabled
when the Oracle Client 10g, or 11g is used against older versions of
the
Oracle server, say, Oracle 9.2. When the OCI10 native SQLT_BDOUBLE /
SQLT_BFLOAT bindings are used via the Oracle 10 Client with, say,
Oracle 9i database backend, the bindings don't work, because the Oracle
9i server doesn't support them. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="OTL_ORA_MAP_BIGINT_TO_LONG"></a><span style="font-weight: bold;">OTL_ORA_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">MAP_BIGINT_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">TO_LONG</span><br>
      </td>
      <td style="vertical-align: top;">This #define enables the mapping
from &lt;<a href="otl3_bind_variables.htm#bigint">bigint</a>&gt; for
64-bit OCIs for LP64 platforms to signed 64-bit longs. It's a more
efficient alternative to the char[XXX] binding and bigint-string /
string-bigint conversion (see also the following #define's: <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>,&nbsp; <a
 href="otl3_compile.htm#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR,</a>&nbsp;&nbsp;
      <a href="otl3_compile.htm#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_MAP_LONG_TO_SQL_C_SBIGINT"></a>OTL_MAP_<br>
LONG_TO_<br>
SQL_C_SBIGINT</span><br>
      </td>
      <td style="vertical-align: top;">In the ODBC/DB2 CLI standard,
SQL_C_SLONG contains 32 bits regardless of the size of "long int" on a
given 64-bit platform. Similarly, SQL_C_SBIGINT is a signed 64-bit
integer, regardless of whether the platform is 32-bit or 64-bit. ODBC
drivers have different implementations of SQL_C_SLONG, meaning that
some ODBC drivers deviate from the standard. OTL tries to cover all
implementations of the SQL_C_SLONG. This #define maps "long" (in bind
variable declarations) into SQL_C_SBIGINT in case if sizeof(long) == 8.
For example, <span style="font-family: monospace;">:v1&lt;long&gt;</span>
will be mapped to SQL_C_SBIGINT, which is a signed 64-bit integer. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_NO_TMPL_MEMBER_FUNC_SUPPORT"></a>OTL_NO_TMPL_<br>
MEMBER_<br>
FUNC_<br>
SUPPORT</span><br>
      </td>
      <td style="vertical-align: top;">OTL 4.0.127 or higher tries to
use template member functions for implementing operator
&gt;&gt;/&lt;&lt; for numeric data types (int, unsigned, short, long,
float, double, signed 64-bit int) for C++ compilers that have support
for the feature.&nbsp; However, even after so many years since the C++
standard was adopted back in the summer of 1998, some C++ compilers
either still have bugs in their support of the feature, or are missing
any support completely. If that happens, it's possible to make OTL fall
back on the old proven plain nontemplate member functions. This #define
can be used to do just that.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_SUBSCRIBE"></a>OTL_ORA_<br>
SUBSCRIBE</span><br>
      </td>
      <td style="vertical-align: top;">This #define enables the <a
 href="otl4_subscriber.htm">otl_subscriber</a> class. The class is
Oracle 9/10 (or higher) specific. It uses the Oracle Change
Notification OCI functions, which allow the user to get notified about
changes on database tables of interest. This feature is especially
useful in an Oracle RAC environment, though the interface works in a
stand alone Oracle instance. When #define OTL_ORA_SUBSCRIBE is enabled,
the following #define's need to enabled as well:<br>
      <pre>#define OTL_ORA_OCI_ENV_CREATE<br>#define OTL_ORA_OCI_ENV_CREATE_MODE (OCI_THREADED|OCI_OBJECT|OCI_EVENTS)<br></pre>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_UTF8"></a>OTL_ORA_UTF8</span><br>
      </td>
      <td style="vertical-align: top;">This #define enables OCI9i/10g
support for Oracle UTF8 character encodings (UTF8, AL32UTF8). This
#define is mutually exclusive with #define <a href="#OTL_UNICODE">OTL_UNICODE</a>,
which supports UTF-16. UTF-8 seems to be more popular <big>with Oracle
C++ <small>developers at least in Linux/Unix. The basic difference
between UTF-8 and UTF-16 is that UTF-8 is byte oriented. It's okay to
use a '\0' terminated array of unsigned chars with UTF-8 as opposed to
an array of unsigned 16-bit integers with UTF-16.</small></big><br>
      </td>
    </tr>
    <tr style="font-weight: bold;">
      <td style="vertical-align: top;"><a
 name="OTL_ORA7_STRING_TO_TIMESTAMP"></a>OTL_ORA7_<br>
STRING_TO_<br>
TIMESTAMP<br>
      </td>
      <td style="vertical-align: top;"><span
 style="font-weight: normal;">OCI7 is still important even when used
against Oracle 9i or Oracle 10g. In fact, OCI7 is supported by all
Oracle Clients with no exception, and it is called the <span
 style="font-style: italic;">classic OCI</span>. In addition to DATE,
Oracle 9i introduced TIMESTAMP as a new temporal datatype which
supports fractional parts of the second: milliseconds, microseconds,
etc. Sometimes, there is a need to use TIMESTAMPs and OCI7 together in
order to enhance legacy applications. This #define makes the use of
TIMESTAMPs transparaent through OCI7. For example:<br>
      <br>
      <span style="font-family: monospace;">#define
OTL_ORA7 // Compile OTL 4.0/OCI7</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">#define <a
 href="#OTL_ORA7_TIMESTAMP_TO_STRING">OTL_ORA7_TIMESTAMP_TO_STRING</a>(tm,s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;
sprintf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"%02d/%02d/%04d %02d:%02d:%02d.%06ld",\</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">#define <a
 href="#OTL_ORA7_STRING_TO_TIMESTAMP">OTL_ORA7_STRING_TO_TIMESTAMP</a>(s,tm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;
sscanf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"%02d/%02d/%04d %02d:%02d:%02d.%06ld", \</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
      <br>
#define </span><big><big><span style="font-weight: normal;"><small><small>OTL_ORA7_STRING_TO_TIMESTAMP
and #define </small></small></span><span style="font-weight: normal;"><small><small>OTL_ORA7_TIMESTAMP_TO_STRING
should be used together as shown in the example above. These #defines
define string-to-timestamp and timestamp-to-string conversion so that
operator&lt;&lt;/&gt;&gt;(otl_datetime&amp;) can be used transparently
with :var&lt;char[XXX]&gt; bind variables. Also, see example <a
 href="otl4_ex473.htm">473</a>.<br>
      <br>
Oracle 10g seems to have a bug that when #define <a
 href="#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a> is enabled, it takes
much more time than usual to retrieve timestamp values from a table.
The same bug was reported with the Oracle 10g JDBC driver, so it may be
a deficiency in the Oracle network protocol. #define
OTL_ORA7_TIMESTAMP_TO_STRING and #define OTL_ORA7_STRING_TO_TIMESTAMP
are supported for OTL/ORA8,8i,9i,10g,11g, and can be used as a
workaround for the Oracle network protocol deficiency. Under #define <a
 href="#OTL_UNICODE">OTL_UNICODE</a>, </small></small></span></big></big><span
 style="font-weight: normal;">the following </span><big><big><span
 style="font-weight: normal;"><small><small>OTL_ORA7_STRING_TO_TIMESTAMP/</small></small></span></big></big><big><big><span
 style="font-weight: normal;"><small><small>OTL_ORA7_TIMESTAMP</small></small></span></big></big><span
 style="font-weight: normal;">_TO_STRING
can be used:<br>
      <br>
      </span><span style="font-weight: normal;"><span
 style="font-family: monospace;">#define <a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ORA7_TIMESTAMP_TO_STRING">OTL_ORA7_TIMESTAMP_TO_STRING</a>(tm,s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;
swprintf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
L"%02d/%02d/%04d %02d:%02d:%02d.%06ld",\</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
      <br style="font-family: monospace;">
      <span style="font-family: monospace;">#define <a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_ORA7_STRING_TO_TIMESTAMP">OTL_ORA7_STRING_TO_TIMESTAMP</a>(s,tm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;
swscanf(s,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
L"%02d/%02d/%04d %02d:%02d:%02d.%06ld", \</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.month,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.day,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.year,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.hour,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.minute,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.second,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;tm.fraction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
      </span><br>
      <a style="font-weight: normal;" href="#OTL_UNICODE"><big><big><span
 style="font-weight: normal;"></span></big></big></a><big><big><span
 style="font-weight: normal;"><small><small><br>
      </small></small></span></big></big> <span
 style="font-weight: normal;"><br>
      </span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a style="font-weight: bold;"
 name="OTL_ORA7_TIMESTAMP_TO_STRING"></a><span
 style="font-weight: bold;">OTL_ORA7_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">TIMESTAMP_TO_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">STRING</span><br>
      </td>
      <td style="vertical-align: top;">This #define should be used
together with #define <span style="font-weight: normal;"><small><small><a
 href="#OTL_ORA7_STRING_TO_TIMESTAMP">OTL_ORA7_STRING_TO_TIMESTAMP</a>.</small></small></span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_MAP_STRINGS_TO_CHARZ"></a>OTL_ORA_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">MAP_STRINGS_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">TO_CHARZ</span><br>
      </td>
      <td style="vertical-align: top;">OTL normally binds a variable
size string buffer (host variable) with both VARCHAR() and CHAR()
columns. ODBC and DB2 CLI handle variable size vs padded string
comparison semantic correctly for both types of string columns. OCIx do
that a little bit differently. So, when OTL/OCIx is used with CHAR()
columns, if,, say, a WHERE clause has a char[XXX] bind variable, the
actual strings for the WHERE clause need to be padded to the full
length of the CHAR() columns. #define OTL_ORA_MAP_STRINGS_TO_CHARZ
changes the OTL default binding of string host variables. When the
#define is enabled, OTL makes "CHARZ" type string bindings, which
behaves exactly the same as ODBC / DB2 CLI. However, this type of
string binding has a slightly higher runtime overhead. It's up to the
database developer to make the right decision on balancing out
performance vs protability / readability of the source code.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;"><a
 name="OTL_ORA_MAX_UNICODE_VARCHAR_SIZE"></a>OTL_ORA_<br>
MAX_UNICODE_<br>
VARCHAR_<br>
SIZE</td>
      <td style="vertical-align: top;">When <a href="#OTL_UNICODE">OTL_UNICODE</a>,
      <a href="#OTL_ORA8I">OTL_ORA8I</a> / <a href="#OTL_ORA9I">OTL_ORA9I</a>
are enabled, and the stream is instantiated with a SELECT statement
that has two (or more) large VARCHAR2(4000), or NVARCHAR2(2000), Oracle
may generate the following error: ORA-01461 (Invalid length...). The
error has to do with the fact that Oracle (8i/9i) treats large
VARCHAR2s / NVARCHAR2s as LONGs, which means that there may be only one
large VARCHAR2 / NVARCHAR2 in a SELECT statement. The only workaround
that Oracle Corporation recommends for Oracle 8i/9i is that the size
of&nbsp; large VARCHAR2s/NVARCHAR2s on a SELECT statement needs to be
limited to 4000 bytes. For PL/SQL block that have large
VARCHAR2/NVARCHAR2 the workaround doesn't apply, that is, there is no
such error, simply because PL/SQL treats large strings differently.
#define OTL_ORA_MAX_UNICODE_VARCHAR_SIZE implements the workaround:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_UNICODE<br>
#define OTL_ORA8I<br>
//#define OTL_ORA9I<br>
int my_max_unicode_varchar_string_size=32000; <br>
&nbsp; // in bytes, the number is not precise, <br>
&nbsp; // the actual maximum may be higher<br>
#define OTL_ORA_MAX_UNICODE_VARCHAR_SIZE (</span><span
 style="font-family: monospace;">my_max_unicode_varchar_string_size)</span><br>
      <span style="font-family: monospace;">#include &lt;otlv4.h&gt;<br>
...<br>
      </span><span style="font-family: monospace;">&nbsp;
my_max_unicode_varchar_string_size=32000; // in bytes<br>
&nbsp; otl_stream o(...); // PL/SQL block that has large
VARCHAR/NVARCHAR strings<br>
...<br>
      </span><span style="font-family: monospace;">&nbsp;
my_max_unicode_varchar_string_size=4000; // in bytes<br>
&nbsp; otl_stream s(...); // SELECT statement that has two or more
large VARCHAR2/NVARCHAR2 strings<br>
      </span><span style="font-family: monospace;">&nbsp;
my_max_unicode_varchar_string_size=32000; // in bytes<br>
...<br>
      <br>
      </span>All of the above is NOT needed under #define OTL_ORA10G /
OTL_ORA10G_R2, or when there is no more than one large
VARCHAR2/NVARCHAR2 in the same SELECT. Sorry for this complicated
stuff: a compliacted bug requires a kludgy fix. The workaround is not
needed for Oracle 10g because Oracle 10g changed the architecture,
compared with Oracle 9i in how large Unicode VARCHAR2 / NVARCHAR2 are
handled inside the Oracle Client / Server.<br>
      <br>
      <span style="font-family: monospace;"></span><br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_OCI_ENV_CREATE"></a>OTL_ORA_<br>
OCI_ENV_<br>
CREATE</span><br>
      </td>
      <td style="vertical-align: top;">This #define can only be used
when one of the following is defined: <a href="#OTL_ORA8I">OTL_ORA8I</a>,
      <a href="#OTL_ORA9I">OTL_ORA9I</a>, <a href="#OTL_ORA10G">OTL_ORA10G</a>,
      <a href="#OTL_ORA10G_R2">OTL_ORA10G_R2</a>. The #define enables
OCI Environment Handle initialization via OCIEnvCreate() instead of the
older OCIInitialize() + OCIEnvInit() scheme. I don't want to go too
deep into the discussion of what works, and what doesn't work. Those
who want to use OCIEnvCreate(), be my guests.<br>
      <br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_OCI_ENV_CREATE_MODE"></a>OTL_ORA_<br>
OCI_ENV_<br>
CREATE_<br>
MODE</span><br>
      </td>
      <td style="vertical-align: top;">This define should be used in a
combination with #define <a href="#OTL_ORA_OCI_ENV_CREATE">OTL_ORA_OCI_ENV_CREATE</a>.
When OTL_ORA_OCI_ENV_CREATE_MODE is defined, it overrides the mode
(OCI_DEFAULT/OCI_THREADED) in which OCI environment handles will be
created. For example:<br>
      <br>
      <span style="font-family: monospace;">#define
OTL_ORA_OCI_ENV_CREATE </span><br style="font-family: monospace;">
      <span style="font-family: monospace;">#define
OTL_ORA_OCI_ENV_CREATE_MODE OCI_THREADED</span><br
 style="font-family: monospace;">
      <br>
The problem that this #define is trying to address is that the
"default/threaded" mode was passed into otl_connect::otl_initialize()
once in the whole program, instead of having to pass the same parameter
into all calls to otl_connect::<a
 href="otl3_connect_class.htm#rlogon_xa">rlogon</a>() or <a
 href="otl3_connect_class.htm#server_attach">server_attach(</a>). When
this #define is enabled, it overrides everything else, so that the
custom code wouldn't have to be changed. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_STREAM_NO_PRIVATE_BOOL_OPERATORS"></a>OTL_STREAM_<br>
NO_PRIVATE_<br>
BOOL_<br>
OPERATORS</span><br>
      </td>
      <td style="vertical-align: top;">By default, OTL makes
otl_stream::operator&gt;&gt;(bool&amp;) and operator&lt;&lt;(const
bool) private because they are not implemented, and in some cases it is
very confusing when the C++ compiler use a different operator, say,
instead of operator&gt;&gt;(bool&amp;) . It makes it harder to track
down bugs in the code at runtime.&nbsp; By making the operators
private,&nbsp; the runtime bugs of that sort become more obvious at
compile time. However, there may be legitimate use cases when there is
a need to overload operator&gt;&gt;(bool&amp;) and
operator&lt;&lt;(const bool). This #define, when enabled, prevents OTL
from declaring private operator&gt;&gt;(bool&amp;) and
operator&lt;&lt;(const bool) in the otl_stream class.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_STREAM_NO_PRIVATE_UNSIGNED_LONG_OPERATORS"></a>OTL_STREAM_<br>
NO_PRIVATE_<br>
UNSIGNED_<br>
LONG_<br>
OPERATORS</span><br>
      </td>
      <td style="vertical-align: top;">By default, OTL makes
otl_stream::operator&gt;&gt;(unsigned long&amp;) and
operator&lt;&lt;(const unsigned long) private because they are not
implemented,
and in some cases it is very confusing when the C++ compiler use a
different operator, say, instead of operator&gt;&gt;(unsigned
long&amp;). It
makes it harder to track down bugs in the code at runtime.&nbsp; By
making
the operators private,&nbsp; the runtime bugs of that sort become more
obvious at compile time. However, there may be legitimate use cases
when there is a need to overload operator&gt;&gt;(unsigned long&amp;)
and
operator&lt;&lt;(const unsigned long). This #define, when enabled,
prevents OTL
from declaring private operator&gt;&gt;(unsigned long&amp;) and
operator&lt;&lt;(const unsigned long) in the otl_stream class.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT"></a>OTL_STRICT_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">NUMERIC_TYPE_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">CHECK_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">ON_SELECT</span><br>
      </td>
      <td style="vertical-align: top;">By default on an SELECT
statement, or a stored procedure that returns an implcit result set
(ODBC, DB2 CLI) / a reference cursor (PL/SQL), OTL tries to describe
the [SELECT] output columns, and map internal datatypes to external C++
datatypes.&nbsp; In the case of internal numeric datatypes, the
corresponding external C++ datatypes may not have exactly the same
domain as the internal datatypes. And, say, the values are being read
into a variable of a third numeric datatype. In this case OTL has to
convert the values from one numeric datatype to another. This #define
(OTL_STRICT_NUMERIC_TYPE_CHECK_ON_SELECT) enforces the exact match
between the output variable's datatype that's the internal numeric
value is being read into, and the datatype of the internal value
itself. <br>
      <br>
In some cases, as it was mentioned in the previous paragraph, the
internal-to-external numeric datatype mapping is not exact. In those
case, the numeric [SELECT] column's datatype may be explicitly <a
 href="otl3_bind_variables.htm#SELECT_OVERRIDE">overriden</a> to ensure
the exact match between the internal and the external datatypes. Also,
if the external and internal datatypes match exactly, OTL provides a
small performance boost by avoiding any numeric datatype conversion. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_ODBC_SQL_EXTENDED_FETCH_ON"></a><b>OTL_ODBC_SQL<br>
_EXTENDED<br>
_FETCH_ON</b> <br>
      </font></td>
      <td style="vertical-align: top;">(for ODBC and
DB2-CLI). Forces
OTL to generate calls to
SQLExtendedFetch
(buffer size &gt; 1), or SQLFetch (buffer size ==1), instead of
SQLFetchScroll,
in case if the ODBC level is greater of equal to ODBC 3.0. This #define
is introduced to mainly fix a bug in DB2-CLI in Linux, and some ODBC
drivers,
when CLOBs/BLOBs are being fetched with SQLFetchScroll(). </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE"></a><span
 style="font-weight: bold;">OTL_ODBC_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">SELECT_STM_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">EXECUTE_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">BEFORE_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">DESCRIBE</span><br>
      </td>
      <td style="vertical-align: top;">This #define (#define
OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE) should be used in a
combination with #define OTL_ODBC, and it changes the OTL stream's
default sequence of ODBC functions in the case of SELECT statement. The
default from sequence is as follows: SQLPrepare(),
SQLDescribeCol(),..., SQLBindParameter(),..., SQLExecute(), SQLFetch().
New ODBC drivers tend to do more optmization of database round-trips,
and they return the SELECT column descriptions along with the first
batch of rows. The ODBC specifation calls this kind of optimization an
implementaion detail, and leaves it up to the implometors of ODBC
driver. In the case of such optimization, the sequence of ODBC function
becomes this: SQPrepare(), SQLBindParameter(),..., SQLExecute(),
SQLDescribeCol(), ..., SQLFetch().<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_ORA_DECLARE_COMMON_READ_STREAM_INTERFACE"></a>OTL_ORA_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">DECLARE_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">COMMON_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">READ_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">STREAM_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">INTERFACE</span><br>
      </td>
      <td style="vertical-align: top;">(for OCI8/8i/9i/10g only). Whe
this #define is enabled, OTL declares the following abstract /
interface class which both <a href="otl4_refcur_stream.htm">otl_refcur_stream</a>
and <a href="otl3_stream_class.htm">otl_stream</a> get derived from:<br>
      <br>
      <small><small><small><small><small><span
 style="font-family: monospace;">class otl_read_stream_interface{</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">public:</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; </span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual int is_null(void) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual void rewind(void) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual int eof(void) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; operator&gt;&gt;(otl_datetime&amp; s) =
0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; operator&gt;&gt;(char&amp; c) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; operator&gt;&gt;(unsigned char&amp; c) =
0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp;
operator&gt;&gt;(OTL_STRING_CONTAINER&amp; s) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; operator&gt;&gt;(char* s) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; operator&gt;&gt;(unsigned char* s) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; operator&gt;&gt;(int&amp; n) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(unsigned&amp; u) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(short&amp; sh) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(long int&amp; l) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(float&amp; f) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(double&amp; d) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(otl_long_string&amp;
s) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual
otl_read_stream_interface&amp; </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">operator&gt;&gt;(otl_lob_stream&amp;
s) = 0;</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">&nbsp; virtual otl_column_desc* </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">describe_select(int&amp; desc_len) = 0;<br>
      <br>
&nbsp; <a name="describe_out_vars"></a>virtual otl_var_desc*
describe_out_vars(int&amp; desc_len);<br>
      </span></small></small></small></small></small>&nbsp;&nbsp;&nbsp;
      <span style="font-family: monospace;"><a
 name="describe_next_out_var"></a>virtual otl_var_desc*
describe_next_out_var(void);<br>
      </span><br>
&nbsp;&nbsp;&nbsp; <small><small><small><small><small><span
 style="font-family: monospace;">virtual
~otl_read_stream_interface(){}</span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><br>
      <small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;">};<br>
      <br>
      </span></small></small></small></small></small><small><small><small><small><small><span
 style="font-family: monospace;"></span></small></small></small></small></small>This
interface is useful when there is a lot of common code for
fetching rows either via otrl_stream or via otl_refcur_stream.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_ORA_DOES_NOT_UNDEF_MIN_MAX"></a><b>OTL_ORA_<br>
DOES_NOT_<br>
UNDEF_<br>
MIN_MAX</b> </font></td>
      <td style="vertical-align: top;">OTL/OCI8/8i/9i/10g #undef's
#define min and #define max that are defined in one of the OCI header
files. This was done because in some cases min() and max() were
declared as functions in C++ standard header files. However, when ATL
is used, min() and max() are defined as #define's in "windef.h". If the
OTL header file is included after the windef.h file, the min() and
max() #defines get #undef''ined by OTL, so the symbols become
unavailable. When #define OTL_ORA_DOES_NOT_UNDEF_MIN_MAX) is enabled,
it makes OTL keep #define min and #define max as they were defined (if
they were defined).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_ORA_TEXT_ON"></a><b>OTL_ORA<br>
_TEXT_ON</b>. <br>
      </font></td>
      <td style="vertical-align: top;">When
fstream.h gets
included before the OTL header file, fstream.h declares object "text",
which is part of the C++ stream environment. Oracle OCI header files
use
symbol "text" as well. Depending on the platform and the C++ compiler,
symbol "text" is defined in OCI either as a typedef or a #define. In
any
case, it interferes with the C++ "text", defined in fstream.h. #define
OTL_ORA_TEXT_ON is introduced to fix the problem. So, all the user
needs
to do in order to make fstream.h and the OTL header compile together is
to put #define OTL_ORA_TEXT_ON before including the OTL header file,
and
after #include &lt;fstream.h&gt;. In the case of fstream.h being
include after
the OTL header file, #define OTL_ORA_TEXT_ON also needs to be defined
before
the inclusion of the OTL header file. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_ORA_TIMESTAMP"></a><b>OTL_ORA<br>
_TIMESTAMP</b></font></td>
      <td style="vertical-align: top;">This
#define
enables support for Oracle 9i's timestamps, timestamps with time zones,
and timestamps with local time zones. The #define forces OTL to use the
OCI "OCIDateTime*" resource instead
of the OCI 7-byte date structure. OCIDateTime allows the timestamp
values
(down to microseconds and time zone hours/minutes) to be written and
read. OCI 8.1.7 has support for
OCIDateTime's when they are used with Oracle 9i on the back end,
meaning
that Oracle Client 8.1.7 can be connected to Oracle 9i, and
OTL_ORA_TIMESTAMP
can be enabled at the same time. In other words, #define OTL_ORA8I, or
#define OTL_ORA9I can be used&nbsp; in a combination with
OTL_ORA_TIMESTAMP,
if the underlynig Oracle Client (OCI) libraries have the corresponding
functionality.<br>
      <br>
PL/SQL (index-by) tables of otl_datetime's, that are bound with "tables
of timestamps" are not supported this time around, due to some bugs in
the OCI code (I just could not track down the problem: no info on
metalink.oracle.com,
no references on dejanews either, no code samples). TIMESTAMPs, as
parametrs
in stored procedures, can be used with otl_datetime's. PL/SQL
(index-by)
table can be boud with "tables of DATEs", as usual. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><span
 style="font-weight: bold;"><a name="OTL_STR_TO_BIGINT"></a>OTL_STR_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">_TO_BIGINT</span>(str,n)</font> </td>
      <td style="vertical-align: top;">This #define is required when <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>
is enabled and when one of OTL_ORAxx #defines is enabled, in order to
support OTL internal string-to-bigint conversion. This #define is
supposed to provide string-to-bigint conversion code that is most
probably C++
compiler specific (because 64-bit ints are not part of the ANSI C++
standard), for example:<br>
      <br>
      <pre>#if defined(__GNUC__) // GNU C++<br><br>#include &lt;stdlib.h&gt;<br><br>#define <a
 href="#OTL_BIGINT">OTL_BIGINT</a> long long<br><br>#define <a
 href="#OTL_STR_TO_BIGINT">OTL_STR_TO_BIGINT</a>(str,n)                \<br>{                                               \<br>  n=strtoll(str,0,10);                          \<br>}<br><br>#define <a
 href="#OTL_BIGINT_TO_STR">OTL_BIGINT_TO_STR</a>(n,str)                \<br>{                                               \<br>  sprintf(str,"%lld",n);                        \<br>}<br><br><br>#endif<br></pre>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;"><a
 name="OTL_STREAM_READ_ITERATOR_ON"></a>OTL_STREAM_<br>
READ_<br>
ITERATOR_ON<br>
      </td>
      <td style="vertical-align: top;">This #define enables the&nbsp; <a
 href="otl4_stream_read_iterator.htm">OTL stream read iterator</a>,
which provides a JDBC-like <span style="font-style: italic;">getter</span>
interface. <br>
Typically, OTL stream read iterators can be used with SELECT
statements, stored prcoredures that return implicit result sets (ODBC,
DB2-CLI), or stored procedures that return referenced cursors (Oracle).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO"></a><small>OTL_THROWS_</small></span><small><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">ON_SQL_SUCCESS_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">WITH_INFO</span></small><br>
      </td>
      <td style="vertical-align: top;">OTL/ODBC, OTL/DB2-CLI only. This
#define enables the following function: otl_connect::<a
 href="otl3_connect_class.htm#set_throw_on_sql_success_with_info">set_throw_on_sql_success_with_info</a>().&nbsp;
When the function sets the "throw flag", OTL&nbsp; throws an
otl_exceptioin
if SQLExecute() / SQLExecDirect() returns SQL_SUCCESS_WITH_INFO. By
raising an exception on SQL_SUCCESS_WITH_INFO, OTL makes it possible
to communicate messages that would normally get retrieved via
SQLGetDiagRec() calls right after SQLExecute() / SQLExecDirect()
returns. In order to get the maximum amount of diagnostic information
from the ODBC driver, this #define should be used in a combination with
#define <a href="#OTL_EXTENDED_EXCEPTION">OTL_EXTENDED_EXCEPTION</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><span
 style="font-weight: bold;"><a name="OTL_TRACE"></a></span><span
 style="font-weight: bold;">OTL_TRACE_LEVEL</span><br>
      <br>
      <span style="font-weight: bold;">OTL_TRACE_<br>
STREAM <br>
      <br>
OTL_TRACE<br>
_LINE_PREFIX <br>
      <br>
OTL_TRACE_<br>
LINE_SUFFIX<br>
      <br>
      <a name="OTL_TRACE_ENABLE_STREAM_LABELS"></a>OTL_TRACE_ENABLE_<br>
STREAM_LABELS<br>
      </span></font></td>
      <td style="vertical-align: top;"><span style="font-weight: bold;"></span>These
#defines enable OTL <span style="font-style: italic;">function call
tracing</span>. OTL tracing
uses the C++ stream interface (ostream, fstream) to log OTL function
calls with arguments, "<span style="font-style: italic;">this"</span>
addresses of class instances, etc. <br>
      <ul>
        <li>#define
OTL_TRACE_LEVEL specifies a level of OTL tracing.
Each
type of tracing is represented by its own bit in the whole trace level
unsigned&nbsp; int value:<br>
          <br>
        </li>
        <ul>
        </ul>
        <ol>
          <li>0x1 --
traces the following functions of the otl_connect
class (1st level of tracing): rlogon(), logoff(), commit(), rollback(),
auto_commit_on(), auto_commit_off()<br>
          </li>
          <li>0x2 --
traces otl_cursor::direct_exec(), direct execution
of
static SQL statements, no otl_streams (2nd level of tracing).<br>
          </li>
          <li>0x4 --
traces the following functions of the otl_stream
class: open(), close()<span style="font-weight: bold;"></span></li>
          <li><span style="font-weight: bold;"></span>0x8 -- traces
internal "execute SQL statement" function,
internal "fetch the first bacth of rows" function, internal "fetch the
next batch of rows" function (3rd level of tracing).</li>
          <li>0x10 --
traces the operator &gt;&gt; and &lt;&lt;
functions of
the otl_stream class (4th level of tracing)<span
 style="font-weight: bold;"></span></li>
          <li><a name="level_x20"></a>0x20 -- traces all <a
 href="otl3_exception_class.htm">otl_exception'</a>s raised by OTL.</li>
        </ol>
        <br>
        <br>
        <li>#define
OTL_TRACE_STREAM specifies a log stream variable,
or a
function call that returns a file stream reference. What is defined by
this #define is used as an output file stream variable inside OTL.<br>
          <br>
        </li>
        <li>#define
OTL_TRACE_LINE_PREFIX can be used to override the
default OTL trace line prefix: "OTL TRACE ==&gt;". If it is more
convenient to have something different from the default, say, for
running a Perl script on an OTL log file to mine for patterns.<br>
          <br>
        </li>
        <li>#define OTL_TRACE_LINE_SUFFIX can be used to override the
default OTL trace line suffix: "<span style="font-family: monospace;">\n</span>".
If it is more convenient to have something different from the default,
say, for running a Perl script on an OTL log file to mine for patterns.<br>
          <br>
        </li>
        <li>#define OTL_TRACE_ENABLE_STREAM_LABELS can be used to
enable logging of otl_stream labels instead of SQL statement bodies.
See The Oracle, DB2-CLI, and ODBC specific <a
 href="otl3_stream_class.htm#otl_stream_otl_stream">otl_stream </a>descriptions
for more detail.<br>
        </li>
      </ul>
#define
OTL_TRACE_LEVEL may be
either a
constant, or a variable, or a function call that returns the trace
level dynamically. If OTL_TRACE_LEVEL is not defined then tracing calls
are not generated, and therefore there is not any runtime performance
penalty. Even if #define OTL_TRACE_LEVEL is defined, performance
degradation is very small, if the level of tracing is set relatively
low.<br>
      <br>
Example:<br>
      <pre>      unsigned int my_trace_level=<br>        0x1 | // 1st level of tracing<br>        0x2 | // 2nd level of tracing<br>        0x4 | // 3rd level of tracing<br>        0x8 | // 4th level of tracing<br>        0x10| // 5th level of tracing<br>        0x20; // 6th level of tracing<br>     // each level of tracing is represented by its own bit, <br>     // so levels of tracing can be combined in an arbitrary order.<br><br>     #define OTL_TRACE_LEVEL my_trace_level <br>        // enables OTL tracing, and use my_trace_level <br>        // as a trace control variable.<br><br>     #define OTL_TRACE_STREAM cerr <br>        // directs all OTL tracing to cerr<br><br>     #define OTL_TRACE_LINE_PREFIX "MY OTL TRACE ==&gt; " <br>        // redefines the default OTL trace line prefix. <br>        // This #define is optional<br><br>     #define OTL_TRACE_LINE_SUFFIX std::endl <br>        // redefines the default OTL trace line suffix. <br>        // This #define is optional<br><br></pre>
Also,&nbsp; see OTL examples for more detail. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a name="OTL_STL"></a><b>OTL_STL</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(for turning on <i>std::strings</i>,
and STL-compliant OTL stream iterators: otl_input_iterator,
otl_output_iterator) </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_STL_NOSTD_NAMESPACE"></a><b>OTL_STL_NOSTD<br>
_NAMESPACE</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(for
excluding namespace std, when #define OTL_STL is on). This is mainly
for
fixing problem <a href="otl3_prob.htm#prob42">42.</a> </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_STLPORT"></a><b>OTL_STLPORT</b></font></td>
      <td style="vertical-align: top;">(the same as
#define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>,
only for use with STLPort 4.x). This #define makes OTL compile with
STLPort
4.x. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_STREAM_POOLING_ON"></a><b>OTL_STREAM<br>
_POOLING_ON</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(for enabling <a
 href="otl3_stream_pooling.htm">otl_stream
pooling</a>). This #define requires #define OTL_STL to be defined first
because STL containers were used in the implementation of the
otl_stream
pooling. For more detail, see examples <a href="otl3_ex113.htm">113</a>,
      <a href="otl3_ex114.htm">114</a>, <a href="otl3_ex115.htm">115</a>.
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_UNCAUGHT_EXCEPTION_ON"></a><b>OTL_UNCAUGHT<br>
_EXCEPTION_ON</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(for enabling a
safer exception
handling and error recovery). This is
for
fixing problem <a href="otl3_prob.htm#prob46">46.</a><br>
      <br>
From OTL 4.0.162 and on, the #define becomes the default in order to
address user complaints. The rationale for making it the default at
this point in time is that thr C++ compilers support the stardard C++
uncaught_exception() function more or less. OTL 4.0.167 and higher do
not enable this #define by default for Visual C++ 6.0. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;"><a
 name="OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR"></a>OTL_UNICODE_<br>
STRING_TYPE_<br>
CAST_FROM_<br>
CHAR<br>
      </td>
      <td style="vertical-align: top;">When #define <a
 href="#OTL_UNICODE">OTL_UNICODE</a>, #define <a href="##OTL_ORA8I">OTL_ORA8I</a>/<a
 href="#OTL_ORA9I">9I</a>/<a href="#OTL_ORA10G">10G</a>/<a
 href="#OTL_ORA10G_R2">10G_R2</a>, and #define <a
 href="#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a> are
enabled, a string class that is different from std::wstring may be
used, for example:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_ORA10G</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">#defined OTL_UNICODE<br>
      </span>...<span style="font-family: monospace;"><br
 style="font-family: monospace;">
      </span><span style="font-family: monospace;">#define
OTL_UNICODE_STRING_TYPE my_wide_char_string</span><br
 style="font-family: monospace;">
      <br>
Let's also assume that my_wide_char_string is not 100% compatible with
std::wstring and doesn't have the following function<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp; <tt>assign(const charT* s, size_type n)<br>
      <br>
      </tt>In order for OTL to handle wide character strings of
my_wide_char_string type, it needs to know how to efficiently make a
string out of a raw buffer + the string length. #define
OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR can be used for passing into the
OTL layer a piece
of code that does the conversion. For example, say,
ACE_TString is used:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_ORA10G_R2</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">#defined OTL_UNICODE<br>
#define OTL_UNICODE_CHAR_TYPE wchar_t<br style="font-family: monospace;">
      </span><span style="font-family: monospace;">#define
OTL_UNICODE_STRING_TYPE ACE_TString</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">#define
OTL_UNICODE_STRING_TYPE_CAST_FROM_CHAR(s, c_ptr, len) {</span><span
 style="font-family: monospace;">s.set(c_ptr,len,1);}<br>
      <br>
      </span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_USER_DEFINED_STRING_CLASS_ON"></a><b>OTL_USER_DEFINED<br>
_STRING_CLASS_ON</b></font></td>
      <td style="vertical-align: top;"><small><small><b> </b>(for
defining a string class, other than STL's <i>std::string, </i>for
reading
from/writing to the otl_stream). This #define goes in pair with #define
      <b>USER_DEFINED_STRING_CLASS</b>,
which is used to define the actual string class name.Fore more detail,
see examples <a href="otl3_ex119.htm">119</a>, <a
 href="otl3_ex120.htm">120</a>, <a href="otl3_ex121.htm">121</a> </small></small></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL"></a>OTL_USER_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">DEFINED_STRING_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">CLASS_DEFAULT_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">NULL_TO_VAL</span><br>
      </td>
      <td style="vertical-align: top;">This #define
OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL(s) can be used in the
case if a C++ string class is used with OTL in order to read string
values tothe database., and to default string NULLs to a predefined
value. If string NULLs need to be defaulted to an empty string, some
C++ string classes have more efficient ways than assigning an empty
string to an actual string variable. Especially, when the variable is
used a reusable buffer. <br>
      <br>
For example, ACE_TString has fast_clear(), which keeps the string
internal buffer. It just assigns '\0' to the first element of the
internal buffer, and sets the length indicator to 0. Here's what the
#define should look like in the case of ACE_TString and the desired
default value for string NULLs is an empty string:<br>
      <br>
      <span style="font-family: monospace;">#define
OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL(s) {s.fast_clear();}<br>
      <br>
      </span>std::string can be cleared via std::string::clear(), for
example:<br>
      <br>
      <span style="font-family: monospace;">#define
OTL_USER_DEFINED_STRING_CLASS_DEFAULT_NULL_TO_VAL(s) { s.clear();}</span><br>
      <span style="font-family: monospace;"></span><br>
This feature becomes more important if your OTL based C++ code starts
relying of defaulting string NULLs to a value, especially in a
multi-threaded environment, and an&nbsp; inefficient dynamic heap
manager.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 style="font-weight: bold;" name="OTL_UNICODE"></a><span
 style="font-weight: bold;">OTL_UNICODE</span><br>
      </font> </td>
      <td style="vertical-align: top;">This #define
enables Unicode
string support in OTL for Oracle8i (UCS-2), and for Oracle 9i/10g
(UTF-16). Character
string
lengths change from byte semantic to character semantic, meaning that
sizes
are given in characters rather than in bytes. For more detail, refer to
the corresponding Oracle manuals on nationalization / globalization.
For
example, in Oracle 8i, if a string column is, say, VARCHAR2(60), 60 is
the size of the column in bytes. In Oracle 9i, the size will be
characters.
In Oracle 10g, it maybe specified in bytes or characters. The OTL
manual is not a substitute for the Oracle manuals.<br>
      <br>
Starting with version 4.0.108, OTL supports Unicode strings for
OTL/ODBC, and OTL/DB2-CLI. Unicode string data can be accessed in
Oracle via ODBC, MS SQL via ODBC, and DB2 via DB2-CLI/ODBC. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b><a
 name="OTL_UNICODE_CHAR_TYPE"></a>OTL_UNICODE_<br>
CHAR_TYPE</b></font><br>
      </td>
      <td style="vertical-align: top;">This #define is used in a
combinatiuon with <a href="#OTL_UNICODE">OTL_UNICODE</a>. The #define
specifies a compiler specific, 2-byte Unicode character type.:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_UNICODE</span><br>
      <span style="font-family: monospace;">#define
OTL_UNICODE_CHAR_TYPE wchar_t<br>
      <br>
      </span>When your C++ compiler doesn't have any appropriate
Unicode compatible character type, <span
 style="font-family: monospace;">unsigned short</span> can be used
instead:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_UNICODE<br>
      </span><span style="font-family: monospace;">#define
OTL_UNICODE_CHAR_TYPE unsigned short</span><br>
      <br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_UNICODE_EXCEPTION_AND_RLOGON"></a>OTL_UNICODE_<br>
EXCEPTION_AND_<br>
RLOGON</span><br>
      </td>
      <td style="vertical-align: top;">This #define enables support for
Unicode <a href="otl3_exception_class.htm">otl_exception</a>'s <a
 href="otl3_exception_class.htm#unicode_msg"><span
 style="font-style: italic;">msg</span></a>, <a
 href="otl3_exception_class.htm#unicode_sqlstate"><span
 style="font-style: italic;">sqlstate</span></a> data members, and an
otl_connect::<a href="otl3_connect_class.htm#logon_odbc_unicode">rlogon</a>()
function that accepts Unicode user id, password, and DSN. This #define
should be enabled only when #define UNICODE / _UNICODE is enabled for
ODBC / DB2 CLI, In other words, when Unicode ODBC driver functions are
enabled. Also, it's recommened that this #define be used in a
conbination with <a href="#OTL_UNICODE">OTL_UNICODE,</a> and <a
 href="#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a>, for example:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_UNICODE<br>
#define OTL_UNICODE_CHAR_TYPE wchar_t<br>
#define OTL_UNICODE_EXCEPTION_AND_RLOGON<br>
      <br>
      </span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_UNICODE_STRING_TYPE"></a>OTL_UNICODE_<br>
STRING_TYPE</span><br>
      </td>
      <td style="vertical-align: top;">This #define enables <span
 style="font-family: monospace;">std::wstring</span> as 2-byte Unicode
strings in OTL. It can be used when <span
 style="font-family: monospace;">wstring</span> is based on a <span
 style="font-family: monospace;">wchar_t </span>that corresponds to
2-byte Unicode:<br>
      <br>
      <span style="font-family: monospace;">#define OTL_UNICODE</span><br>
      <span style="font-family: monospace;">#define
OTL_UNICODE_CHAR_TYPE wchar_t<br>
#define OTL_UNICODE_STRING_TYPE wstring<br>
      <br>
      </span>If your C++ compiler doesn't have <span
 style="font-family: monospace;">std::wstring</span> class defined
(say, only <span style="font-family: monospace;">std::string</span> is
defined), it is possible to instantiate <span
 style="font-family: monospace;">std::basic_string&lt;XXX&gt;</span>,
where XXX is your 2-byte Unicode type, for example, your 2-byte Unicode
is <span style="font-family: monospace;">unsigned short</span>:<br>
      <br>
      <span style="font-family: monospace;">#include &lt;string&gt;</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">namespace std{<br>
&nbsp;&nbsp;&nbsp; typedef unsigned short my_unicode_char;<br>
&nbsp;&nbsp;&nbsp; typedef basic_string&lt;my_unicode_type&gt;
my_unicode_string;<br style="font-family: monospace;">
      </span><span style="font-family: monospace;">}</span><br>
      <span style="font-family: monospace;">#define OTL_UNICODE</span><br>
      <span style="font-family: monospace;">#define
OTL_UNICODE_CHAR_TYPE my_unicode_char<br>
#define OTL_UNICODE_STRING_TYPE my_unicode_string<br>
      </span><br>
More specifically, GNU C++ doesn't implement std::wstring, so the
example above should be useful for GNU C++ at least.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT"></a>OTL_UNICODE_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">USE_ANSI_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">ODBC_FUNCS_</span><br
 style="font-weight: bold;">
      <span style="font-weight: bold;">FOR_DATA_DICT</span><br>
      </td>
      <td style="vertical-align: top;">This #define should be used as a
workaround for an MS SQL Server ODBC driver bug. It's not possible to
say for sure what the scope of the bug (or may be it's a an
undocumented feature!) is. OTL provides access to the <a
 href="otl4_append_b.htm">data dictionary</a> ODBC / DB2 CLI functions.
When Unicode ODBC function prototypes are enabled via #define UNICODE /
_UNICODE, the corresponding Unicode ODBC data dictionary functions are
enabled. However, some of the Unicode ODBC data dictionary functions
don't work correctly when the MS SQL Server Unicode ODBC driver is
used. As a workaround, ANSI ODBC data dictionary functions can be used
instead, even if the output string bind variables are Unicode. #define
OTL_UNICODE_USE_ANSI_ODBC_FUNCS_FOR_DATA_DICT makes OTL generate ANSI
ODBC data dictionary function calls instead of the Unicode ODBC data
dictionary function calls.<br>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_VALUE_TEMPLATE_ON"></a><b>OTL_VALUE<br>
_TEMPLATE_ON</b>&nbsp;</font></td>
      <td style="vertical-align: top;">(for enabling <a
 href="otl3_value.htm">otl_value&lt;T&gt;</a>).
The otl_value&lt;T&gt; template class can be also enabled with #define
OTL_STL.
#define OTL_VALUE_TEMPLATE_ON allows the template class to be enabled
without
turning on STL compliance. Not all C++ compilers compile OTL under
#define
OTL_STL. #define OTL_VALUE_TEMPLATE_ON was introduced In order to relax
that limitation. Fore more detail, see examples <a
 href="otl3_ex119.htm">119</a>, <a href="otl3_ex120.htm">120</a>, <a
 href="otl3_ex121.htm">121</a> </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><a
 name="OTL_VERSION_NUMBER"></a><b>OTL_VERSION<br>
_NUMBER</b> <br>
      </font></td>
      <td style="vertical-align: top;">This
#define
holds the version number of the OTL header file, in which the #define
is
defined. For example, OTL 4.0.17 is defined as (0x040011L). This
#define
allows the user to keep track of OTL version numbers, e.g. the #define
makes it possible to do more complex conditional compilation. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE"></a>OTL_UNCAUGHT_<br>
EXCEPTION_OWN_<br>
NAMESPACE</span><br>
      </td>
      <td style="vertical-align: top;">When OTL is used with <a
 href="http://stlport.org">STL Port</a> (#define <a href="#OTL_STLPORT">OTL_STLPORT</a>),
STL Port library may be configured not to expose some <span
 style="font-style: italic;">std::</span> functions like
uncaught_exception() in its namespace _STL. In order to work around the
problem, #define OTL OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE is introduced:<br>
      <br>
      <span style="font-family: monospace;">#define
OTL_UNCAUGHT_EXCEPTION_OWN_NAMESPACE __std_alias::</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">...</span><br
 style="font-family: monospace;">
      <span style="font-family: monospace;">#include &lt;otlv4.h&gt;<br>
      <br>
      </span>This #define tells OTL what namespace to prefix the
uncaught_exception() function with. In OTL 4.0.167 or higher, this
#define is obsolete, and has no effect.<br>
      <span style="font-family: monospace;"></span> </td>
    </tr>
  </tbody>
</table>
&nbsp;<br>
<br>
The macro definitions may be defined directly in the program's code, or
turned on via C++ compiler command line
<br>
option, e.g.: -DOTL_ODBC, -DOTL_ORA7, -DOTL_ORA8, -DOTL_ORA8I,
-DOTL_ORA9I,, -DOTL_ODBC_UNIX,
-DOTL_ODBC_MYSQL, -DOTL_DB2_CLI, -DOTL_ODBC_TIMESTEN_WIN,
-DOTL_ODBC_TIMESTEN_UNIX<br>
<p>In order to compile and link OTL with an underlying database API,
the following header
files and libraries of the database API are needed (&lt;<span
 style="font-style: italic;">ORACLE_HOME</span>&gt;,&nbsp; &lt;<span
 style="font-style: italic;">DB2_HOME</span>&gt;,&nbsp;
&lt;TimesTen_HOME&gt;, and &lt;INFORMIX_HOME&gt; are home directories
for installations of Oracle, DB2, TimesTen, and Informix):<br>
</p>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">API</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">API
header files for&nbsp; Win</span>dows<br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">API
libraries for Windows<br>
      </span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI7<br>
      </td>
      <td style="vertical-align: top;">In
&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include<br>
      </td>
      <td style="vertical-align: top;">&nbsp;&lt;<span
 style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\ociw32.lib<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI8<br>
      </td>
      <td style="vertical-align: top;">In
&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>
      <td style="vertical-align: top;">&nbsp;&lt;<span
 style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI8i<br>
      </td>
      <td style="vertical-align: top;">In
&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>
      <td style="vertical-align: top;">&nbsp;&lt;<span
 style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI9i<br>
      </td>
      <td style="vertical-align: top;">In
&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>
      <td style="vertical-align: top;">&nbsp;&lt;<span
 style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI10g<br>
      </td>
      <td style="vertical-align: top;">In
&lt;<span style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\include</td>
      <td style="vertical-align: top;">&nbsp;&lt;<span
 style="font-style: italic;">ORACLE_HOME</span>&gt;\oci\lib\&lt;compiler_specific&gt;\oci.lib</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ODBC<br>
      </td>
      <td style="vertical-align: top;">Normally,
in one of the C++ compiler system directories, no need to include
explicitly.<br>
      </td>
      <td style="vertical-align: top;">Normally,
in one of the C++ compiler system directories: odbc32.lib<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">DB2
CLI<br>
      </td>
      <td style="vertical-align: top;">In
&lt;<span style="font-style: italic;">DB2_HOME</span>&gt;\include<br>
      </td>
      <td style="vertical-align: top;">&lt;DB2_HOME&gt;\lib\db2api.lib<br>
&lt;DB2_HOME&gt;\lib\db2cli.lib<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="TIMESTEN_ODBC_WIN_COMPILE"></a>TimesTen&nbsp; ODBC<br>
      </td>
      <td style="vertical-align: top;">&#8226; Directly with the TimesTen
ODBC driver<br>
      <br>
&nbsp;&nbsp; &nbsp;&nbsp; in &lt;TimesTen_HOME&gt;\include<br>
      <br>
      <br>
&#8226; Directly with the TimesTen Client ODBC driver<br>
      <br>
&nbsp;&nbsp; &nbsp;&nbsp; in &lt;TimesTen_HOME&gt;\include<br>
      <br>
&#8226; With an ODBC driver manager (to be used with #define <a
 href="#OTL_ODBC">OTL_ODBC</a>, no TimeSten ODBC extensions are
available)<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normally,
in one of the C++ compiler system directories, no need to include
explicitly.<br>
      <br>
      </td>
      <td style="vertical-align: top;">&#8226; Directly with the TimesTen
ODBC driver<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;TimesTen_HOME&gt;\lib\TTEN70.LIB <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;TimesTen_HOME&gt;\lib\TTDV70.LIB<br>
      <br>
&#8226; Directly with the TimesTen Client ODBC driver<br>
      <br>
&nbsp;&nbsp;&nbsp; &lt;TimesTen_HOME&gt;\lib\TTCL70.LIB<br>
      <br>
&#8226; With an ODBC driver manager<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normally,
in one of the C++ compiler system directories: odbc32.lib</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Informix CLI<br>
      </td>
      <td style="vertical-align: top;">Default ODBC header files for
the C++ compiler.<br>
      </td>
      <td style="vertical-align: top;">odbc32.lib<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<table style="text-align: left; width: 987px; height: 238px;" border="1"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><small><small><small><small><small><small><small><span
 style="font-weight: bold;">API</span><br>
      </small></small></small></small></small></small></small></td>
      <td style="vertical-align: top;"><small><small><small><small><small><small><small><span
 style="font-weight: bold;">API header files for Unix</span><br>
      </small></small></small></small></small></small></small></td>
      <td style="vertical-align: top;"><small><small><small><small><small><small><small><span
 style="font-weight: bold;">API libraries for Unix</span><br>
      </small></small></small></small></small></small></small></td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI7<br>
      </td>
      <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp;
-I$(ORACLE_HOME)/rdbms/public<br>
      </td>
      <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/
-lclntsh<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI8<br>
      </td>
      <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp;
-I$(ORACLE_HOME)/rdbms/public</td>
      <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/
-lclntsh<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI8i<br>
      </td>
      <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp;
-I$(ORACLE_HOME)/rdbms/public</td>
      <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/
-lclntsh<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI9i<br>
      </td>
      <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp;
-I$(ORACLE_HOME)/rdbms/public</td>
      <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/
-lclntsh<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">OCI10g<br>
      </td>
      <td style="vertical-align: top;">-I$(ORACLE_HOME)/rdbms/demo&nbsp;
-I$(ORACLE_HOME)/rdbms/public</td>
      <td style="vertical-align: top;">-L$(ORACLE_HOME)/lib/
-lclntsh</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ODBC<br>
      </td>
      <td style="vertical-align: top;">ODBC
bridge specific. If you're using unixodbc, see its manuals for more
detail.<br>
      </td>
      <td style="vertical-align: top;">ODBC
bridge specific. If you're using unixodbc, see its manuals for more
detail </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">DB2
CLI<br>
      </td>
      <td style="vertical-align: top;">-I/&lt;<span
 style="font-style: italic;">DB2_HOME</span>&gt;/sqllib/include<br>
      </td>
      <td style="vertical-align: top;">-L/&lt;<span
 style="font-style: italic;">DB2_HOME</span>&gt;/sqllib/lib -ldb2<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><a
 name="TIMESTEN_ODBC_UNIX_COMPILE"></a>TimesTen ODBC<br>
      </td>
      <td style="vertical-align: top;">-I&lt;TimesTen_HOME&gt;/include<br>
      </td>
      <td style="vertical-align: top;">To link with the TimesTen Data
Manager ODBC Driver<br>
      <br>
&nbsp;&nbsp;&nbsp; -L &lt;TimesTen_HOME&gt;/lib -ltten<br>
      <br>
To link with the TimesTen Client ODBC Driver:<br>
      <br>
&nbsp;&nbsp;&nbsp; -L&lt;TimesTen_HOME&gt;/lib -lttclient<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Informix CLI<br>
      </td>
      <td style="vertical-align: top;">-I&lt;INFORMIX_HOME&gt;/incl/cli<br>
      </td>
      <td style="vertical-align: top;">-L&lt;INFORMIX_HOME&gt;/lib
-lifdmr -lthcli<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
For more detail, see the manul of your C++ compiler and the database
API manuals.<br>
<p></p>
<hr width="100%">
<center>
<p><a href="otl3_examples.htm">Prev</a> <a href="otl3_namespaces.htm">Next</a><a
 href="otl3.htm">Contents</a><a href="home.htm">Go
Home</a></p>
</center>
#define OTL_ODBC_SELECT_STM_EXECUTE_BEFORE_DESCRIBE
href="mailto:skuchin@aceweb.com"&gt;skuchin@aceweb.com,
a href="mailto:skuchin@gmail.com"&gt;skuchin@gmail.com.&nbsp;
<script language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
 //-->
 </script>
<p></p>
<p><i>Permission to use, copy, modify and redistribute this document
for
any purpose is hereby granted without fee, provided that the above
copyright
notice appear in all copies.</i>
</p>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
pageTracker._trackPageview();
</script>
</body>
</html>
