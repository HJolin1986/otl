<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>One-Page ODBC 2.5 API, ODBC Template Library (OTL), Version 2.1</title>
</head>
<body>
<h1>One-Page ODBC 2.5 API, ODBC Template Library (OTL),
Version 2.1</h1>
<p><i>Sergei Kuchin, email:
<a href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.com</a></i>
<xmp>Copyright (C) Sergei Kuchin, 1996, 1997, 1998, 1999
Permission to use, copy, modify and redistribute this
document for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all
copies.
</xmp></p>
<h1><a href="mailto:skuchin@gmail.com">Table of Contents</a></h1>
<ul>
  <li><a href="#sec1">1. Introduction</a>
  </li>
  <li><a href="#sec11">1.1. SQL streams</a>
  </li>
  <li><a href="#sec2">2. <i>One-page</i> ODBC API</a>
    <ul>
      <li><a href="#sec21">2.1. Connect object</a>
      </li>
      <li><a href="#sec22">2.2. otl_stream class</a>
        <ul>
          <li><a href="#sec221">2.2.1. Stream bind variables declaration</a>
          </li>
          <li><a href="#sec222">2.2.2. otl_long_string class</a>
          </li>
        </ul>
      </li>
      <li><a href="#sec23">2.3. Exception handling</a>
      </li>
      <li><a href="#sec24">2.4. Constant SQL statement or stored
procedure call</a>
      </li>
      <li><a href="#sec25">2.5. Examples</a>
        <ul>
          <li><a href="#sec251">Example 1 (with otl_stream class)</a>
          </li>
          <li><a href="#sec252a">Example 2a (with an Oracle stored
procedure call)</a>
          </li>
          <li><a href="#sec252b">Example 2b (with an MS SQL Server
stored procedure call)</a>
          </li>
          <li><a href="#sec253">Example 3 (with printf/scanf functions)</a>
          </li>
          <li><a href="#sec254a">Example 4a (with otl_stream class,
TIMESTAMP_STRUCT and Oracle)</a>
          </li>
          <li><a href="#sec254b">Example 4b (with otl_stream class,
TIMESTAMP_STRUCT and MS SQL Server)</a>
          </li>
          <li><a href="#sec255a">Example 5a (with otl_stream class,
CTime class
and Oracle)</a>
          </li>
          <li><a href="#sec255b">Example 5b (with otl_stream class,
CTime class
and MS SQL Server)</a>
          </li>
          <li><a href="#sec256">Example 6 (implicit SELECT/result set
returned by
a stored procedure, MS SQL Server)</a>
          </li>
          <li><a href="#sec257a">Example 7a (with MS SQL Server's TEXT
column)</a>
          </li>
          <li><a href="#sec257b">Example 7b (with MS SQL Server's IMAGE
column)</a>
          </li>
          <li><a href="#sec257c">Example 7c (with Oracle's LONG column)</a>
          </li>
          <li><a href="#sec257d">Example 7d (with Oracle's LONG RAW
column)</a>
          </li>
          <li><a href="#sec257e">Example 7e (with Oracle's CLOB column)</a>
          </li>
          <li><a href="#sec257f">Example 7f (with Oracle's LOB column)</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#sec3">3. STL-compliant iterators for otl_stream</a>
    <ul>
      <li><a href="#sec31">3.1. Example</a>
      </li>
    </ul>
  </li>
  <li><a href="#app_a">Appendix A. How to download the source code</a>
  </li>
  <li><a href="#app_b">Appendix B. OTL exception list</a>
  </li>
</ul>
<h1><a name="sec1"> 1. Introduction</a></h1>
<p>
<a name="sec1">This document describes the ODBC Template Library,
Version 2.1 (OTL). The library introduces a <i>one-page</i> ODBC
API in the form of </a><a href="#sec11">SQL streams</a>.
</p>
<p>
OTL is a new kind of C++ libraries, similar to the <a
 href="http://www.sgi.com/Technology/STL/">Standard Template
Library</a>. This kind of libraries is easy to use, since the user
needs only to include C++ header files which contain template classes
and inline functions. There is no need to link additional object
modules into C++ applications. The code instantiated from template
classes and inline functions is efficient and reliable in terms of
runtime performance and C++ strict type checking.
</p>
<p>
OTL automatically uses ODBC bulk operations (<a href="#sec11">SQL
streams</a> are buffered by definition) and has a higher runtime
performance than scalar operations. Runtime performance can be improved
by
increasing the stream buffer size.
</p>
<p>
OTL provides an exception handling mechanism in the format of the <a
 href="#sec23">otl_exception</a> class. This mechanism takes advantage
of C++ exception handling compared to coding database applications in
plain C. The user does not need to check out return codes after each
function call. The code, instantiated from the OTL templates and
inline functions is much nicer and cleaner in comparison with the
straight ODBC code or even with the MFC database classes.
</p>
<p>
Also, OTL integrates with the <a
 href="http://www.sgi.com/Technology/STL/">Standard Template
Library</a> by means of <a href="#sec3">STL-compliant iterator
classes</a>. This feature is very powerful because it allows to
combine the power of <a
 href="http://www.metabyte.com/%7Efbp/stl/readings.html">generic
programming</a> and a database backend into compact, reliable,
top performance and easy-to-maintain C++ database applications.
</p>
<p>
This version of OTL available for ODBC drivers, versions 2.5 or
higher. It was tested at least with ODBC drivers for MS SQL Server
6.5/7.0
and for Oracle 8.x. <a href="#sec25">Examples</a> for both Oracle 8.x
and MS SQL Server can found in chapter 2 of this manual.
</p>
<p>The fact that OTL is available in source code adds more value to
this
material -- folks new to ODBC can use the OTL source code to learn it
</p>
<p>
Besides the OTL for ODBC, there is <a href="otl_1pg.htm#">two
versions</a> of OTL for Oracle 7 and Oracle 8. They use native Oracle
APIs: OCI7 and OCI8. OTL ODBC was designed with Oracle OTL in mind, to
keep OTL applications portable across databases.
</p>
<h2><a name="sec11">1.1. SQL stream classes</a></h2>
<p>
<a name="sec11">OTL introduces the concept of SQL streams. The idea
here is to combine
streams and SQL. Any SQL statement or stored procedure call can be
treated as a functional element with input/output parameters. There
are functions to put objects into a stream, that is, to assign values
to input variables of the SQL statement. Also, there are functions to
get objects from the stream, that is, to get values from output
variables of the SQL statement.
</a></p>
<center>
<a name="sec11"><img src="otlodbc.gif"></a></center>
<p>
<a name="sec11">When values of all input variables of the functional
element
are filled out then the element is executed. Resulting
values are assigned to the output variables right after the
execution. Sets of input and output variables are allowed to
overlap.
</a></p>
<p>
<a name="sec11">Logically, a SQL stream is a structured stream with
input
and output rows. The format of the input row is defined by a
set of output variables of the stream. Similarly, the output
row is defined by input variables of the stream. When
objects are written into the stream, values are actually
assigned to the input variables. Likewise, when objects are
read from the stream, values are read from the output
variables of the stream.
</a></p>
<p>
<a name="sec11">SQL streams are similar to buffered files. A SQL
statement or stored
procedure call is opened as an ordinary buffered file. The logic of
he SQL stream operations remains the same as the file operations with
the only exception -- the SQL stream has separate input and output
buffers which may overlap.
</a></p>
<p>
<a name="sec11">The SQL stream has a flush function for flushing its
input buffer when
the buffer gets full and a collection of &gt;&gt; and &lt;&lt;
operators for
reading and writing object of different data types. The most important
advantage of the SQL streams is their unified interface to SQL
statements and stored procedure call of any kind. This means that the
application developer needs to remember just a few syntactical
constructs and function names which he already got familiar with when
he started working with C++ streams.
</a></p>
<p>
<a name="sec11">Inside the SQL stream there is a small parser for
parsing </a><a href="#sec221">declarations of bind variables</a> and
their data
types. There is no need to declare C/C++ host variables and bind them
with placeholders by special bind function calls. All necessary
buffers are created dynamically inside the stream. The stream just
needs to be opened for reading input values and writing output values.
</p>
<p>
The OTL stream interface requires use of the OTL exceptions. This
means that potentially any OTL stream operation can throw an exception
of the <a href="#sec23">otl_exception</a> type. In order to intercept
the exception and prevent the program from aborting, wrap up the OTL
stream code with the corresponding try &amp; catch block.
</p>
<h1><a name="sec2">2. <i>One-page</i> ODBC API</a></h1>
<h2><a name="sec21">2.1. Connect object</a></h2>
<p>
<a name="sec21">This class encapsulates the ODBC <i>connect</i>
functions: connect, commit, roll back, etc. In other words,
otl_connect is the class for creating "connect" objects.
</a></p>
<a name="ref002"></a><xmp>
class otl_connect{
public:
</xmp>
<ul>
  <li><a name="ref006"></a>Initialize ODBC program. This function needs
to be called only once
before connecting to the database for the first time. The function is
static in class.
    <xmp>static void otl_initialize(void);
    </xmp></li>
  <li>Set timeout (in seconds) for the connect object. If timeout is
set then any SQL
statement may time out.
    <xmp>void set_timeout(const int atimeout=0);
    </xmp></li>
  <li>Set cursor type for all subsequent SELECT statements open under
the connect object
    <xmp>void set_cursor_type(const int acursor_type=0);
    </xmp>
    <p>The following cursor types are available:
    </p>
    <ul>
      <li>SQL_CURSOR_FORWARD_ONLY
      </li>
      <li>SQL_CURSOR_STATIC
      </li>
      <li>SQL_CURSOR_KEYSET_DRIVEN
      </li>
      <li>SQL_CURSOR_DYNAMIC
      </li>
    </ul>
    <br>
    <br>
  </li>
  <li><a name="set_max"></a>Set Max Size for operations with
LONGVARCHAR and LONGVARBINARY datatypes
    <xmp>void set_max_long_size(const int amax_size);
    </xmp></li>
  <li>Get Max Size for LONGVARCHAR and LONGVARBINARY datatypes
    <xmp>int get_max_long_size(void);
    </xmp></li>
  <li>Create "connect" object.
    <xmp>otl_connect();
    </xmp></li>
  <li>Create "connect" object and connect to data source using the
"connect_str" connect string. Both Oracle and MFC styles of connect
strings are supported:<br>
    <br>
    <ul>
      <li> Oracle: "USERNAME/PASSWORD@DSN"
      </li>
      <li> MFC: "DSN=value;UID=value;PWD=value"
      </li>
    </ul>
    <p>
Both styles are case insensitive
    </p>
    <xmp> otl_connect(const char* connect_str);
    </xmp></li>
  <li>Destructor
    <xmp>~otl_connect();
    </xmp></li>
  <li><a name="ref007"></a>Concurrent logon; ODBC application is
allowed to have more than one
concurrent logon. Returns 1 on success, 0 on failure. The format of
connect string is the same as connect(const char* connect_str).
    <xmp>int rlogon(const char* connect_str);
    </xmp></li>
  <li>Set connect option: "option" is the same as 2nd parameter in
SQLSetConnectOption, "param" is the same as 3rd parameter in
SQLSetConnectOption. For more detail, see the ODBC programmer's
Guide.
    <xmp> void set_option(UWORD option, UDWORD param);
    </xmp></li>
  <li><a name="ref009"></a>Disconnect from / log off data source.
Returns 1 on success, 0 on
failure.
    <xmp>int logoff(void);
    </xmp></li>
  <li>Commit current transaction. Returns 1 on success, 0 on failure.
    <xmp>int commit(void);
    </xmp></li>
  <li>Roll back current transaction. Returns 1 on success, 0 on
failure.
    <xmp>int rollback(void);
    </xmp></li>
</ul>
<xmp>
};
</xmp>
<h2><a name="sec22">2.2. otl_stream class</a></h2>
<p>
<a name="sec22">OTL introduces the otl_stream class which is the actual
implementation
of the </a><a href="#sec11">SQL Stream</a> concept. It is unified for
any
SQL statement or stored procedure call which potentially may have
input/output bind variables (placeholders).
</p>
<p>
An OTL stream needs to have at least one <a href="#sec221">bind
variable</a>. See <a href="#sec24">2.4.</a> for more information on
how to execute a constant SQL statement or stored procedure call.
</p>
<xmp>
class otl_stream{
public:
</xmp>
<ul>
  <li><a name="ref001"></a>General conctructor. SQL statement is
parsed, all host input and
output host variables are automatically allocated and bound. This
constructor allows the user to use <a href="#sec221">extended
placeholder declarations</a>.
    <xmp>otl_stream( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db, // connect object const
int implicit_select=otl_explicit_select // "implicit" SELECT indicator.
It defaults to "explicit" // SELECT meaning that the SQL statement
statement in the stream // is "SELECT ...". "Implicit" SELECT means
that a result set // is returned by a stored procedure implicitly. );
    </xmp></li>
  <li>Default constructor
    <xmp>otl_stream();
    </xmp></li>
  <li>Destructor
    <xmp>~otl_stream();
    </xmp></li>
  <li><a name="ref005"></a>Test if all data has been already read from
the stream
    <xmp>int eof(void);
    </xmp></li>
  <li><a name="ref010"></a>Flush stream's output buffer. It actually
means to execute the SQL
statement as many times as rows entered to the output buffer. The
stream is automatically flushed when the buffer gets full.
    <xmp>void flush(void); </xmp>
  </li>
  <li>Clean up buffer without flushing it.
    <xmp>void clean(void);
    </xmp></li>
  <li>Rewind stream
    <xmp>void rewind(void);
    </xmp></li>
  <li>Test if NULL was fetched from the stream
    <xmp>int is_null(void);
    </xmp></li>
  <li>Set "auto-commit" flag. When the buffer is flushed, current
transaction is automatically commited, if the flag is set. By default,
the flag is set. In order to prevent current transaction from
"auto-committing", unset the flag using this function.<br>
This auto-commit flag has nothing to do with the database auto-commit
mode. This auto-commit is otl_stream specific. If it is more
convenient to have "auto-commit off" by default then it makes sense to
derive another stream class from otl_stream and unset the flag in
constructors of the derived class.
    <xmp>void set_commit(int auto_commit=0);
    </xmp></li>
  <li>Open stream
    <xmp>void open( short arr_size, // host array size const char*
sqlstm, // SQL statement otl_connect&amp; db, // connect object const
int implicit_select=otl_explicit_select // "implicit" SELECT indicator.
It defaults to "explicit" // SELECT meaning that the SQL statement
statement in the stream // is "SELECT ...". "Implicit" SELECT means
that a result set // is returned by a stored procedure implicitly. );
    </xmp></li>
  <li>Close stream
    <xmp>void close(void);
    </xmp></li>
  <li>Test if the stream was opened okay
    <xmp>int good(void);
    </xmp></li>
  <li><a name="ref004"></a>Read objects from stream
    <xmp>otl_stream&amp; operator&gt;&gt;(char&amp; c);
otl_stream&amp; operator&gt;&gt;(unsigned char&amp; c);
otl_stream&amp; operator&gt;&gt;(char* s);
otl_stream&amp; operator&gt;&gt;(unsigned char* s);
otl_stream&amp; operator&gt;&gt;(int&amp; n);
otl_stream&amp; operator&gt;&gt;(unsigned&amp; u);
otl_stream&amp; operator&gt;&gt;(short&amp; sh);
otl_stream&amp; operator&gt;&gt;(long int&amp; l);
otl_stream&amp; operator&gt;&gt;(float&amp; f);
otl_stream&amp; operator&gt;&gt;(double&amp; d);
otl_stream&amp; operator&gt;&gt;(otl_long_string&amp; s);
otl_stream&amp; operator&gt;&gt;(TIMESTAMP_STRUCT&amp; t);
otl_stream&amp; operator&gt;&gt;(CTime&amp; t);
    </xmp></li>
  <li><a name="ref003"></a>Write objects into stream
    <xmp>otl_stream&amp; operator&lt;&lt;(const char c);
otl_stream&amp; operator&lt;&lt;(const unsigned char c);
otl_stream&amp; operator&lt;&lt;(const char* s);
otl_stream&amp; operator&lt;&lt;(const unsigned char* s);
otl_stream&amp; operator&lt;&lt;(const int n);
otl_stream&amp; operator&lt;&lt;(const unsigned u);
otl_stream&amp; operator&lt;&lt;(const short sh);
otl_stream&amp; operator&lt;&lt;(const long int l);
otl_stream&amp; operator&lt;&lt;(const float f);
otl_stream&amp; operator&lt;&lt;(const double d);
otl_stream&amp; operator&lt;&lt;(const TIMESTAMP_STRUCT&amp; t);
otl_stream&amp; operator&lt;&lt;(const CTime&amp; t);
otl_stream&amp; operator&lt;&lt;(const otl_long_string&amp; s);
otl_stream&amp; operator&lt;&lt;(const otl_null n); // write NULL into
stream. otl_null is a dummy class // which has only a empty default
constructor. The only purpose // of creating this class was providing a
function to write // NULL into the database
    </xmp></li>
  <li><a name="ref011"></a>C-style printf/scanf functions
    <xmp>void printf(const char* fmt,...);
void scanf(const char* fmt,...);
    </xmp>
    <p>The following format specifiers are supported:
    </p>
    <ul>
      <li><b>%d</b> -- int
      </li>
      <li><b>%u</b> -- unsigned </li>
      <li><b>%ld</b> -- long int
      </li>
      <li><b>%f</b> -- float
      </li>
      <li><b>%lf</b> -- double
      </li>
      <li><b>%c</b> -- char
      </li>
      <li><b>%t</b> -- ODBC timestamp, requires TIMESTAMP_STRUCT or
CTime class
      </li>
      <li><b>%s</b> -- string
      </li>
      <li><b>%N</b> -- specifier for writing NULL into streams
      </li>
    </ul>
  </li>
</ul>
<xmp>
};
</xmp>
<h2><a name="sec221">2.2.1. Stream bind variables declaration</a></h2>
<p>
<a name="sec221">This section explains in detail how to declare bind
variables (or
extended placeholders) in the SQL streams.
</a></p>
<p>
<a name="sec221">A SQL statement or stored procedure call may have
placeholders which
are usually connected with the corresponding bind variables in the
program. OTL has a small parser which parses a SQL statament or stored
procedure call and allocates corresponding bind variables dynamically
inside the stream.
</a></p>
<p>
<a name="sec221">In OTL, placeholder names represent positions starting
with <b>:1</b>,
<b>:2</b>, etc.
</a></p>
<p>
<a name="sec221">The following data types for extneded placeholder
declarations are
available:
</a></p>
<ul>
  <li><a name="sec221">int
    </a></li>
  <li><a name="sec221">unsigned
    </a></li>
  <li><a name="sec221">short
    </a></li>
  <li><a name="sec221">long -- (long integer)
    </a></li>
  <li><a name="sec221">float
    </a></li>
  <li><a name="sec221">double
    </a></li>
  <li><a name="sec221">timestamp -- ODBC timestamp, requires
TIMESTAMP_STRUCT or CTime class
    </a></li>
  <li><a name="sec221">char[length] (length &gt;= 3 and length &lt;=
datasource specific value)
    </a></li>
  <li><a name="sec221">varchar_long -- corresponds to SQL_LONGVARCHAR
(see </a><a href="#sec222">2.2.2.</a>)
  </li>
  <li>raw_long -- corresponds to SQL_LONGVARBINARY (see <a
 href="#sec222">2.2.2.</a>)
  </li>
</ul>
<p>
For stored procedure calls, special qualifiers are introduced to
distinguish
between input and output variables:
</p>
<ul>
  <li>in -- input variable
  </li>
  <li>out -- output variable
  </li>
  <li>inout -- input/output variable
  </li>
</ul>
<h4>Examples</h4>
<p>
Here is some examples:
</p>
<pre>   {<br>    call :1&lt;int,out&gt; := my_func(:2&lt;float,in&gt;,  <br>                                :3&lt;int,inout&gt;, <br>                                :4&lt;char[32],out&gt;<br>                               )<br>   }<br></pre>
<p>
Invoke the my_func function; return the function result into
the :1 variable; the function has three parameters: <b>:1</b>
(input), <b>:2</b> (iput/output), <b>:3</b> (output)
</p>
<pre>
   select * from tab1 where f1 &gt; :1&lt;double&gt;

</pre>
<p>
Select all columns from the tab1 table where f1 is greater
than <b>:1</b>
</p>
<pre>
   insert into tab1 values( :1&lt;double&gt;, :2&lt;char[32]&gt;, :3&lt;int&gt; )

</pre>
<p>
Insert row { <b>:1</b>(double), <b>:2</b>(string), <b>:3</b>(integer)
} into the tab1
table.
</p>
<p>
In the extended placeholder declaration, spaces in the data type
section and in the access qualifier section ARE NOT allowed. The
following code is invalid:
</p>
<xmp> insert into tab1 values(:1&lt; double &gt;, :2&lt; char [ 32 ]
&gt; , :3&lt; int&gt;); :1&lt; int, out &gt; := ...;
</xmp>
<h2><a name="sec222">2.2.2. otl_long_string class</a></h2>
<p>
<a name="sec222">This class represents a data container for
SQL_LONGVARCHAR and
SQL_LONGVARBINARY datatypes. These two datatypes are defined in ODBC
to map them to the TEXT/IMAGE datatypes in MS SQL Server 6.5/7.0,
LONG/LONG RAW and CLOB/LOB in Oracle 8.x. Respectively, OTL has
varchar_long and raw_long datatypes for defining </a><a href="#sec221">extended
placeholders</a> which get bound to the
SQL_LONGVARCHAR/SQL_LONGVARBINARY table columns.
</p>
<pre>class otl_long_string{<br></pre>
<ul>
  <li>Class constructor. It allocates a block of memory according to
the
specified size <i>str_size</i>.
    <xmp> otl_long_string(const int str_size=32760)
    </xmp></li>
  <li>Class destructor
    <xmp> ~otl_long_string()
    </xmp></li>
  <li> <a name="set_len"></a>Set string's dynamic length
    <xmp>void set_len(const int len=0)
    </xmp></li>
  <li> Get string's dynamic length
    <xmp> int len()
    </xmp></li>
  <li>[] operator for accessing individual elements of the long string.
    <xmp> unsigned char&amp; operator[](int ndx)
    </xmp></li>
</ul>
<pre> <br>};<br></pre>
<p>
Before writing the string to a stream, a dynamic length of the string
needs to be set by calling set_len() function. When reading the
string from a stream, the dynamic length field is updated with an
actual string length. It is not guaranteed that for "varchar_long" on
the output otl_long_string is null terminated: always check the length
of the string. Besides, before opening a stream with such columns the
<a href="#set_max">otl_connect::set_max_long_size()</a> function needs
to be called in order to set the maximum size of <i>long</i> columns
for the connect object. See example <a href="#sec257a">7a</a> for more
detail.
</p>
<h2><a name="sec23">2.3. Exception handling</a></h2>
<p>
<a name="sec23">In case of database failure or inconsistent use of SQL
streams,
exceptions of the otl_exception type are raised by the library
functions. The main advantage of using this exception handling
mechanism is that exceptions can be processed in one catch block,
instead of checking return codes from every library function call.
</a></p>
<xmp><a name="sec23">
class otl_exception{
public:
</a></xmp>
<ul>
  <li><a name="ref008"></a>This <i>enum</i> defines two constants
which may be used in the
    <a href="#sec24">direct_exec</a> function
    <pre>enum{ disabled, enabled };<br></pre>
  </li>
  <li>Create exception out of either environment or database or
statement handle
    <xmp>otl_exception(HENV henv,HDBC hdbc,HSTMT hstmt,const char*
sqlstm=0);
    </xmp></li>
  <li>Create exception from amsg, acode and sqlstm
    <xmp>otl_exception(const char* amsg,const int acode,const char*
sqlstm=0);
    </xmp></li>
  <li>Copy constructor
    <xmp>otl_exception(const otl_exception&amp; p);
    </xmp></li>
  <li>Default constructor
    <xmp> otl_exception();
    </xmp><br>
    <hr size="3">
    <br>
  </li>
  <li>native error message buffer
    <xmp>unsigned char msg[1000]; </xmp>
  </li>
  <li>native error code
    <xmp>int code;
    </xmp></li>
  <li>SQL statement or stored procedure call that caused the error
    <xmp> unsigned char* stm_text;
    </xmp></li>
  <li>SQLSTATE message buffer
    <xmp>unsigned char sqlstate[1000]; </xmp>
  </li>
</ul>
<xmp>
};
</xmp>
<h3>Example</h3>
<xmp> try{ otl_stream s(50, // fetch 50 rows per one fetch operation
"select state_name, state_code " "from state " "where state_name like
:1&lt;char[33]&gt;", db // connect object ); char name[33]; int code;
s&lt;&lt;"M%"; while(!s.eof)){ s&gt;&gt;name&gt;&gt;code;
cout&lt;&lt;"State="&lt;&lt;name&lt;&lt;",
Code="&lt;&lt;code&lt;&lt;endl; } }catch(otl_exception&amp; p){ //
intercept exception cerr&lt;&lt;p.code&lt;&lt;endl; // print out error
code cerr&lt;&lt;p.msg&lt;&lt;endl; // print out error message
cerr&lt;&lt;p.sqlstate&lt;&lt;endl; // print out SQLSTATE
if(p.stm_text) cerr&lt;&lt;p.stm_text&lt;&lt;endl; // print out SQL
that caused the error }
</xmp>
<h2><a name="sec24">2.4. Constant SQL statement or stored procedure call</a></h2>
<p>
<a name="sec24">SQL statement or stored procedure call is considered to
be constant if it does
not have any bind variables. OTL has a static (in class) function to
execute constant statements or blocks, e.g.
</a></p>
<xmp><a name="sec24"> otl_cursor::direct_exec (db, // connect object
"create table test_tab(f1 numeric, f2 varchar(30))" ); // create table
</a></xmp>
<p><a name="sec24">otl_cursor is one of OTL internal classes. There is
another format of
the direct_exec function call:
</a></p>
<xmp><a name="sec24"> otl_cursor::direct_exec (db, // connect object
"drop table test_tab", // SQL statement or stored procedure call
otl_exception::disabled // disable OTL exceptions, // in other words,
ignore any // database error ); // drop table
</a></xmp>
<h2><a name="sec25">2.5. Examples</a></h2>
<p>
<a name="sec25">All examples below assume Oracle 8.x or SQL Server
6.5/7.0 ODBC
drivers as their data sources.
</a></p>
<a name="sec251"></a>
<h3><a name="sec251">Example 1 (with otl_stream class)</a></h3>
<p>
<a name="sec251">This example works with both Oracle 8.x and SQL Server
6.5/7.0 without
any modifications to the table structure or datatypes.
</a></p>
<h4><a name="sec251">Source code</a></h4>
<pre>
<a name="sec251"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref101"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;float&gt;,:2&lt;char[31]&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );
 <font
 color="#0000a0">char</font> tmp[32];<br><br> <font color="#0000a0">for</font>(<font
 color="#0000a0">int</font> i=1;i&lt;=100;++i){<br>  sprintf(tmp,<font
 color="#008080">"Name%d"</font>,i);<br>  o<a href="#ref003">&lt;&lt;</a>(<font
 color="#0000a0">float</font>)i<a href="#ref003">&lt;&lt;</a>tmp;<br> }<br>}<br><br><a
 name="ref102"></a><h4><font color="#0000a0">void</font> select()</h4>
{ 
 <a
 href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> <font color="#0000a0">char</font> f2[31];<br><br> i<a
 href="#ref003">&lt;&lt;</a>8<a href="#ref003">&lt;&lt;</a>8; <i><font
 color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 varchar(30))"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref101">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref102">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</pre>
<a name="sec252a"></a>
<h3><a name="sec252a">Example 2a (with an Oracle stored procedure call)</a></h3>
<p>
<a name="sec252a">This example works with Oracle 8.x ODBC drivers only.
Check out </a><a href="#sec252b">example 2b</a> to see how to call a
stored procedure
in an MS SQL Server 6.5/7.0.
</p>
<h4>Source code</h4>
<pre>
<font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref201"></a><h4><font color="#0000a0">void</font> stored_proc()</h4>
<i><font color="#804000">// invoking stored procedure</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size should be equal to 1 in case of stored procedure call</font></i>
	      <font
 color="#008080">"{call my_proc("</font>
	      <font color="#008080">" :1&lt;int,inout&gt;, "</font>
	      <font
 color="#008080">" :2&lt;char[31],out&gt;, "</font>
	      <font
 color="#008080">" :3&lt;char[31],in&gt; "</font>
	      <font
 color="#008080">")}"</font>,<br>	         <i><font color="#804000">// stored procedure call</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );
 o<a
 href="#ref003">&lt;&lt;</a>1<a href="#ref003">&lt;&lt;</a><font
 color="#008080">"Test String1"</font>; <i><font color="#804000">// assigning :1 = 1, :3 = "Test String1"</font></i>

 <font
 color="#0000a0">int</font> a;<br> <font color="#0000a0">char</font> b[31];<br><br> o<a
 href="#ref004">&gt;&gt;</a>a<a href="#ref004">&gt;&gt;</a>b;<br> cout&lt;&lt;<font
 color="#008080">"A="</font>&lt;&lt;a&lt;&lt;<font color="#008080">", B="</font>&lt;&lt;b&lt;&lt;endl;<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"uid=scott;pwd=tiger;dsn=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>
  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"CREATE OR REPLACE PROCEDURE my_proc "</font>
    <font
 color="#008080">"  (A IN OUT NUMBER, "</font>
    <font
 color="#008080">"   B OUT VARCHAR2, "</font>
    <font color="#008080">"   C IN VARCHAR2) "</font>
    <font
 color="#008080">"IS "</font>
    <font color="#008080">"BEGIN "</font>
    <font
 color="#008080">"   A := A+1; "</font>
    <font color="#008080">"   B := C; "</font>
    <font
 color="#008080">"END;"</font>
    );  <i><font color="#804000">// create stored procedure</font></i>

  <a
 href="#ref201">stored_proc()</a>; <i><font color="#804000">// invoking stored procedure</font></i>
 }
 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }
 db.<a
 href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>
 <font
 color="#0000a0">return</font> 0;<br>} <br><br></pre>
<h4>Output</h4>
<pre>
A=2, B=Test String1

</pre>
<a name="sec252b"></a>
<h3><a name="sec252b">Example 2b (with an MS SQL Server stored
procedure call)</a></h3>
<p>
<a name="sec252b">This example works with Oracle 8.x ODBC drivers only.
Check out </a><a href="#sec252a">example 2a</a> to see how to call a
stored procedure
in Oracle 8.x
</p>
<h4>Source code</h4>
<pre>
<font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref201b"></a><h4><font color="#0000a0">void</font> stored_proc()</h4>
<i><font color="#804000">// invoking stored procedure</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size should be equal to 1 in case of stored procedure call</font></i>
	      <font
 color="#008080">"{call my_proc("</font>
	      <font color="#008080">" :1&lt;int,inout&gt;, "</font>
	      <font
 color="#008080">" :2&lt;char[31],out&gt;, "</font>
	      <font
 color="#008080">" :3&lt;char[31],in&gt; "</font>
	      <font
 color="#008080">")}"</font>,<br>	         <i><font color="#804000">// stored procedure call</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );
 o<a
 href="#ref003">&lt;&lt;</a>1<a href="#ref003">&lt;&lt;</a><font
 color="#008080">"Test String1"</font>; <i><font color="#804000">// assigning :1 = 1, :3 = "Test String1"</font></i>

 <font
 color="#0000a0">int</font> a;<br> <font color="#0000a0">char</font> b[31];<br><br> o<a
 href="#ref004">&gt;&gt;</a>a<a href="#ref004">&gt;&gt;</a>b;<br> cout&lt;&lt;<font
 color="#008080">"A="</font>&lt;&lt;a&lt;&lt;<font color="#008080">", B="</font>&lt;&lt;b&lt;&lt;endl;<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"uid=sa;pwd=;dsn=mssql"</font>); <i><font
 color="#804000">// connect to data source MSSQL</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"DROP PROCEDURE my_proc"</font>,<br>    0 <i><font
 color="#804000">// ignore any errors</font></i>
    );  <i><font
 color="#804000">// drop stored procedure</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"CREATE PROCEDURE my_proc "</font>
    <font
 color="#008080">"  @A int out, "</font>
    <font color="#008080">"  @B varchar(60) out, "</font>
    <font
 color="#008080">"  @C varchar(60) "</font>
    <font color="#008080">"AS "</font>
    <font
 color="#008080">"BEGIN "</font>
    <font color="#008080">"  SELECT @A=@A+1"</font>
    <font
 color="#008080">"  SELECT @B=@C "</font>
    <font color="#008080">"END"</font>
    );  <i><font
 color="#804000">// create stored procedure</font></i>

  <a
 href="#ref201b">stored_proc()</a>; <i><font color="#804000">// invoking stored procedure</font></i>
 }
 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }
 db.<a
 href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>
 <font
 color="#0000a0">return</font> 0;<br>} <br><br></pre>
<h4>Output</h4>
<pre>
A=2, B=Test String1

</pre>
<a name="sec253"></a>
<h3><a name="sec253">Example 3 (with printf/scanf functions)</a></h3>
<p>
<a name="sec253">This example works with Oracle 8.x and SQL Server
6.5/7.0 without any
modifications to the table structure or datatypes.
</a></p>
<h4><a name="sec253">Source code</a></h4>
<pre>
<a name="sec253"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref301"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;char[31]&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );
 <font
 color="#0000a0">char</font> tmp[32];<br><br> <font color="#0000a0">for</font>(<font
 color="#0000a0">int</font> i=1;i&lt;=100;++i){<br>  sprintf(tmp,<font
 color="#008080">"Name%d"</font>,i);<br>  o.<a href="#ref011">printf</a>(<font
 color="#008080">"%d %s"</font>,i,tmp); <i><font color="#804000">// write one row into stream</font></i>
 }
}

<a name="ref302"></a><h4><font color="#0000a0">void</font> select()</h4>
{ 
 <a
 href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> <font color="#0000a0">char</font> f2[31];<br><br> i<a
 href="#ref003">&lt;&lt;</a>8<a href="#ref003">&lt;&lt;</a>8; <i><font
 color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i.<a
 href="#ref011">scanf</a>(<font color="#008080">"%d %s"</font>,&amp;f1,f2); <i><font
 color="#804000">// read one row from stream</font></i>
  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i.<a
 href="#ref011">scanf</a>(<font color="#008080">"%d %s"</font>,&amp;f1,f2); <i><font
 color="#804000">// read one row from stream</font></i>
  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>

 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=SCOTT;PWD=TIGER;DSN=MY_DB"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 varchar(30))"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref301">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref302">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 db.<a
 href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</pre>
<a name="sec254a"></a>
<h3><a name="sec254a">Example 4a (with otl_stream class,
TIMESTAMP_STRUCT and Oracle)</a></h3>
<p>
<a name="sec254a">This example works with Oracle 8.x ODBC drivers only.
</a></p>
<h4><a name="sec254a">Source code</a></h4>
<pre>
<a name="sec254a"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref101a"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(3, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab2 values(:1&lt;float&gt;,:2&lt;timestamp&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );

 TIMESTAMP_STRUCT tm;

 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=10;++i){<br>  tm.year=1998;<br>  tm.month=10;<br>  tm.day=19;<br>  tm.hour=23;<br>  tm.minute=12;<br>  tm.second=12;<br>  tm.fraction=0;<br>  o<a
 href="#ref003">&lt;&lt;</a>(<font color="#0000a0">float</font>)i<a
 href="#ref003">&lt;&lt;</a>tm;<br> }<br>}<br><br><a name="ref102a"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(3, <i><font
 color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab2 where f2=:1&lt;timestamp&gt;"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> TIMESTAMP_STRUCT tm,f2;<br><br> tm.year=1998;<br> tm.month=10;<br> tm.day=19;<br> tm.hour=23;<br> tm.minute=12;<br> tm.second=12;<br> tm.fraction=0;<br><br> i<a
 href="#ref003">&lt;&lt;</a>tm; <i><font color="#804000">// assigning :1 = tm</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2.month&lt;&lt;<font
 color="#008080">"/"</font>&lt;&lt;f2.day&lt;&lt;<font color="#008080">"/"</font>
      &lt;&lt;f2.year&lt;&lt;<font
 color="#008080">" "</font>&lt;&lt;f2.hour&lt;&lt;<font color="#008080">":"</font>&lt;&lt;f2.minute&lt;&lt;<font
 color="#008080">":"</font>
      &lt;&lt;f2.second&lt;&lt;<font
 color="#008080">"."</font>&lt;&lt;f2.fraction<br>      &lt;&lt;endl;<br> }<br> <br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab2"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab2(f1 int, f2 date)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref101a">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref102a">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=1, f2=10/19/1998 23:12:12.0
f1=2, f2=10/19/1998 23:12:12.0
f1=3, f2=10/19/1998 23:12:12.0
f1=4, f2=10/19/1998 23:12:12.0
f1=5, f2=10/19/1998 23:12:12.0
f1=6, f2=10/19/1998 23:12:12.0
f1=7, f2=10/19/1998 23:12:12.0
f1=8, f2=10/19/1998 23:12:12.0
f1=9, f2=10/19/1998 23:12:12.0
f1=10, f2=10/19/1998 23:12:12.0

</pre>
<a name="sec254b"></a>
<h3><a name="sec254b">Example 4b (with otl_stream class,
TIMESTAMP_STRUCT and MS SQL Server)</a></h3>
<p>
<a name="sec254b">This example works with MS SQL Server 6.5/7.0 only.
</a></p>
<h4><a name="sec254b">Source code</a></h4>
<pre>
<a name="sec254b"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref101b"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(3, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab2 values(:1&lt;float&gt;,:2&lt;timestamp&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );

 TIMESTAMP_STRUCT tm;

 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=10;++i){<br>  tm.year=1998;<br>  tm.month=10;<br>  tm.day=19;<br>  tm.hour=23;<br>  tm.minute=12;<br>  tm.second=12;<br>  tm.fraction=0;<br>  o<a
 href="#ref003">&lt;&lt;</a>(<font color="#0000a0">float</font>)i<a
 href="#ref003">&lt;&lt;</a>tm;<br> }<br>}<br><br><a name="ref102b"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(3, <i><font
 color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab2 where f2=:1&lt;timestamp&gt;"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> TIMESTAMP_STRUCT tm,f2;<br><br> tm.year=1998;<br> tm.month=10;<br> tm.day=19;<br> tm.hour=23;<br> tm.minute=12;<br> tm.second=12;<br> tm.fraction=0;<br><br> i<a
 href="#ref003">&lt;&lt;</a>tm; <i><font color="#804000">// assigning :1 = tm</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2.month&lt;&lt;<font
 color="#008080">"/"</font>&lt;&lt;f2.day&lt;&lt;<font color="#008080">"/"</font>
      &lt;&lt;f2.year&lt;&lt;<font
 color="#008080">" "</font>&lt;&lt;f2.hour&lt;&lt;<font color="#008080">":"</font>&lt;&lt;f2.minute&lt;&lt;<font
 color="#008080">":"</font>
      &lt;&lt;f2.second&lt;&lt;<font
 color="#008080">"."</font>&lt;&lt;f2.fraction<br>      &lt;&lt;endl;<br> }<br> <br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=sa;PWD=;DSN=mssql"</font>); <i><font
 color="#804000">// connect to data source MSSQL</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab2"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab2(f1 int, f2 datetime)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref101b">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref102b">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=1, f2=10/19/1998 23:12:12.0
f1=2, f2=10/19/1998 23:12:12.0
f1=3, f2=10/19/1998 23:12:12.0
f1=4, f2=10/19/1998 23:12:12.0
f1=5, f2=10/19/1998 23:12:12.0
f1=6, f2=10/19/1998 23:12:12.0
f1=7, f2=10/19/1998 23:12:12.0
f1=8, f2=10/19/1998 23:12:12.0
f1=9, f2=10/19/1998 23:12:12.0
f1=10, f2=10/19/1998 23:12:12.0

</pre>
<a name="sec255a"></a>
<h3><a name="sec255a">Example 5a (with otl_stream class, CTime class
and Oracle)</a></h3>
<p>
</p>
<h4><a name="sec255a">Source code</a></h4>
<pre>
<a name="sec255a"><font color="#ff0000">#define USE_MFC</font> <i><font
 color="#804000">// needs to be defined if CTime and MFC are used </font></i>
<font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref105a"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(3, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab2 values(:1&lt;float&gt;,:2&lt;timestamp&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );

 CTime tm=CTime(1998,10,19,23,12,12);

 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=10;++i){<br>  o<a
 href="#ref003">&lt;&lt;</a>(<font color="#0000a0">float</font>)i<a
 href="#ref003">&lt;&lt;</a>tm;<br> }<br>}<br><br><a name="ref102"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(3, <i><font
 color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab2 where f2=:1&lt;timestamp&gt;"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> CTime tm=CTime(1998,10,19,23,12,12);<br> CTime f2;<br><br> i<a
 href="#ref003">&lt;&lt;</a>tm; <i><font color="#804000">// assigning :1 = tm</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2.GetMonth()&lt;&lt;<font
 color="#008080">"/"</font>&lt;&lt;f2.GetDay()&lt;&lt;<font
 color="#008080">"/"</font>
      &lt;&lt;f2.GetYear()&lt;&lt;<font
 color="#008080">" "</font>&lt;&lt;f2.GetHour()&lt;&lt;<font
 color="#008080">":"</font>&lt;&lt;f2.GetMinute()&lt;&lt;<font
 color="#008080">":"</font>
      &lt;&lt;f2.GetSecond()
      &lt;&lt;endl;
 }
 

}

<h4><font color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab2"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab2(f1 int, f2 date)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref101">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref102">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=1, f2=10/19/1998 23:12:12
f1=2, f2=10/19/1998 23:12:12
f1=3, f2=10/19/1998 23:12:12
f1=4, f2=10/19/1998 23:12:12
f1=5, f2=10/19/1998 23:12:12
f1=6, f2=10/19/1998 23:12:12
f1=7, f2=10/19/1998 23:12:12
f1=8, f2=10/19/1998 23:12:12
f1=9, f2=10/19/1998 23:12:12
f1=10, f2=10/19/1998 23:12:12

</pre>
<a name="sec255b"></a>
<h3><a name="sec255b">Example 5b (with otl_stream class, CTime class
and MS SQL Server)</a></h3>
<p>
<a name="sec255b">This example works with MS SQL Server only.
</a></p>
<h4><a name="sec255b">Source code</a></h4>
<pre>
<a name="sec255b"><font color="#ff0000">#define USE_MFC</font> <i><font
 color="#804000">// needs to be defined if CTime and MFC are used </font></i>
<font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref105b"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(3, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab2 values(:1&lt;float&gt;,:2&lt;timestamp&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );

 CTime tm=CTime(1998,10,19,23,12,12);

 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=10;++i){<br>  o<a
 href="#ref003">&lt;&lt;</a>(<font color="#0000a0">float</font>)i<a
 href="#ref003">&lt;&lt;</a>tm;<br> }<br>}<br><br><a name="ref106b"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(3, <i><font
 color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab2 where f2=:1&lt;timestamp&gt;"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> CTime tm=CTime(1998,10,19,23,12,12);<br> CTime f2;<br><br> i<a
 href="#ref003">&lt;&lt;</a>tm; <i><font color="#804000">// assigning :1 = tm</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2.GetMonth()&lt;&lt;<font
 color="#008080">"/"</font>&lt;&lt;f2.GetDay()&lt;&lt;<font
 color="#008080">"/"</font>
      &lt;&lt;f2.GetYear()&lt;&lt;<font
 color="#008080">" "</font>&lt;&lt;f2.GetHour()&lt;&lt;<font
 color="#008080">":"</font>&lt;&lt;f2.GetMinute()&lt;&lt;<font
 color="#008080">":"</font>
      &lt;&lt;f2.GetSecond()
      &lt;&lt;endl;
 }
 

}

<h4><font color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=sa;PWD=;DSN=mssql"</font>); <i><font
 color="#804000">// connect to data source MSSQL</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab2"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab2(f1 int, f2 datetime)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref105b">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref106b">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=1, f2=10/19/1998 23:12:12
f1=2, f2=10/19/1998 23:12:12
f1=3, f2=10/19/1998 23:12:12
f1=4, f2=10/19/1998 23:12:12
f1=5, f2=10/19/1998 23:12:12
f1=6, f2=10/19/1998 23:12:12
f1=7, f2=10/19/1998 23:12:12
f1=8, f2=10/19/1998 23:12:12
f1=9, f2=10/19/1998 23:12:12
f1=10, f2=10/19/1998 23:12:12

</pre>
<a name="sec256"></a>
<h3><a name="sec256">Example 6 (implicit SELECT/result set return by
a stored procedure)</a></h3>
<p>
<a name="sec256">This example works MS SQL Server 6.5/7.0 only. In
order to do the same
thing with Oracle via an Oracle ODBC driver, you need the Oracle ODBC
driver 8.0.5.x and the Oracle Client 8.0.5.x. In other words, it is
possible to return Oracle's normal referenced cursor in the format of
an
implicit result set. Oracle's stored procedure call would look like
this:
</a></p>
<xmp><a name="sec256"> {call my_proc(:1&lt;int,in&gt;,?)}
</a></xmp>
<p><a name="sec256">where <b>?</b> is used to tell the Oracle ODBC
driver 8.0.5.x that
the second parameter in the my_proc procedure is the referenced cursor
to be returned. The driver allocates the referenced cursor variable
inside and returns the fetch sequence in the format of the implicit
result set. For more info, refer to the Oracle ODBC driver 8.0.5.x's
manual. </a></p>
<h4><a name="sec256">Source code</a></h4>
<pre>
<a name="sec256"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref110"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;float&gt;,:2&lt;char[31]&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );
 <font
 color="#0000a0">char</font> tmp[32];<br><br> <font color="#0000a0">for</font>(<font
 color="#0000a0">int</font> i=1;i&lt;=100;++i){<br>  sprintf(tmp,<font
 color="#008080">"Name%d"</font>,i);<br>  o<a href="#ref003">&lt;&lt;</a>(<font
 color="#0000a0">float</font>)i<a href="#ref003">&lt;&lt;</a>tmp;<br> }<br>}<br><br><a
 name="ref111"></a><h4><font color="#0000a0">void</font> select()</h4>
{ 
 <a
 href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"{call my_proc(:1&lt;int,in&gt;)}"</font>,<br>	         <i><font
 color="#804000">// implicit SELECT statement</font></i>
	      db, <i><font
 color="#804000">// connect object</font></i>
              otl_implicit_select <i><font
 color="#804000">// implicit SELECT statement</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br> <font color="#0000a0">char</font> f2[31];<br><br> i<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :1 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=sa;PWD=;DSN=mssql"</font>); <i><font
 color="#804000">// connect to data source MSSQL</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 varchar(30))"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"DROP PROCEDURE my_proc"</font>,<br>    0 <i><font
 color="#804000">// ignore any errors</font></i>
    );  <i><font
 color="#804000">// drop stored procedure</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"CREATE PROCEDURE my_proc "</font>
    <font
 color="#008080">"  @F1 int "</font>
    <font color="#008080">"AS "</font>
    <font
 color="#008080">"SELECT * FROM test_tab "</font>
    <font
 color="#008080">"WHERE f1&gt;=@F1 AND f1&lt;=@F1*2 "</font>
    );  <i><font
 color="#804000">// create stored procedure</font></i>


  <a
 href="#ref110">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a
 href="#ref111">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</pre>
<a name="sec257a"></a>
<h3><a name="sec257a">Example 7a (with MS SQL Server's TEXT column)</a></h3>
<p>
<a name="sec257a">This example works with SQL Server 6.5/7.0 only.
</a></p>
<h4><a name="sec257a">Source code</a></h4>
<pre>
<a name="sec257a"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref121a"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 

 <a
 href="#sec222">otl_long_string</a> f2(70000); <i><font color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size needs to be set to 1 for long strings</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;varchar_long&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );


 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=20;++i){<br>  <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> j=0;j&lt;50000;++j)<br>   f2[j]='*';<br>  f2[50000]='?';<br>  f2.<a
 href="#set_len">set_len</a>(50001);<br>  o<a href="#ref003">&lt;&lt;</a>i<a
 href="#ref003">&lt;&lt;</a>f2;<br> }<br>}<br><br><a name="ref122a"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#sec222">otl_long_string</a> f2(70000); <i><font
 color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> i(1, <i><font color="#804000">// buffer size needs to be set to 1</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br><br> i<a href="#ref003">&lt;&lt;</a>8<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=sa;PWD=;DSN=mssql"</font>); <i><font
 color="#804000">// connect to data source MSSQL</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 text)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref121a">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref122a">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=*?, len=50001
f1=9, f2=*?, len=50001
f1=10, f2=*?, len=50001
f1=11, f2=*?, len=50001
f1=12, f2=*?, len=50001
f1=13, f2=*?, len=50001
f1=14, f2=*?, len=50001
f1=15, f2=*?, len=50001
f1=16, f2=*?, len=50001
f1=4, f2=*?, len=50001
f1=5, f2=*?, len=50001
f1=6, f2=*?, len=50001
f1=7, f2=*?, len=50001
f1=8, f2=*?, len=50001

</pre>
<a name="sec257b"></a>
<h3><a name="sec257b">Example 7b (with MS SQL Server's IMAGE column)</a></h3>
<p>
<a name="sec257b">This example works with SQL Server 6.5/7.0 only.
</a></p>
<h4><a name="sec257b">Source code</a></h4>
<pre>
<a name="sec257b"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref121b"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#sec222">otl_long_string</a> f2(70000); <i><font color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size needs to be set to 1 for long strings</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;raw_long&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );


 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=20;++i){<br>  <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> j=0;j&lt;50000;++j)<br>   f2[j]='*';<br>  f2[50000]='?';<br>  f2.<a
 href="#set_len">set_len</a>(50001);<br>  o<a href="#ref003">&lt;&lt;</a>i<a
 href="#ref003">&lt;&lt;</a>f2;<br> }<br>}<br><br><a name="ref122b"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#sec222">otl_long_string</a> f2(70000); <i><font
 color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> i(1, <i><font color="#804000">// buffer size needs to be set to 1</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br><br> i<a href="#ref003">&lt;&lt;</a>8<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=sa;PWD=;DSN=mssql"</font>); <i><font
 color="#804000">// connect to data source MSSQL</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 image)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref121b">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref122b">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=*?, len=50001
f1=9, f2=*?, len=50001
f1=10, f2=*?, len=50001
f1=11, f2=*?, len=50001
f1=12, f2=*?, len=50001
f1=13, f2=*?, len=50001
f1=14, f2=*?, len=50001
f1=15, f2=*?, len=50001
f1=16, f2=*?, len=50001
f1=4, f2=*?, len=50001
f1=5, f2=*?, len=50001
f1=6, f2=*?, len=50001
f1=7, f2=*?, len=50001
f1=8, f2=*?, len=50001

</pre>
<a name="sec257c"></a>
<h3><a name="sec257c">Example 7c (with Oracle's LONG column)</a></h3>
<p>
<a name="sec257c">This example works with Oracle 8.x ODBC drivers only.
</a></p>
<h4><a name="sec257c">Source code</a></h4>
<pre>
<a name="sec257c"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref121c"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#sec222">otl_long_string</a> f2(70000); <i><font color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size needs to be set to 1 for long strings</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;varchar_long&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );


 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=20;++i){<br>  <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> j=0;j&lt;50000;++j)<br>   f2[j]='*';<br>  f2[50000]='?';<br>  f2.<a
 href="#set_len">set_len</a>(50001);<br>  o<a href="#ref003">&lt;&lt;</a>i<a
 href="#ref003">&lt;&lt;</a>f2;<br> }<br>}<br><br><a name="ref122c"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#sec222">otl_long_string</a> f2(70000); <i><font
 color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>
 <a
 href="#ref001">otl_stream</a> i(1, <i><font color="#804000">// buffer size needs to be set to 1</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br><br> i<a href="#ref003">&lt;&lt;</a>8<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 long)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref121c">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref122c">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=*?, len=50001
f1=9, f2=*?, len=50001
f1=10, f2=*?, len=50001
f1=11, f2=*?, len=50001
f1=12, f2=*?, len=50001
f1=13, f2=*?, len=50001
f1=14, f2=*?, len=50001
f1=15, f2=*?, len=50001
f1=16, f2=*?, len=50001
f1=4, f2=*?, len=50001
f1=5, f2=*?, len=50001
f1=6, f2=*?, len=50001
f1=7, f2=*?, len=50001
f1=8, f2=*?, len=50001

</pre>
<a name="sec257d"></a>
<h3><a name="sec257d">Example 7d (with Oracle's LONG RAW column)</a></h3>
<p>
<a name="sec257d">This example works with Oracle 8.x ODBC drivers only.
</a></p>
<h4><a name="sec257d">Source code</a></h4>
<pre>
<a name="sec257d"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref121d"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#sec222">otl_long_string</a> f2(70000); <i><font color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size needs to be set to 1 for long strings</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;raw_long&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );


 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=20;++i){<br>  <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> j=0;j&lt;50000;++j)<br>   f2[j]='*';<br>  f2[50000]='?';<br>  f2.<a
 href="#set_len">set_len</a>(50001);<br>  o<a href="#ref003">&lt;&lt;</a>i<a
 href="#ref003">&lt;&lt;</a>f2;<br> }<br>}<br><br><a name="ref122d"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#sec222">otl_long_string</a> f2(70000); <i><font
 color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>
 <a
 href="#ref001">otl_stream</a> i(1, <i><font color="#804000">// buffer size needs to be set to 1</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br><br> i<a href="#ref003">&lt;&lt;</a>8<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 long raw)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref121d">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref122d">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=*?, len=50001
f1=9, f2=*?, len=50001
f1=10, f2=*?, len=50001
f1=11, f2=*?, len=50001
f1=12, f2=*?, len=50001
f1=13, f2=*?, len=50001
f1=14, f2=*?, len=50001
f1=15, f2=*?, len=50001
f1=16, f2=*?, len=50001
f1=4, f2=*?, len=50001
f1=5, f2=*?, len=50001
f1=6, f2=*?, len=50001
f1=7, f2=*?, len=50001
f1=8, f2=*?, len=50001

</pre>
<a name="sec257e"></a>
<h3><a name="sec257e">Example 7e (with Oracle's CLOB column)</a></h3>
<p>
<a name="sec257e">This example works with Oracle 8.0.5.x ODBC drivers
only and requires
the Oracle Client 8.0.5.x as well.
</a></p>
<h4><a name="sec257e">Source code</a></h4>
<pre>
<a name="sec257e"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref121e"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#sec222">otl_long_string</a> f2(70000); <i><font color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size needs to be set to 1 for long strings</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;varchar_long&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );


 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=20;++i){<br>  <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> j=0;j&lt;50000;++j)<br>   f2[j]='*';<br>  f2[50000]='?';<br>  f2.<a
 href="#set_len">set_len</a>(50001);<br>  o<a href="#ref003">&lt;&lt;</a>i<a
 href="#ref003">&lt;&lt;</a>f2;<br> }<br>}<br><br><a name="ref122e"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#sec222">otl_long_string</a> f2(70000); <i><font
 color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>
 <a
 href="#ref001">otl_stream</a> i(1, <i><font color="#804000">// buffer size needs to be set to 1</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br><br> i<a href="#ref003">&lt;&lt;</a>8<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 clob)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref121c">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref122c">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=*?, len=50001
f1=9, f2=*?, len=50001
f1=10, f2=*?, len=50001
f1=11, f2=*?, len=50001
f1=12, f2=*?, len=50001
f1=13, f2=*?, len=50001
f1=14, f2=*?, len=50001
f1=15, f2=*?, len=50001
f1=16, f2=*?, len=50001
f1=4, f2=*?, len=50001
f1=5, f2=*?, len=50001
f1=6, f2=*?, len=50001
f1=7, f2=*?, len=50001
f1=8, f2=*?, len=50001

</pre>
<a name="sec257f"></a>
<h3><a name="sec257f">Example 7f (with Oracle's LOB column)</a></h3>
<p>
<a name="sec257f">This example works with Oracle 8.0.5.x ODBC drivers
only and requires
the Oracle Client 8.0.5.x as well.
</a></p>
<h4><a name="sec257f">Source code</a></h4>
<pre>
<a name="sec257f"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref121f"></a><h4><font color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#sec222">otl_long_string</a> f2(70000); <i><font color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>

 <a
 href="#ref001">otl_stream</a> o(1, <i><font color="#804000">// buffer size needs to be set to 1 for long strings</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;raw_long&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     );


 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=20;++i){<br>  <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> j=0;j&lt;50000;++j)<br>   f2[j]='*';<br>  f2[50000]='?';<br>  f2.<a
 href="#set_len">set_len</a>(50001);<br>  o<a href="#ref003">&lt;&lt;</a>i<a
 href="#ref003">&lt;&lt;</a>f2;<br> }<br>}<br><br><a name="ref122f"></a><h4><font
 color="#0000a0">void</font> select()</h4>
{ 
 <a href="#sec222">otl_long_string</a> f2(70000); <i><font
 color="#804000">// define long string variable</font></i>
 <a
 href="#set_max">db.set_max_long_size</a>(70000); <i><font
 color="#804000">// set maximum long string size for connect object</font></i>
 <a
 href="#ref001">otl_stream</a> i(1, <i><font color="#804000">// buffer size needs to be set to 1</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 <font
 color="#0000a0">int</font> f1;<br><br> i<a href="#ref003">&lt;&lt;</a>8<a
 href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
   <i><font
 color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br> <br> i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
   <i><font
 color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font
 color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font
 color="#0000a0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font
 color="#804000">// while not end-of-data</font></i>
  i<a
 href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;<br>  cout&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2[0]&lt;&lt;f2[50000]&lt;&lt;<font
 color="#008080">", len="</font>&lt;&lt;f2.len()&lt;&lt;endl;<br> }<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>
 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"UID=scott;PWD=tiger;DSN=my_db"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    <a href="#ref008">otl_exception::disabled</a> <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 lob)"</font>
    );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref121f">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref122f">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a
 href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<pre>
f1=8, f2=*?, len=50001
f1=9, f2=*?, len=50001
f1=10, f2=*?, len=50001
f1=11, f2=*?, len=50001
f1=12, f2=*?, len=50001
f1=13, f2=*?, len=50001
f1=14, f2=*?, len=50001
f1=15, f2=*?, len=50001
f1=16, f2=*?, len=50001
f1=4, f2=*?, len=50001
f1=5, f2=*?, len=50001
f1=6, f2=*?, len=50001
f1=7, f2=*?, len=50001
f1=8, f2=*?, len=50001

</pre>
<h1><a name="sec3">3. STL-compliant iterators for otl_stream </a></h1>
<p>
<a name="sec3">OTL provides two </a><a href="#sec22">otl_stream</a>
based <a href="http://www.sgi.com/Technology/STL/Iterators.html">STL-compliant
iterator</a> classes:
</p>
<ul>
  <li><a href="otl_it01.htm">otl_output_iterator</a></li>
  <li><a href="otl_it02.htm">otl_input_iterator</a></li>
</ul>
<p>
These two iterator classes make it possible to combine the power of <a
 href="http://www.metabyte.com/%7Efbp/stl/readings.html">generic
programming</a> and ODBC into compact, reliable, top performance and
easy-to-maintain C++ database applications.
</p>
<h2><a name="sec31">3.1. Example </a></h2>
<h4><a name="sec31">Source code</a></h4>
<pre>
<a name="sec31"><font color="#ff0000">#include &lt;iostream.h&gt;</font>
<font color="#ff0000">#include &lt;stdio.h&gt;</font>
<font color="#ff0000">#include &lt;otl_iter.h&gt;</font>
<font color="#ff0000">#include &lt;vector.h&gt;</font>
<font color="#ff0000">#include &lt;hash_map.h&gt;</font>
<font color="#ff0000">#include &lt;iterator.h&gt;</font>

</a><a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<i><font color="#804000">// row container class</font></i>
<font color="#0000a0">class</font> row{<br><font color="#0000a0">public</font>:<br> <font
 color="#0000a0">int</font> f1;<br> <font color="#0000a0">char</font> f2[32];<br><br><i><font
 color="#804000">// default constructor</font></i>
 row(){f1=0; f2[0]=0;}

<i><font color="#804000">// destructor</font></i>
 ~row(){}

<i><font color="#804000">// copy constructor</font></i>
 row(<font
 color="#0000a0">const</font> row&amp; row)<br> {<br>  f1=row.f1;<br>  strcpy(f2,row.f2);<br> }<br> <br><i><font
 color="#804000">// assignment operator</font></i>
 row&amp; <font
 color="#0000a0">operator</font>=(<font color="#0000a0">const</font> row&amp; row)<br> {<br>  f1=row.f1;<br>  strcpy(f2,row.f2);<br>  <font
 color="#0000a0">return</font> *<font color="#0000a0">this</font>;<br> }<br><br>};<br><br><i><font
 color="#804000">// redefined operator&gt;&gt; for reading row&amp; from otl_stream</font></i>
<a href="#ref001">otl_stream</a>&amp; <font color="#0000a0">operator</font>&gt;&gt;(<a
 href="#ref001">otl_stream</a>&amp; s, row&amp; row)<br>{<br> s<a
 href="#ref004">&gt;&gt;</a>row.f1<a href="#ref004">&gt;&gt;</a>row.f2;<br> <font
 color="#0000a0">return</font> s;<br>}<br><br><i><font color="#804000">// redefined operator&lt;&lt; for writing row&amp; into otl_stream</font></i>
<a href="#ref001">otl_stream</a>&amp; <font color="#0000a0">operator</font>&lt;&lt;(<a
 href="#ref001">otl_stream</a>&amp; s, <font color="#0000a0">const</font> row&amp; row)<br>{<br> s<a
 href="#ref003">&lt;&lt;</a>row.f1<a href="#ref003">&lt;&lt;</a>row.f2;<br> <font
 color="#0000a0">return</font> s;<br>}<br><br><i><font color="#804000">// redefined operator&lt;&lt; writing row&amp; into ostream</font></i>
ostream&amp; <font
 color="#0000a0">operator</font>&lt;&lt;(ostream&amp; s, <font
 color="#0000a0">const</font> row&amp; row)<br>{<br> s&lt;&lt;<font
 color="#008080">"f1="</font>&lt;&lt;row.f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;row.f2;<br> <font
 color="#0000a0">return</font> s;<br>}<br><br><a name="ref501"></a><h4><font
 color="#0000a0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a
 href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"insert into test_tab values(:1&lt;int&gt;,:2&lt;char[31]&gt;)"</font>, <br>	         <i><font
 color="#804000">// SQL statement</font></i>
	      db // connect object
	     );
 row r; <i><font
 color="#804000">// single row buffer</font></i>
 vector&lt;row&gt; vo; <i><font
 color="#804000">// vector of rows</font></i>

<i><font color="#804000">// populate the vector</font></i>
 <font
 color="#0000a0">for</font>(<font color="#0000a0">int</font> i=1;i&lt;=100;++i){<br>  r.f1=i;<br>  sprintf(r.f2,<font
 color="#008080">"Name%d"</font>,i);<br>  vo.push_back(r);<br> }<br><br> cout&lt;&lt;<font
 color="#008080">"vo.size="</font>&lt;&lt;vo.size()&lt;&lt;endl;<br><i><font
 color="#804000">// insert vector into table</font></i>
 copy(vo.begin(), 
      vo.end(), 
      <a
 href="otl_it01.htm#">otl_output_iterator</a>&lt;row&gt;(o)<br>     );<br><br>}<br><br><a
 name="ref502"></a><h4><font color="#0000a0">void</font> select()</h4>
{ 
 <a
 href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font
 color="#008080">"select * from test_tab where f1&gt;=:1&lt;int&gt; and f1&lt;=:2&lt;int&gt;*2"</font>,<br>	         <i><font
 color="#804000">// SELECT statement</font></i>
	      db <i><font
 color="#804000">// connect object</font></i>
	     ); 
   <i><font
 color="#804000">// create select stream</font></i>
 
 vector&lt;int&gt; inp_par; <i><font
 color="#804000">// vector of 2 elements to demonstrate OTL iterators</font></i>
 vector&lt;row&gt; v; <i><font
 color="#804000">// vector of rows</font></i>

<i><font color="#804000">// assigning :1 = 8, :2 = 8</font></i>
<i><font color="#804000">// this example demonstrates how both input</font></i>
<i><font color="#804000">// and output iterators may be attached to the</font></i>
<i><font color="#804000">// same otl_stream</font></i>

 inp_par.push_back(8); <i><font
 color="#804000">// populate the vector with two elements</font></i>
 inp_par.push_back(8); <i><font
 color="#804000">// populate the vector with two elements</font></i>
 cout&lt;&lt;<font
 color="#008080">"inp_par.size="</font>&lt;&lt;inp_par.size()&lt;&lt;endl;<br><br><i><font
 color="#804000">// copy the vector into the input variable of the select statement</font></i>
 copy(inp_par.begin(),inp_par.end(),<a
 href="otl_it01.htm#">otl_output_iterator</a>&lt;int&gt;(i));<br><br><i><font
 color="#804000"> // SELECT automatically executes when all input variables are</font></i>
<i><font color="#804000"> // assigned. First portion of out rows is fetched to the buffer</font></i>

<i><font color="#804000">// copy all rows to be fetched into the vector</font></i>

 copy(<a
 href="otl_it02.htm#">otl_input_iterator</a>&lt;row,ptrdiff_t&gt;(i), <br>      <a
 href="otl_it02.htm#">otl_input_iterator</a>&lt;row,ptrdiff_t&gt;(),<br>      back_inserter(v));    <br><br> cout&lt;&lt;<font
 color="#008080">"Size="</font>&lt;&lt;v.size()&lt;&lt;endl;<br><br><i><font
 color="#804000">// send the vector to cout</font></i>
 copy(v.begin(), v.end(), ostream_iterator&lt;row&gt;(cout, <font
 color="#008080">"\n"</font>));<br><br><i><font color="#804000">// clean up the vector</font></i>
 v.erase(v.begin(),v.end());

<i><font color="#804000">// OTL traditional technique</font></i>
  i<a
 href="#ref003">&lt;&lt;</a>4<a href="#ref003">&lt;&lt;</a>4; <i><font
 color="#804000">// assigning :1 = 4, :2 = 4</font></i>
<i><font color="#804000">   // SELECT automatically executes when all input variables are</font></i>
<i><font color="#804000">   // assigned. First portion of out rows is fetched to the buffer</font></i>

<i><font color="#804000">// copy all rows to be fetched to the vector</font></i>
 copy(otl_input_iterator&lt;row,ptrdiff_t&gt;(i), 
      otl_input_iterator&lt;row,ptrdiff_t&gt;(),
      back_inserter(v));    

 cout&lt;&lt;<font
 color="#008080">"Size="</font>&lt;&lt;v.size()&lt;&lt;endl;<br><br><i><font
 color="#804000">// send the vector to cout</font></i>
 copy(v.begin(), v.end(), ostream_iterator&lt;row&gt;(cout, <font
 color="#008080">"\n"</font>));<br><br>}<br><br><h4><font
 color="#0000a0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font
 color="#804000">// initialize ODBC environment</font></i>

 <font
 color="#0000a0">try</font>{<br><br>  db.<a href="#ref007">rlogon</a>(<font
 color="#008080">"DSN=MY_DB;PWD=TIGER;UID=SCOTT"</font>); <i><font
 color="#804000">// connect to data source MY_DB</font></i>

  <a
 href="#sec24">otl_cursor::direct_exec</a>
   (db,
    <font
 color="#008080">"drop table test_tab"</font>,<br>    otl_exception::disabled <i><font
 color="#804000">// disable OTL exceptions</font></i>
   ); <i><font
 color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (db,
    <font
 color="#008080">"create table test_tab(f1 int, f2 varchar(30))"</font>
   );  <i><font
 color="#804000">// create table</font></i>

  <a href="#ref501">insert()</a>; <i><font
 color="#804000">// insert records into table</font></i>
  <a
 href="#ref502">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font
 color="#0000a0">catch</font>(<a href="#sec23">otl_exception</a>&amp; p){ <i><font
 color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.code</a>&lt;&lt;endl; <i><font color="#804000">// print out error code</font></i>
  cerr&lt;&lt;<a
 href="#sec23">p.sqlstate</a>&lt;&lt;endl; <i><font color="#804000">// print out SQLSTATE message</font></i>
  <font
 color="#0000a0">if</font>(p.stm_text)<br>   cerr&lt;&lt;<a
 href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 db.<a
 href="#ref009">logoff(</a>); <i><font color="#804000">// disconnect from the data source</font></i>

 <font
 color="#0000a0">return</font> 0;<br><br>}<br><br></pre>
<h4>Output</h4>
<xmp>
vo.size=100
inp_par.size=2
Size=9
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
Size=5
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8
</xmp>
<h1><a name="app_a">Appendix A. How to download the source code</a></h1>
<p><a name="app_a">In order to obtain a copy of the OTL header files,
send email to </a><a href="mailto:skuchin@aceweb.com">skuchin@aceweb.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.comgmail</a></p>
<p><a href="mailto:skuchin@gmail.com">Here is the list of the OTL
header files:</a></p>
<ul>
  <li><a href="mailto:skuchin@gmail.com"><i><font color="#804040">otlodbc.h</font>
    </i>-- the OTL source code
for ODBC 2.5. Save the file as otl.h. </a></li>
  <li><a href="mailto:skuchin@gmail.com"><i><font color="#804040">otl_iter.h</font></i>
-- STL-compliant iterators
for otl_stream </a></li>
</ul>
<p>
<a href="mailto:skuchin@gmail.com">Besides, you need to have standard
ODBC32 and MFC header files and
object libraries. See the corresponding manuals for more detail.
</a></p>
<p>
<a href="mailto:skuchin@gmail.com">The header files to be included are
as follows:
</a></p>
<ul>
  <li><a href="mailto:skuchin@gmail.com">afx.h</a></li>
  <li><a href="mailto:skuchin@gmail.com">sql.h</a></li>
  <li><a href="mailto:skuchin@gmail.com">sqlext.h</a></li>
</ul>
<p></p>
<p>
<a href="mailto:skuchin@gmail.com">If you want to use the </a><a
 href="#sec3">STL-compliant iterators</a>
then you are going to need the <a
 href="http://www.metabyte.com/%7Efbp/stl/">Standard Template Library</a>
(adaption by <a href="mailto:fbp@metabyte.com">Boris Fomitchev</a>) or
<a href="http://www.sgi.com/Technology/STL/">the original STL SGI,
version 3.11</a>.
</p>
<h1><a name="app_b">Appendix B. OTL exception list</a></h1>
<p>
<a name="app_b">The following </a><a href="#sec23">OTL exceptions</a>
can be raised by the
OTL functions:
</p>
<dl>
  <dt><b>Code=32000</b>: Incompatible data types in stream operation
  </dt>
  <dd><br>
    <b>Cause</b>: The data type of a variable used in the current
stream operation is not compatible with the declared stream format.
    <br>
    <br>
    <b>Action</b>: Check placeholders and their data types declaration.
  </dd>
  <dt><br>
    <b>Code=32001</b>: Row must be full for flushing output stream
  </dt>
  <dd><br>
    <b>Cause</b>: Stream is open for output and has a format of output
rows. An output row is a tuple of all output variables put together.
The current output row is not filled yet but the flush function is
invoked. The stream buffer cannot be flushed until the current row of
the output buffer is full.
    <br>
    <br>
    <b>Action</b>: Fill the row first, then flush the stream.
  </dd>
  <dt><br>
    <b>Code=32004</b>: Not all input variables have been initialized
  </dt>
  <dd><br>
    <b>Cause</b>: stream has input variables but not all the variables
have been initialized. An attempt to read data from the stream was
made.
    <br>
    <br>
    <b>Action</b>: Assign all the input variables first.
  </dd>
  <dt><br>
    <b>Code=32004</b>: No input variables have been defined in SQL
statement
  </dt>
  <dd><br>
    <b>Cause</b>: Stream has no input variables. An attempt to write
objects to the stream via one of the &lt;&lt; operators was made.
    <br>
    <br>
    <b>Action</b>: Do not call the &lt;&lt; operators for streams which
have no input variables defined.
  </dd>
</dl>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5456201-1");
pageTracker._trackPageview();
</script>
</body>
</html>
